---
title: Учебник. Проверка
description: Использование функций Azure в Visual Studio для Mac.
author: conceptdev
ms.author: crdun
ms.date: 05/06/2018
ms.topic: article
ms.technology: vs-ide-install
ms.assetid: 38FD2070-5151-482E-B0A9-993715128736
ms.openlocfilehash: d6a0683405340d479fb3289540ffde2c5e7a4f78
ms.sourcegitcommit: da73f7a0cf1795d5d400c0897ae3326191435dd0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2019
ms.locfileid: "58568726"
---
# <a name="tutorial-getting-started-with-azure-functions"></a>Учебник. Начало работы с функциями Azure

В этом руководстве вы узнаете, как приступить к созданию функций Azure с помощью Visual Studio для Mac. Вы также выполните интеграцию с таблицами хранилища Azure — один из многих видов привязок и триггеров, доступных разработчикам функций Azure.

## <a name="objectives"></a>Цели

> [!div class="checklist"]
> * Создание и отладка локальных функций Azure
> * Интеграция с веб и ресурсами хранилища Azure
> * Управление ходом рабочего процесса, в который входит несколько функций Azure

## <a name="requirements"></a>Требования

- Visual Studio для Mac 7.5 или более поздней версии.
- Подписка Azure (доступна бесплатно по адресу [https://azure.com/free](https://azure.com/free)).

## <a name="exercise-1-creating-an-azure-functions-project"></a>Упражнение 1. Создание проекта функций Azure

1. Запустите **Visual Studio для Mac**.

2. Выберите **Файл > Новое решение**.

3. В категории **Облако > Общие** выберите шаблон **Функции Azure**. Вы будете использовать C# для создания библиотеки классов .NET, в которой размещаются функции Azure. Нажмите кнопку **Далее**.

    ![Выбор шаблона функций Azure](media/azure-functions-lab-image1.png)

4. Задайте **имя проекта** **AzureFunctionsLab** и нажмите **Создать**.

    ![именование и создание проекта функций azure](media/azure-functions-lab-image2.png)

5. Разверните узлы на **панели решения**. Шаблон проекта по умолчанию включает ссылки NuGet на различные пакеты AzureWebJobs, а также на пакет Newtonsoft.Json.

     Также существует три файла: — **host.json** для описания глобальных параметров конфигурации для узла. — **local.settings.json** для настройки параметров службы.
        — Шаблон проекта также создает HttpTrigger по умолчанию. В целях этого руководства удалите файл **HttpTrigger.cs** из проекта.

    Откройте файл **local.settings.json**. По умолчанию в нем имеется два параметра пустой строки подключения.

    ![панель решения с файлом local.settings.json](media/azure-functions-lab-image3.png)

## <a name="exercise-2-creating-an-azure-storage-account"></a>Упражнение 2. Создание учетной записи службы хранилища Azure

1. Войдите в учетную запись Azure по адресу [https://portal.azure.com](https://portal.azure.com).

1. В разделе **Избранное**, расположенном в левой части экрана, выберите **Учетная запись хранения**:

    ![раздел "избранное" на портале Azure с элементом "учетная запись хранения"](media/azure-functions-lab-image4.png)

1. Нажмите **Добавить**, чтобы создать новую учетную запись хранения:

    ![Кнопка для добавления новой учетной записи хранения](media/azure-functions-lab-image5.png)

1. Введите глобальное уникальное имя для поля **Имя** и используйте его повторно для **группы ресурсов**. Оставьте значения остальных элементов по умолчанию.

    ![сведения о новой учетной записи хранения](media/azure-functions-lab-image6.png)

1. Нажмите кнопку **Создать**. Создание учетной записи хранения может занять несколько минут. Вы получите уведомление об успешном создании.

    ![уведомления об успехе развертывания](media/azure-functions-lab-image7.png)

1. Нажмите на кнопку **Перейти к ресурсу** в уведомлении.

1. Выберите вкладку **Ключи доступа**.

    ![настройка ключа доступа](media/azure-functions-lab-image8.png)

1. Скопируйте первую **строку подключения**. Эта строка позже используется для интеграции хранилища Azure с функциями Azure.

    ![сведения для ключа 1](media/azure-functions-lab-image9.png)

1. Вернитесь в **Visual Studio для Mac** и вставьте полную строку подключения как параметр **AzureWebJobsStorage** в файле **local.settings.json**. Теперь можно ссылаться на имя параметра в атрибутах для функций, которым требуется доступ к его ресурсам.

    ![локальный файл параметров с введенным ключом подключения](media/azure-functions-lab-image10.png)

## <a name="example-3-creating-and-debugging-an-azure-function"></a>Пример 3. Создание и отладка функции Azure

1. Теперь вы готовы приступить к добавлению кода. При работе с библиотекой классов .NET функции Azure добавляются как статические методы. На **Панели решения** щелкните правой кнопкой мыши узел проекта **AzureFunctions** и выберите **Добавить > Добавить функцию**.

    ![пункт "Добавить функцию"](media/azure-functions-lab-image11.png)

1. В диалоговом окне "Новые функции Azure" выберите шаблон универсального веб-перехватчика. Укажите для параметра **Имя** значение **Добавить** и нажмите кнопку **ОК** для создания функции:

    ![диалоговое окно создания функции azure](media/azure-functions-lab-image12.png)

1. В начале нового файла добавьте следующие директивы **using**:

    ```csharp
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using System.Web;
    using Microsoft.WindowsAzure.Storage.Table;
    ```
1. Удалите существующий метод `Run` и добавьте в класс следующий метод в качестве функции Azure:

    ```csharp
    [FunctionName("Add")]
    public static int Run(
    [HttpTrigger(AuthorizationLevel.Function, "get", Route = null)]
    HttpRequestMessage req,
    TraceWriter log)
    {
        int x = 1;
        int y = 2;

        return x + y;
    }
    ```
1. Давайте подробно рассмотрим определение метода.

    Прежде всего вы увидите атрибут **FunctionName**, который помечает этот метод как функцию Azure. Этот атрибут определяет открытое имя функции. Имя атрибута не должно соответствовать имени фактического метода.

    ![Новый метод Run с выделенным атрибутом FunctionName](media/azure-functions-lab-image13.png)

1. Затем метод помечается как метод **public static**, который является обязательным. Вы заметите, что возвращается значение **int**. Если не указано иначе с помощью атрибутов метода, все непустые возвращаемые значения функции Azure возвращаются клиенту в виде текста. По умолчанию они возвращаются как **XML**, но позднее мы рассмотрим, как изменить формат на **JSON**.

    ![Новый метод run с выделенным методом инициализации](media/azure-functions-lab-image14.png)

1. Первый параметр помечается атрибутом **HttpTrigger**, который указывает, что этот метод вызывается HTTP-запросом. Атрибут также указывает уровень авторизации данного метода и поддерживаемые им команды (только **GET** в данном случае). По желанию вы можете определить параметр **Route**, который переопределяет путь к методу и предлагает способ автоматического извлечения переменных из пути. Поскольку в данном случае **Route** имеет значение NULL, будет использоваться путь к этому методу по умолчанию — **/api/Add**.

    ![Новый метод run с выделенным параметром](media/azure-functions-lab-image15.png)

1. Последний параметр метода — это **TraceWriter**, который может использоваться для записи сообщений о диагностике и ошибках.

    ![Новый метод run с выделенным TraceWriter](media/azure-functions-lab-image16.png)

1. Установите точку останова в строке **return** этого метода, нажав на поле строки:

    ![Точка останова в строке return](media/azure-functions-lab-image17.png)

1. Скомпилируйте и запустите проект в сеансе отладки, нажав **F5** или выбрав **Запустить > Начать отладку**. Или нажмите на кнопку **Запуск**. Все варианты выполняют одну задачу. Далее в инструкциях будет упоминаться клавиша **F5**, но вы можете использовать наиболее удобный метод.

    ![Компиляция и запуск проекта](media/azure-functions-lab-image18.png)

1. При запуске проекта будет автоматически открыто приложение терминала.

1. В проекте выполняется процесс обнаружения функций Azure на основе атрибутов метода и соглашения для файлов, которые будут рассматриваться далее в этой статье. В этом случае он обнаруживает одну функцию Azure и создает 1 функциональную обязанность.

    ![Выходные данные функции Azure в терминале](media/azure-functions-lab-image19.png)

1. В нижней части сообщения о запуске узел функций Azure выводит URL-адреса API триггеров HTTP. Там должен быть только один адрес. Скопируйте его и вставьте в новой вкладке браузера.

    ![URL-адрес API функций Azure](media/azure-functions-lab-image20.png)

1. Сразу должна сработать точка останова. Веб-запрос был направлен в функцию и теперь готов для отладки. Наведите указатель мыши на переменную **x** для просмотра ее значения.

    ![Срабатывание точки останова](media/azure-functions-lab-image21.png)

1. Удалите точку останова, используя тот же метод, который вы применяли для ее добавления (щелкните на поле или выберите строку и нажмите клавишу **F9**).

1. Чтобы продолжить выполнение, нажмите клавишу **F5**.

1. В браузере будут отображаться результаты метода в формате XML. Как и ожидалось, жестко закодированная операция сложения выдает достоверную сумму. Если в Safari вы видите только 3, перейдите в меню **Safari > Параметры > Дополнительно**, поставьте флажок **Показывать меню "Разработка" в строке меню** и перезагрузите страницу.

1. В **Visual Studio для Mac** нажмите кнопку **Остановить**, чтобы завершить сеанс отладки. Чтобы применить изменения, перезапустите (остановите и снова запустите) сеанс отладки.

    ![Вариант остановки отладки](media/azure-functions-lab-image22.png)

1. В методе **Run** замените определения **x** и **y** следующим кодом. Этот код извлекает значения из строки запроса URL-адреса, чтобы операция сложения выполнялась динамически в зависимости от предоставленных параметров.

    ```csharp
    var query = HttpUtility.ParseQueryString(req.RequestUri.Query);

    int x = int.Parse(query["x"]);

    int y = int.Parse(query["y"]);

    return x + y;
    ```
1. Запустите приложение.

1. Вернитесь в окно браузера и добавьте строку `/?x=2&y=3` в URL-адрес. Теперь URL-адрес должен выглядеть следующим образом: `http://localhost:7071/api/Add?x=2&y=3`. Перейдите по новому URL-адресу.

1. На этот раз результат должен отражать новые параметры. Вы можете запустить проект с другими значениями. Проверка ошибок не выполняется, поэтому в случае недопустимых или отсутствующих параметров возникнет ошибка.

1. Остановите сеанс отладки.


## <a name="exercise-4-working-with-functionjson"></a>Упражнение 4. Работа с function.json

1.  В предыдущем упражнении говорилось, что в Visual Studio для Mac создается функциональная обязанность для функции Azure, определенной в библиотеке. Дело в том, что функции Azure не используют атрибуты метода в среде выполнения, но используют соглашение для файловой системы во время компиляции для настройки времени и способа предоставления функций Azure. На **панели решения** щелкните правой кнопкой мыши узел проекта и выберите **Отобразить в средстве поиска**.

     ![Пункт меню "Отобразить в средстве поиска"](media/azure-functions-lab-image23.png)

1. Перейдите к файловой системе до пункта **bin/Debug/netstandard2.0**. Найдите папку с именем **Add**. Эта папка была создана по атрибуту имени функции в коде C#. Разверните папку Add. Там находится один файл **function.json**. Этот файл используется средой выполнения для размещения и управления функцией Azure. Для других языковых моделей без поддержки среды компиляции (например, скрипт C# или JavaScript) эти папки необходимо создать вручную. Для разработчиков C# они создаются автоматически из метаданных атрибута при сборке. Щелкните правой кнопкой мыши файл **function.json** и откройте его в Visual Studio.

    ![function.json в каталоге файлов](media/azure-functions-lab-image24.png)

1. Учитывая уже выполненные шаги в этом руководстве, вы имеете общее представление об атрибутах C#. Так что этот файл JSON должен быть вам знаком. Но следует обсудить еще несколько аспектов, о которых мы не говорили ранее. Например, для каждого элемента привязки **binding** необходимо задать направление **direction**. Очевидно, что **in** означает входной параметр, а **out** — это либо возвращаемое значение (через **$return**), либо параметр **out** для метода. В сборке также необходимо указать **scriptFile** (относительно этого конечного расположения) и метод **entryPoint** (открытый и статический). В следующих шагах мы добавим пользовательский путь к функции с помощью этой модели, поэтому скопируйте содержимое этого файла в буфер обмена.

    ![файл function.json открыт в visual studio для mac](media/azure-functions-lab-image25.png)

1. На **панели решений** щелкните правой кнопкой мыши узел проекта **AzureFunctionsLab** и выберите **Добавить > Новая папка**. Назовите папку **Adder**. В соответствии с соглашением по умолчанию имя этой папки будет определять путь к API, например **api/Adder**.

    ![пункт "новая папка"](media/azure-functions-lab-image26.png)

1. Щелкните правой кнопкой мыши папку **Adder** и выберите **Добавить > Новый файл**.

    ![пункт "новый файл"](media/azure-functions-lab-image27.png)

1. Выберите категорию **Веб** и шаблон **Пустой файл JSON**. Задайте **Имя** **function** и нажмите **Создать**.

    ![пункт "пустой файл json"](media/azure-functions-lab-image28.png)

1. Вставьте содержимое из другого файла **function.json** (из шага 3), чтобы заменить содержимое по умолчанию только что созданного файла.

1. Удалите следующие строки в верхней части файла json:

    ```json
    "configurationSource":"attributes",
    "generatedBy":"Microsoft.NET.Sdk.Functions-1.0.13",
    ```

1. В конце первой привязки (после строки **"name": "req"**) добавьте следующие свойства. Не забудьте поставить запятую в предыдущей строке. Это свойство переопределяет маршрут по умолчанию. Теперь он извлечет параметры **int** из пути и поместит их в параметры метода с именами **x** и **y**.

    ```json
    "direction": "in",
    "route": "Adder/{x:int?}/{y:int?}"
    ```

1. Добавьте другую привязку под первой. Эта привязка обрабатывает возвращаемое значение функции. Не забудьте поставить запятую в предыдущей строке:

    ```json
    {
    "name": "$return",
    "type": "http",
    "direction": "out"
    }
    ```

1. Обновите свойство **entryPoint** в нижней части файла, чтобы использовать метод **Add2**, как показано ниже. Это показывает, что путь **api/Adder...** можно сопоставить с соответствующим методом с любым именем (в данном случае — **Add2**).

    ```json
    "entryPoint": "<project-name>.<function-class-name>.Add2"
    ```

1. Окончательный файл **function.json** должен выглядеть следующим образом:

    ```json
    {
    "bindings": [
        {
        "type": "httpTrigger",
        "methods": [
            "get"
        ],
        "authLevel": "function",
        "direction": "in",
        "name": "req",
        "route": "Adder/{x:int?}/{y:int?}"
        },
        {
        "name": "$return",
        "type": "http",
        "direction": "out"
        }
    ],
    "disabled": false,
    "scriptFile": "../bin/AzureFunctionsProject.dll",
    "entryPoint": "AzureFunctionsProject.Add.Add2"
    }
    ```

1. Чтобы все это работало, необходимо сделать последний шаг — дать Visual Studio для Mac указание копировать этот файл в тот же относительный путь в выходном каталоге при каждом изменении. Выберите файл, откройте вкладку свойств на правой панели и для пункта **Копировать в выходной каталог** выберите **Копировать более позднюю версию**:

    ![Параметры свойств для JSON-файла](media/azure-functions-lab-image30.png)

1. В **Add.cs** замените метод `Run` (включая атрибут) следующим методом для выполнения ожидаемой функции. Это очень похоже на метод `Run`, только он не использует атрибуты и имеет явные параметры для **x** и **y**.

    ```csharp
    public static int Add2(
        HttpRequestMessage req,
        int x,
        int y,
        TraceWriter log)
    {
        return x + y;
    }
    ```
1. Нажмите клавишу **F5** для сборки и запуска проекта.

1. После завершения сборки и запуска платформы вы увидите, что существует второй маршрут для запросов, сопоставляемый с добавленным методом:

    ![URL-адрес для функций HTTP](media/azure-functions-lab-image31.png)

1. Вернитесь в окно браузера и перейдите к **http://localhost:7071/api/Adder/3/5**.

1. На этот раз метод сработает снова, извлекая параметры из пути и рассчитывая сумму.

1. Вернитесь в **Visual Studio для Mac** и завершите сеанс отладки.

## <a name="exercise-5-working-with-azure-storage-tables"></a>Упражнение 5. Работа с таблицами хранилища Azure

Часто вы будете создавать гораздо более сложные службы, чем в этом руководстве, и вам потребуется значительно больше времени и ресурсов инфраструктуры. В этом случае эффективнее будет принимать запросы, помещенные в очередь на обработку, когда ресурсы будут доступны. Функции Azure поддерживают такой вариант. В других случаях данные можно хранить централизованно. Для этого удобно использовать таблицы хранилища Azure.

1. Добавьте следующий класс в **Add.cs**. Он добавляется в пространство имен, но за пределами существующего класса.

    ```csharp
    public class TableRow : TableEntity
    {
        public int X { get; set; }
        public int Y { get; set; }
        public int Sum { get; set; }
    }
    ```
1. Добавьте в класс **Add** следующий код, чтобы ввести еще одну функцию. Этот код уникален, поскольку не содержит HTTP-ответов. Последняя строка возвращает новый объект **TableRow**, содержащий ключевую информацию, которую будет легко извлечь позже (**PartitionKey** и **RowKey**), а также его параметры и сумму. Код в этом методе также использует **TraceWriter**, чтобы вам было проще понимать, когда функция выполняется.

    ```csharp
    [FunctionName("Process")]
    [return: Table("Results")]
    public static TableRow Process(
        [HttpTrigger(AuthorizationLevel.Function, "get",
            Route = "Process/{x:int}/{y:int}")]
        HttpRequestMessage req,
        int x,
        int y,
        TraceWriter log)
    {
        log.Info($"Processing {x} + {y}");

        return new TableRow()
        {
            PartitionKey = "sums",
            RowKey = $"{x}_{y}",
            X = x,
            Y = y,
            Sum = x + y
        };
    }
    ```
1. Нажмите клавишу **F5** для сборки и запуска проекта.

1. На вкладке браузера перейдите по адресу **http://localhost:7071/api/Process/4/6**. В результате в очередь встанет еще одно сообщение, и в конечном итоге в таблицу будет добавлена еще одна строка.

1. Вернитесь в **терминал** и следите за входящим запросом для **4 + 6**.

    ![Выходные данные терминала с запросом на сложение](media/azure-functions-lab-image32.png)

1. Вернитесь в браузер и обновите запрос, указав тот же URL-адрес. На этот раз вы увидите ошибку после метода **Process**. Дело в том, что код пытается добавить строку в таблицу хранилища таблиц Azure с помощью комбинации ключа раздела и строки, которая уже существует.

    ```
    System.Private.CoreLib: Exception while executing function: Process. Microsoft.Azure.WebJobs.Host: Error while handling parameter $return after function returned:. Microsoft.Azure.WebJobs.Host: The specified entity already exists.
    ```

1. Остановите сеанс отладки.

1. Чтобы устранить ошибку, добавьте следующий параметр в определение метода непосредственно перед параметром **TraceWriter**. Этот параметр дает платформе функций Azure указание попытаться извлечь **TableRow** из таблицы **Results** в **PartitionKey**, который мы использовали для хранения результатов. Настоящее волшебство происходит тогда, когда вы заметите, что **RowKey** создается динамически на основе других параметров **x** и **y** для этого же метода. Если эта строка уже существует, **tableRow** получит ее при запуске метода без дополнительных усилий со стороны разработчика. Если строка не существует, она будет иметь значение NULL. Благодаря этой возможности разработчики могут сосредоточиться на важной бизнес-логике, а не на инфраструктуре.

    ```csharp
    [Table("Results", "sums", "{x}_{y}")]
    TableRow tableRow,
    ```
1. Добавьте следующий код в начало метода. Если **tableRow** не имеет значение NULL, значит, у нас уже есть результаты для запрашиваемой операции и мы можем получить их незамедлительно. В противном случае функция будет работать, как раньше. Возможно, это не самый надежный способ получить данные, но он иллюстрирует тот факт, что вы можете выполнять невероятно сложные операции на нескольких масштабируемых уровнях с небольшим фрагментом кода.

    ```csharp
    if (tableRow != null)
    {
        log.Info($"{x} + {y} already exists");
        return null;
    }
    ```
1. Нажмите клавишу **F5** для сборки и запуска проекта.

1. На вкладке браузера измените URL-адрес: **http://localhost:7071/api/Process/4/6**. Поскольку для этой записи уже существует строка в таблице, она будет возвращена немедленно и без ошибок. Раз выходных данных HTTP нет, результат можно увидеть в терминале.

    ![Выходные данные в терминале с уже существующей строкой таблицы](media/azure-functions-lab-image33.png)

1. Обновите URL-адрес, указав еще не протестированную комбинацию, например **http://localhost:7071/api/Process/5/7**. Обратите внимание на сообщение в терминале, которое указывает, что строка таблицы не найдена (как и ожидалось).

    ![Выходные данные в терминале с новым процессом](media/azure-functions-lab-image34.png)

1. Вернитесь в **Visual Studio для Mac** и завершите сеанс отладки.

<!--
1. Finally, let's take a look at what it's like to work with multiple input records. Rather than specify a specific **TableRow**, you can request an **IQueryable<TableRow>** using the same attributes, and the runtime will fill it with the appropriate resource you need. Add the code below to create a **List** function that lists all items that currently exist in the Azure table we've been working with. Also note that we're specifying that the MIME type of the response is **application/json**, so the runtime will automatically render as JSON.

    ```csharp
    [FunctionName("List")]
    public static HttpResponseMessage List(
        [HttpTrigger(AuthorizationLevel.Function, "get", Route = null)]
        HttpRequestMessage req,
        [Table("Results", "sums")]
        IQueryable<TableRow> table,
        TraceWriter log)
    {
        return req.CreateResponse(HttpStatusCode.OK, table, "application/json");
    }
    ```
1. Press **F5** to build and run the project.

1. In the browser tab, navigate to **http://localhost:7071/api/List**. This should pull down the list of all items in the Azure table and render it as JSON.

    ![](https://user-images.githubusercontent.com/3944468/29033725-be9d5a5e-7b4a-11e7-8b55-df0a200b6320.png)
-->

## <a name="summary"></a>Сводка

В этом руководстве вы узнали, как приступить к созданию функций Azure с помощью Visual Studio для Mac.

