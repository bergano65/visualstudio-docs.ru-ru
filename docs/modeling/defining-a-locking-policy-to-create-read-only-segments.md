---
title: Определение политики блокировки для создания сегментов, доступных только для чтения
description: Узнайте, как определить политику для программы, чтобы заблокировать часть или всю модель доменного языка (DSL), чтобы ее можно было читать, но не изменять.
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
author: JoshuaPartlow
ms.author: joshuapa
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: aa7590689b4d7acdb7a7ebe501584ed6a8bd41bf
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99935421"
---
# <a name="defining-a-locking-policy-to-create-read-only-segments"></a>Определение политики блокировки для создания сегментов, доступных только для чтения
API неизменности пакета SDK визуализации и моделирования Visual Studio позволяет программе заблокировать часть или всю модель доменного языка (DSL), чтобы ее можно было читать, но не изменять. Этот параметр доступен только для чтения, например, чтобы пользователь мог попросить коллег закомментировать и проверить модель DSL, но может запретить им изменять исходное значение.

 Кроме того, в качестве автора DSL можно определить *политику блокировки.* Политика блокировки определяет, какие блокировки разрешены, не разрешены или являются обязательными. Например, при публикации DSL можно рекомендовать сторонним разработчикам расширять его с помощью новых команд. Но можно также использовать политику блокировки, чтобы предотвратить изменение состояния только для чтения указанных частей модели.

> [!NOTE]
> Политику блокировки можно обойти с помощью отражения. Она предоставляет четкие границы для сторонних разработчиков, но не обеспечивает надежную защиту.

 Дополнительные сведения и примеры доступны на веб-сайте [SDK визуализации и моделирования](https://code.msdn.microsoft.com/Visualization-and-Modeling-313535db) Visual Studio.

[!INCLUDE[modeling_sdk_info](includes/modeling_sdk_info.md)]

## <a name="setting-and-getting-locks"></a>Установка и получение блокировок
 Можно установить блокировки для хранилища, для секции или для отдельного элемента. Например, эта инструкция предотвращает удаление элемента модели и также предотвратит изменение его свойств:

```csharp
using Microsoft.VisualStudio.Modeling.Immutability; ...
element.SetLocks(Locks.Delete | Locks.Property);
```

 Другие значения блокировки можно использовать для предотвращения изменений связей, создания элементов, перемещения между секциями и повторного упорядочения ссылок в роли.

 Блокировки применяются как к действиям пользователя, так и к программному коду. Если код программы пытается внести изменение, `InvalidOperationException` будет создано исключение. Блокировки игнорируются при выполнении операции отмены или повтора.

 Можно определить, имеет ли элемент блокировку в заданном наборе с помощью `IsLocked(Locks)` , а также получить текущий набор блокировок для элемента с помощью `GetLocks()` .

 Вы можете установить блокировку без использования транзакции. База данных блокировки не является частью хранилища. Если установить блокировку в ответ на изменение значения в магазине, например в Онвалуечанжед, следует разрешить изменения, которые являются частью операции отмены.

 Эти методы являются методами расширения, определенными в <xref:Microsoft.VisualStudio.Modeling.Immutability> пространстве имен.

### <a name="locks-on-partitions-and-stores"></a>Блокировки на секции и хранилища
 Блокировки также можно применять к секциям и магазину. Блокировка, заданная для секции, применяется ко всем элементам в секции. Поэтому, например, следующая инструкция предотвратит удаление всех элементов в секции независимо от состояний собственных блокировок. Тем не менее, другие блокировки, такие как, `Locks.Property` могут быть установлены для отдельных элементов:

```csharp
partition.SetLocks(Locks.Delete);
```

 Блокировка, заданная для хранилища, применяется ко всем его элементам независимо от параметров этой блокировки в секциях и элементах.

### <a name="using-locks"></a>Использование блокировок
 Можно использовать блокировки для реализации схем, таких как следующие примеры:

- Запретить изменения для всех элементов и связей, кроме тех, которые представляют комментарии. Это позволяет пользователям закомментировать модель, не изменяя ее.

- Запретить изменения в разделе по умолчанию, но разрешить изменения в секции диаграммы. Пользователь может перестроить диаграмму, но не может изменить базовую модель.

- Запретить изменения в магазине, кроме группы пользователей, зарегистрированных в отдельной базе данных. Для других пользователей схема и модель доступны только для чтения.

- Запретить изменения в модели, если логическое свойство схемы имеет значение true. Укажите команду меню, чтобы изменить это свойство. Это гарантирует, что пользователи не будут случайно вносить изменения.

- Запретить добавление и удаление элементов и связей конкретных классов, но разрешить изменение свойств. Это дает пользователям фиксированную форму, в которой они могут заполнять свойства.

## <a name="lock-values"></a>Заблокировать значения
 Блокировки можно задать для хранилища, секции или отдельных ModelElement. "Блокировки" — это `Flags` перечисление. его значения можно комбинировать с помощью "&#124;".

- Блокировки ModelElement всегда включают блокировки своего раздела.

- Блокировки секции всегда содержат блокировки хранилища.

  Нельзя установить блокировку для секции или хранилища и одновременно отключить блокировку для отдельного элемента.

|Значение|Значение `IsLocked(Value)` , если имеет значение true|
|-|-|
|Отсутствуют|Без ограничений.|
|Свойство|Свойства домена элементов не могут быть изменены. Это не относится к свойствам, создаваемым ролью доменного класса в связи.|
|Добавить|Новые элементы и ссылки не могут быть созданы в разделе или хранилище.<br /><br /> Неприменимо к `ModelElement` .|
|Переместить|Невозможно переместить элемент между секциями `element.IsLocked(Move)` , если имеет значение true, или `targetPartition.IsLocked(Move)` значение true.|
|DELETE|Элемент не может быть удален, если эта блокировка задана для самого элемента или для любого элемента, к которому будет распространяться удаление, например внедренные элементы и фигуры.<br /><br /> Можно использовать `element.CanDelete()` , чтобы определить, можно ли удалить элемент.|
|Переупорядочить|Невозможно изменить порядок ссылок в RolePlayer.|
|RolePlayer|Набор ссылок, источником которых является этот элемент, изменить нельзя. Например, новые элементы не могут быть внедрены в этот элемент. Это не влияет на связи, для которых этот элемент является целевым.<br /><br /> Если этот элемент является ссылкой, то его источник и целевой объект не затрагиваются.|
|Все|Побитовое или для других значений.|

## <a name="locking-policies"></a>Политики блокировки
 Как автор DSL вы можете определить *политику блокировки*. Политика блокировки является средним действием Сетлоккс (), что позволяет предотвращать установку конкретных блокировок или задавать необходимость установки конкретных блокировок. Как правило, политика блокировки используется, чтобы запретить пользователям или разработчикам случайно контравенинг предполагаемое использование DSL, точно так же, как вы можете объявить переменную `private` .

 Можно также использовать политику блокировки для установки блокировок всех элементов, зависящих от типа элемента. Это вызвано тем, что `SetLocks(Locks.None)` всегда вызывается при первом создании или десериализации элемента из файла.

 Однако нельзя использовать политику для изменения блокировок элемента в течение его жизненного цикла. Для достижения этого результата следует использовать вызовы метода `SetLocks()` .

 Чтобы определить политику блокировки, необходимо выполнить следующие действия.

- Создайте класс, реализующий <xref:Microsoft.VisualStudio.Modeling.Immutability.ILockingPolicy>.

- Добавьте этот класс в службы, доступные через DocData вашего DSL.

### <a name="to-define-a-locking-policy"></a>Определение политики блокировки
 <xref:Microsoft.VisualStudio.Modeling.Immutability.ILockingPolicy> имеет следующее определение:

```csharp
public interface ILockingPolicy
{
  Locks RefineLocks(ModelElement element, Locks proposedLocks);
  Locks RefineLocks(Partition partition, Locks proposedLocks);
  Locks RefineLocks(Store store, Locks proposedLocks);
}
```

 Эти методы вызываются при вызове метода `SetLocks()` в хранилище, секции или ModelElement. В каждом методе предоставляется предложенный набор блокировок. Вы можете вернуть предложенный набор или добавить и вычесть блокировки.

 Пример:

```csharp
using Microsoft.VisualStudio.Modeling;
using Microsoft.VisualStudio.Modeling.Immutability;
namespace Company.YourDsl.DslPackage // Change
{
  public class MyLockingPolicy : ILockingPolicy
  {
    /// <summary>
    /// Moderate SetLocks(this ModelElement target, Locks locks)
    /// </summary>
    /// <param name="element">target</param>
    /// <param name="proposedLocks">locks</param>
    /// <returns></returns>
    public Locks RefineLocks(ModelElement element, Locks proposedLocks)
    {
      // In my policy, users can never delete an element,
      // and other developers cannot easily change that:
      return proposedLocks | Locks.Delete);
    }
    public Locks RefineLocks(Store store, Locks proposedLocks)
    {
      // Only one user can change this model:
      return Environment.UserName == "aUser"
           ? proposedLocks : Locks.All;
    }
```

 Чтобы гарантировать, что пользователи всегда могут удалять элементы, даже если другие вызовы кода `SetLocks(Lock.Delete):`

 `return proposedLocks & (Locks.All ^ Locks.Delete);`

 Чтобы запретить изменение во всех свойствах каждого элемента MyClass:

 `return element is MyClass ? (proposedLocks | Locks.Property) : proposedLocks;`

### <a name="to-make-your-policy-available-as-a-service"></a>Предоставление доступа к политике в качестве службы
 В `DslPackage` проекте добавьте новый файл, содержащий код, похожий на следующий пример:

```csharp
using Microsoft.VisualStudio.Modeling;
using Microsoft.VisualStudio.Modeling.Immutability;
namespace Company.YourDsl.DslPackage // Change
{
  // Override the DocData GetService() for this DSL.
  internal partial class YourDslDocData // Change
  {
    /// <summary>
    /// Custom locking policy cache.
    /// </summary>
    private ILockingPolicy myLockingPolicy = null;

    /// <summary>
    /// Called when a service is requested.
    /// </summary>
    /// <param name="serviceType">Service requested</param>
    /// <returns>Service implementation</returns>
    public override object GetService(System.Type serviceType)
    {
      if (serviceType == typeof(SLockingPolicy)
       || serviceType == typeof(ILockingPolicy))
      {
        if (myLockingPolicy == null)
        {
          myLockingPolicy = new MyLockingPolicy();
        }
        return myLockingPolicy;
      }
      // Request is for some other service.
      return base.GetService(serviceType);
    }
}
```
