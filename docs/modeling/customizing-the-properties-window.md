---
title: Настройка окна свойств
description: Узнайте, как настроить внешний вид и поведение окна свойств в доменном языке (DSL) в Visual Studio.
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: how-to
helpviewer_keywords:
- Domain-Specific Language, Properties window
author: JoshuaPartlow
ms.author: joshuapa
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: b7ee201494ed849062458afdcd41c2aed1b83b42
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99935395"
---
# <a name="customize-the-properties-window"></a>Настройка окно свойств

Вы можете настроить внешний вид и поведение окна Свойства в доменном языке (DSL) в Visual Studio. В определении DSL вы определяете свойства домена для каждого доменного класса. По умолчанию при выборе экземпляра класса либо на схеме, либо в обозревателе моделей, каждое свойство домена отображается в окне Свойства. Это позволяет просматривать и изменять значения свойств домена, даже если они не были сопоставлены с полями формы на схеме.

## <a name="names-descriptions-and-categories"></a>Имена, описания и категории

**Имя и отображаемое имя**. В определении свойства домена отображаемое имя свойства — это имя, которое отображается во время выполнения в окне Свойства. В отличие от этого имя используется при написании программного кода для обновления свойства. Имя должно быть правильным буквенно-цифровым именем CLR, но отображаемое имя может содержать пробелы.

При задании имени свойства в определении DSL его отображаемое имя автоматически присваивается копии имени. При написании имени в стиле Pascal, например "Фуелгауже", отображаемое имя будет автоматически содержать пробел: "датчик горючего". Однако можно явно задать для отображаемого имени другое значение.

**Описание**. Описание свойства предметной области отображается в двух местах:

- В нижней части окна Свойства, когда пользователь выбирает свойство. С его помощью можно объяснить пользователю, что представляет это свойство.

- В созданном коде программы. Если вы используете средства документации для извлечения документации по API, она будет отображаться в качестве описания этого свойства в API.

**Категория**. Категория — это заголовок в окно свойств.

## <a name="expose-style-features"></a>Предоставление возможностей стиля

Некоторые динамические функции графических элементов могут быть *представлены или представлены* как свойства домена. Возможность, предоставляемая таким способом, может быть обновлена пользователем и может быть легко обновлена программным кодом.

Щелкните правой кнопкой мыши класс Shape в определении DSL, наведите указатель на пункт **добавить предоставленный**, а затем выберите компонент.

В фигурах можно предоставить свойства **FillColor**, **OutlineColor**, **TextColor**, **OutlineDashStyle**, **OutlineThickness** и **FillGradientMode** . В соединителях можно предоставить свойства **Color** `,` **TextColor**, **DashStyle** и **толщина** . На схемах можно предоставить свойства **FillColor** и **TextColor** .

## <a name="forwarding-display-properties-of-related-elements"></a>Пересылка: Отображение свойств связанных элементов

Когда пользователь DSL выбирает элемент в модели, свойства этого элемента отображаются в окне Свойства. Однако можно также отобразить свойства указанных связанных элементов. Это полезно, если определена группа элементов, которые работают вместе. Например, можно определить элемент Main и дополнительный подключаемый элемент. Если главный элемент сопоставлен с фигурой, а другой — нет, то полезно просмотреть все их свойства, как если бы они находились в одном элементе.

Этот результат называется *Пересылка свойств*, и в некоторых случаях это происходит автоматически. В других случаях переадресацию свойств можно добиться, определив дескриптор типа домена.

### <a name="default-property-forwarding-cases"></a>Варианты перенаправления свойств по умолчанию

Когда пользователь выбирает фигуру или соединитель или элемент в обозревателе, в окно свойств отображаются следующие свойства:

- Свойства домена, определенные в доменном классе элемента модели, включая те, которые определены в базовых классах. Исключением являются свойства домена, для которых задано значение **, отображаемое** для `False` .

- Имена элементов, которые связаны через связи, имеющие кратность 0.. 1. Это предоставляет удобный способ просмотра необязательных связанных элементов, даже если для связи не было определено сопоставление соединителя.

- Свойства домена отношения внедрения, нацеленного на элемент. Поскольку отношения внедрения обычно не отображаются явно, это позволяет пользователю видеть их свойства.

- Свойства домена, определенные для выбранной фигуры или соединителя.

### <a name="add-property-forwarding"></a>Добавить перенаправление свойства

Чтобы переслать свойство, необходимо определить дескриптор типа домена. При наличии доменной связи между двумя доменными классами можно использовать дескриптор типа домена, чтобы задать свойству домена в первом классе значение свойства домена во втором классе домена. Например, если имеется связь между классом домена **книги** и классом домена **автора** , можно использовать дескриптор типа домена, чтобы свойство **Name** **автора** книги отображалось в окно свойств, когда пользователь выбирает книгу.

> [!NOTE]
> Пересылка свойств влияет только на окно свойств, когда пользователь редактирует модель. Он не определяет свойство предметной области для принимающего класса. Если вы хотите получить доступ к свойству перенаправленного домена в других частях определения DSL или в коде программы, необходимо получить доступ к элементу перенаправления.

В следующей процедуре предполагается, что вы создали DSL. В первых нескольких шагах описаны предварительные требования.

#### <a name="forward-a-property-from-another-element"></a>Пересылка свойства из другого элемента

1. Создайте [!INCLUDE[dsl](../modeling/includes/dsl_md.md)] решение, содержащее по крайней мере два класса, которые в этом примере называются **Book** и **Author**. Между **книгой** и **автором** должна быть связь любого вида.

    Кратность исходной роли (роль на стороне **книги** ) должна быть равна 0.. 1 или 1.. 1, чтобы каждая **Книга** соработала одного **автора**.

2. В **обозревателе DSL** щелкните правой кнопкой мыши доменный класс **книги** и выберите команду **Добавить новый DomainTypeDescriptor**.

    В узле **дескриптора настраиваемого типа** отображается узел с именованными **путями дескрипторов настраиваемых свойств** .

3. Щелкните правой кнопкой мыши узел **дескриптора настраиваемого типа** и выберите команду **Добавить новый PropertyPath**.

    Новый путь к свойству отображается под путем **к узлу дескрипторов настраиваемых свойств** .

4. Выберите новый путь к свойству, а затем в окне **Свойства** задайте **путь к свойству** путь к соответствующему элементу модели.

    Можно изменить путь в представлении в виде дерева, щелкнув стрелку вниз справа от этого свойства. Дополнительные сведения о путях доменов см. в разделе [синтаксис пути к домену](../modeling/domain-path-syntax.md). После редактирования путь должен выглядеть примерно так **: букреференцесаусор. Author/! Автор**.

5. Задайте **свойству** **имя** свойства домена **автора**.

6. Задайте **Отображаемое имя** в качестве **имени автора**.

7. Преобразование всех шаблонов, сборка и запуск DSL.

8. В схеме модели Создайте книгу, автора и свяжите их с помощью ссылочной связи. Выберите элемент Book и в окно свойств в дополнение к свойствам книги должно отобразиться имя автора. Измените имя связанного автора или свяжите книгу с другим автором и обратите внимание, что имя автора книги изменится.

## <a name="custom-property-editors"></a>Пользовательские редакторы свойств

Окно свойств предоставляет соответствующие возможности редактирования по умолчанию для типа каждого свойства домена. Например, для перечислимого типа пользователь видит раскрывающийся список, а для числового свойства пользователь может вводить цифры. Это справедливо только для встроенных типов. При указании внешнего типа пользователь сможет видеть значения этого свойства, но не изменять его.

Однако можно указать следующие редакторы и типы:

1. Другой редактор, используемый со стандартным типом. Например, можно указать редактор пути к файлу для свойства строки.

2. Внешний тип для свойства предметной области и редактор для него.

3. Редактор .NET, например Редактор пути к файлам, или можно создать собственный редактор свойств.

   Преобразование между внешним типом и типом, таким как String, который имеет редактор по умолчанию.

   В DSL *внешний тип* — это любой тип, не являющийся одним из простых типов (например, Boolean или Int32) или String.

### <a name="define-a-domain-property-that-has-an-external-type"></a>Определение свойства домена, имеющего внешний тип

1. В **Обозреватель решений** добавьте ссылку на СБОРКУ (DLL), содержащую внешний тип, в проекте **DSL** .

    Сборка может быть сборкой .NET или предоставленной вам сборкой.

2. Добавьте тип в список **доменные типы** , если вы еще не сделали этого.

   1. Откройте DslDefinition. DSL и в **обозревателе DSL** щелкните правой кнопкой мыши корневой узел и выберите команду **Добавить новый внешний тип**.

        В узле **типы домена** появится новая запись.

       > [!WARNING]
       > Пункт меню находится в корневом узле DSL, а не в узле **типы домена** .

   2. Задайте имя и пространство имен нового типа в окно свойств.

3. Добавьте свойство домена в доменный класс обычным способом.

    В окно свойств выберите внешний тип из раскрывающегося списка в поле **тип** .

   На этом этапе пользователи могут просматривать значения свойства, но не могут изменять их. Отображаемые значения получаются из `ToString()` функции. Можно написать программный код, который задает значение свойства, например в команде или правиле.

### <a name="set-a-property-editor"></a>Задание редактора свойств

Добавьте атрибут CLR в свойство Domain в следующей форме:

```csharp
[System.ComponentModel.Editor (
   typeof(AnEditor),
   typeof(System.Drawing.Design.UITypeEditor))]
```

Атрибут можно задать для свойства с помощью записи **настраиваемого атрибута** в окно свойств.

Тип `AnEditor` должен быть производным от типа, указанного во втором параметре. Второй параметр должен иметь значение <xref:System.Drawing.Design.UITypeEditor> или <xref:System.ComponentModel.ComponentEditor> . Для получения дополнительной информации см. <xref:System.ComponentModel.EditorAttribute>.

Можно указать собственный редактор или редактор .NET, например <xref:System.Windows.Forms.Design.FileNameEditor> или <xref:System.Drawing.Design.ImageEditor> . Например, используйте следующую процедуру, чтобы иметь свойство, в котором пользователь может ввести имя файла.

#### <a name="define-a-file-name-domain-property"></a>Определение свойства домена имени файла

1. Добавьте свойство домена в доменный класс в определении DSL.

2. Выберите новое свойство. В поле **настраиваемый атрибут** в окно свойств введите следующий атрибут. Чтобы ввести этот атрибут, нажмите кнопку с многоточием **[...]** , а затем введите имя атрибута и параметры отдельно:

    ```csharp
    [System.ComponentModel.Editor (
       typeof(System.Windows.Forms.Design.FileNameEditor)
       , typeof(System.Drawing.Design.UITypeEditor))]

    ```

3. Оставьте для свойства Domain значение по умолчанию **String**.

4. Чтобы протестировать редактор, убедитесь, что пользователи могут открыть редактор имен файлов, чтобы изменить свойство домена.

    1. Нажмите клавиши CTRL + F5 или F5. В решении отладки откройте файл теста. Создайте элемент класса Domain и выберите его.

    2. В окно свойств выберите свойство Domain. В поле значение отображается многоточие **[...]**.

    3. Нажмите кнопку с многоточием. Откроется диалоговое окно файл. Выберите файл и закройте диалоговое окно. Путь к файлу теперь является значением свойства Domain.

### <a name="define-your-own-property-editor"></a>Определение собственного редактора свойств

Можно определить собственный редактор. Это можно сделать, чтобы пользователь мог изменить определенный вами тип или изменить стандартный тип особым образом. Например, можно разрешить пользователю вводить строку, представляющую формулу.

Редактор определяется путем написания класса, производного от <xref:System.Drawing.Design.UITypeEditor> . Класс должен переопределять:

- <xref:System.Drawing.Design.UITypeEditor.EditValue%2A>, для взаимодействия с пользователем и обновления значения свойства.

- <xref:System.Drawing.Design.UITypeEditor.GetEditStyle%2A>, чтобы указать, будет ли редактор открывать диалоговое окно или предоставлять раскрывающееся меню.

Можно также предоставить графическое представление значения свойства, которое будет отображаться в сетке свойств. Для этого переопределите `GetPaintValueSupported` и `PaintValue` .  Для получения дополнительной информации см. <xref:System.Drawing.Design.UITypeEditor>.

> [!NOTE]
> Добавьте код в отдельный файл кода в проекте **DSL** .

Пример:

```csharp
internal class TextFileNameEditor : System.Windows.Forms.Design.FileNameEditor
{
  protected override void InitializeDialog(System.Windows.Forms.OpenFileDialog openFileDialog)
  {
    base.InitializeDialog(openFileDialog);
    openFileDialog.Filter = "Text files(*.txt)|*.txt|All files (*.*)|*.*";
    openFileDialog.Title = "Select a text file";
  }
}
```

Чтобы использовать этот редактор, присвойте **атрибуту custom** свойства домена значение:

```csharp
[System.ComponentModel.Editor (
   typeof(MyNamespace.TextFileNameEditor)
   , typeof(System.Drawing.Design.UITypeEditor))]
```

Для получения дополнительной информации см. <xref:System.Drawing.Design.UITypeEditor>.

## <a name="provide-a-drop-down-list-of-values"></a>Укажите раскрывающийся список значений

Можно предоставить список значений, которые пользователь может выбрать.

> [!NOTE]
> Этот метод предоставляет список значений, которые могут изменяться во время выполнения. Если вы хотите предоставить список, который не изменяется, рассмотрите возможность использования перечислимого типа в качестве типа свойства домена.

Чтобы определить список стандартных значений, добавьте к свойству домена атрибут CLR, имеющий следующий вид:

```csharp
[System.ComponentModel.TypeConverter
(typeof(MyTypeConverter))]
```

Определите класс, производный от класса <xref:System.ComponentModel.TypeConverter>. Добавьте код в отдельный файл в проекте **DSL** . Пример:

```csharp
/// <summary>
/// Type converter that provides a list of values
/// to be displayed in the property grid.
/// </summary>
/// <remarks>This type converter returns a list
/// of the names of all "ExampleElements" in the
/// current store.</remarks>
public class MyTypeConverter : System.ComponentModel.TypeConverter
{
  /// <summary>
  /// Return true to indicate that we return a list of values to choose from
  /// </summary>
  /// <param name="context"></param>
  public override bool GetStandardValuesSupported
    (System.ComponentModel.ITypeDescriptorContext context)
  {
    return true;
  }

  /// <summary>
  /// Returns true to indicate that the user has
  /// to select a value from the list
  /// </summary>
  /// <param name="context"></param>
  /// <returns>If we returned false, the user would
  /// be able to either select a value from
  /// the list or type in a value that is not in the list.</returns>
  public override bool GetStandardValuesExclusive
      (System.ComponentModel.ITypeDescriptorContext context)
  {
    return true;
  }

  /// <summary>
  /// Return a list of the values to display in the grid
  /// </summary>
  /// <param name="context"></param>
  /// <returns>A list of values the user can choose from</returns>
  public override StandardValuesCollection GetStandardValues
      (System.ComponentModel.ITypeDescriptorContext context)
  {
    // Try to get a store from the current context
    // "context.Instance"  returns the element(s) that
    // are currently selected i.e. whose values are being
    // shown in the property grid.
    // Note that the user could have selected multiple objects,
    // in which case context.Instance will be an array.
    Store store = GetStore(context.Instance);

    List<string> values = new List<string>();

    if (store != null)
    {
      values.AddRange(store.ElementDirectory
        .FindElements<ExampleElement>()
        .Select<ExampleElement, string>(e =>
      {
        return e.Name;
      }));
    }
    return new StandardValuesCollection(values);
  }

  /// <summary>
  /// Attempts to get to a store from the currently selected object(s)
  /// in the property grid.
  /// </summary>
  private Store GetStore(object gridSelection)
  {
    // We assume that "instance" will either be a single model element, or
    // an array of model elements (if multiple items are selected).

    ModelElement currentElement = null;

    object[] objects = gridSelection as object[];
    if (objects != null && objects.Length > 0)
    {
      currentElement = objects[0] as ModelElement;
    }
    else
    {
        currentElement = gridSelection as ModelElement;
    }

    return (currentElement == null) ? null : currentElement.Store;
  }

}
```

## <a name="see-also"></a>См. также раздел

- [Перемещение по модели и обновление модели в коде программы](../modeling/navigating-and-updating-a-model-in-program-code.md)
