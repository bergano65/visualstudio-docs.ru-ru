---
title: Практическое руководство. Обновление модели с помощью транзакций
ms.date: 11/04/2016
ms.topic: conceptual
author: gewarren
ms.author: gewarren
manager: douge
ms.workload:
- multiple
ms.prod: visual-studio-dev15
ms.technology: vs-ide-modeling
ms.openlocfilehash: b69015a58b4772a13c387f67f0dc9d6a2571e1b7
ms.sourcegitcommit: ad5fb20f18b23eb8bd2568717f61edc6b7eee5e7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/01/2018
ms.locfileid: "47859228"
---
# <a name="how-to-use-transactions-to-update-the-model"></a>Практическое руководство. Обновление модели с помощью транзакций
Транзакций убедитесь, что изменения, внесенные в хранилище, рассматриваются как группу. Изменения, которые группируются можно зафиксировать или откатить как единое целое.

 Каждый раз, когда код программы изменяет, добавляет или удаляет любой элемент в Store, в Visual Studio Visualization and Modeling SDK, его необходимо делать это внутри транзакции. Необходимо иметь активный экземпляр <xref:Microsoft.VisualStudio.Modeling.Transaction> связанные с Store, когда происходит изменение. Это относится к всех элементов модели, отношения, фигуры, схемы и их свойства.

 Механизм транзакций помогает избежать нестабильных состояний. Если произошла ошибка во время транзакции, выполняется откат всех изменений. Если пользователь выполняет команду отмены, каждая транзакция последние считается за один шаг. Пользователь не удается отменить части последнее изменение, если только вы явным образом поместите их в отдельных транзакциях.

## <a name="opening-a-transaction"></a>Открытие транзакции
 Является наиболее удобным способом управления транзакции с `using` инструкция заключена в `try...catch` инструкции:

```csharp
Store store; ...
try
{
  using (Transaction transaction =
    store.TransactionManager.BeginTransaction("update model"))
    // Outermost transaction must always have a name.
  {
    // Make several changes in Store:
    Person p = new Person(store);
    p.FamilyTreeModel = familyTree;
    p.Name = "Edward VI";
    // end of changes to Store

    transaction.Commit(); // Don't forget this!
  } // transaction disposed here
}
catch (Exception ex)
{
  // If an exception occurs, the Store will be
  // rolled back to its previous state.
}
```

 Если исключение, которое предотвращает последней `Commit()` происходит во время изменения, Store будут сброшены в предыдущее состояние. Это поможет вам убедиться, что ошибки не оставляйте модель в несогласованном состоянии.

 Можно внести любое количество изменений в рамках одной транзакции. Вы можете открыть новые транзакции внутри активной транзакции. Вложенные транзакции необходимо зафиксировать или откатить до окончания этого содержащего транзакции. Дополнительные сведения см. пример для <xref:Microsoft.VisualStudio.Modeling.Transaction.TransactionDepth%2A> свойство.

 Для внесения постоянных изменений, вы должны `Commit` транзакции до ее удаления. При возникновении исключения, не перехватываемое внутри транзакции, Store будут сброшены в состояние до изменения.

## <a name="rolling-back-a-transaction"></a>Откат транзакции
 Чтобы убедиться, что остается в Store, или возвращается в состояние до транзакции, можно использовать любой из этих тактик:

1.  Исключение не перехватывается внутри области транзакции.

2.  Явного отката транзакции:

    ```csharp
    this.Store.TransactionManager.CurrentTransaction.Rollback();
    ```

## <a name="transactions-do-not-affect-non-store-objects"></a>Транзакции не влияют на объекты не Store
 Транзакции только определяют состояние Store. Их нельзя отменить частичные изменения, внесенные в внешние элементы, такие как файлы, базы данных или объекты, которые объявлены с обычные типы за пределами определения DSL.

 Если исключение такого изменения может оставить согласована Store, вы имеете дело с такую возможность в обработчике исключений. Один из способов, чтобы убедиться в том, что внешние ресурсы будут синхронизированы с объектами Store — Создание зависимости между каждого внешнего объекта на элемент в хранилище с помощью обработчиков событий. Дополнительные сведения см. в разделе [обработчики распространения изменений за пределами модели событий](../modeling/event-handlers-propagate-changes-outside-the-model.md).

## <a name="rules-fire-at-the-end-of-a-transaction"></a>Запускаются правила в конце транзакции
 В конце транзакции до удаления транзакции запускаются правила, присоединенные к элементам в хранилище. Каждое правило — это метод, который применяется к элементу модели, которая была изменена. Например «исправить» правила, которые обновляют состояние фигуры при изменении его элемента модели, и при создании элемента модели, которые создают фигуры. Нет указанного срабатывание порядка. Изменения, внесенные с помощью правила срабатывают другое правило.

 Вы можете определить собственные правила. Дополнительные сведения о правилах см. в разделе [реагирование на события и распространение изменений](../modeling/responding-to-and-propagating-changes.md).

 Правила не срабатывают после отмены, повтора или команду отката.

## <a name="transaction-context"></a>Контекст транзакции
 Каждая транзакция имеет словарь, в котором можно хранить любые нужные сведения.

 `store.TransactionManager`

 `.CurrentTransaction.TopLevelTransaction`

 `.Context.Add(aKey, aValue);`

 Это особенно полезно для передачи данных между правилами.

## <a name="transaction-state"></a>Состояние транзакции
 В некоторых случаях нужно избежать распространение изменений, если изменение вызвано Отмена или повтор транзакции. Это может произойти, например, если написать обработчик значения свойства, который может обновить другого значения в Store. Так как операция отмены сбрасывает все значения в Store прежнее состояние, необязательно для вычисления обновленные значения. Используйте следующий код:

```csharp
if (!this.Store.InUndoRedoOrRollback) {...}
```

 Правила срабатывают в том случае, когда хранилище изначально загружается из файла. Чтобы не отвечать на эти изменения, используйте следующую команду:

```csharp
if (!this.Store.InSerializationTransaction) {...}

```