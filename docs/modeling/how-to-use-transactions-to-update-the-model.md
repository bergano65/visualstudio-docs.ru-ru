---
title: Практическое руководство. Обновление модели с помощью транзакций
description: Изучите, что транзакции позволяют гарантировать, что изменения, внесенные в хранилище, обрабатывались как группа и как использовать транзакции для обновления модели.
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
author: JoshuaPartlow
ms.author: joshuapa
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: fe892269d0e02d1f8e0aca2e943993ebb03cea41
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99922587"
---
# <a name="how-to-use-transactions-to-update-the-model"></a>Практическое руководство. Обновление модели с помощью транзакций
Транзакции убедитесь, что изменения, внесенные в хранилище, обрабатываются как группа. Сгруппированные изменения можно зафиксировать или откатить как единое целое.

 Каждый раз, когда код программы изменяет, добавляет или удаляет любой элемент в магазине в пакете SDK визуализации и моделирования Visual Studio, он должен сделать это внутри транзакции. В случае изменения должен существовать активный экземпляр, <xref:Microsoft.VisualStudio.Modeling.Transaction> связанный с хранилищем. Это относится ко всем элементам модели, связям, фигурам, схемам и их свойствам.

 Механизм транзакций помогает избежать непротиворечивых состояний. При возникновении ошибки во время транзакции выполняется откат всех изменений. Если пользователь выполняет команду Undo, каждая последняя транзакция рассматривается как один шаг. Пользователь не может отменить последние изменения, если вы явно не поместили их в отдельные транзакции.

## <a name="opening-a-transaction"></a>Открытие транзакции
 Наиболее удобный способ управления транзакцией заключается в использовании оператора, `using` заключенного в `try...catch` инструкцию:

```csharp
Store store; ...
try
{
  using (Transaction transaction =
    store.TransactionManager.BeginTransaction("update model"))
    // Outermost transaction must always have a name.
  {
    // Make several changes in Store:
    Person p = new Person(store);
    p.FamilyTreeModel = familyTree;
    p.Name = "Edward VI";
    // end of changes to Store

    transaction.Commit(); // Don't forget this!
  } // transaction disposed here
}
catch (Exception ex)
{
  // If an exception occurs, the Store will be
  // rolled back to its previous state.
}
```

 Если исключение, препятствующее последнему `Commit()` , происходит во время изменений, то хранилище будет сброшено до предыдущего состояния. Это позволяет убедиться, что ошибки не оставляют модель в нестабильном состоянии.

 В одну транзакцию можно внести любое количество изменений. Можно открыть новые транзакции внутри активной транзакции. Вложенные транзакции должны быть зафиксированы или возвращены перед завершением содержащей их транзакции. Дополнительные сведения см. в примере для <xref:Microsoft.VisualStudio.Modeling.Transaction.TransactionDepth%2A> Свойства.

 Чтобы изменения были постоянными, необходимо выполнить `Commit` транзакцию до ее удаления. Если возникает исключение, которое не перехватывается внутри транзакции, хранилище будет сброшено до состояния до внесения изменений.

## <a name="rolling-back-a-transaction"></a>Откат транзакции
 Чтобы гарантировать, что хранилище остается в состоянии или вернется к состоянию до транзакции, можно использовать любую из этих тактик:

1. Создает исключение, которое не перехватывается внутри области транзакции.

2. Явно выполнить откат транзакции:

    ```csharp
    this.Store.TransactionManager.CurrentTransaction.Rollback();
    ```

## <a name="transactions-do-not-affect-non-store-objects"></a>Транзакции не влияют на объекты, не являющиеся объектами хранилища
 Транзакции управляют только состоянием магазина. Они не могут отменить частичные изменения, внесенные во внешние элементы, такие как файлы, базы данных или объекты, которые были объявлены с обычными типами за пределами определения DSL.

 Если исключение может оставить такое изменение, несовместимое с хранилищем, необходимо решить эту возможность в обработчике исключений. Один из способов обеспечить синхронизацию внешних ресурсов с объектами хранилища заключается в том, чтобы объединить каждый внешний объект с элементом In-Store с помощью обработчиков событий. Дополнительные сведения см. в разделе " [обработчики событий" распространяют изменения за пределы модели](../modeling/event-handlers-propagate-changes-outside-the-model.md).

## <a name="rules-fire-at-the-end-of-a-transaction"></a>Правила срабатывают в конце транзакции
 В конце транзакции перед ликвидацией транзакции запускаются правила, присоединенные к элементам в хранилище. Каждое правило — это метод, который применяется к измененному элементу модели. Например, существуют правила "исправления", которые обновляют состояние фигуры при изменении его элемента модели и создают фигуру при создании элемента модели. Нет указанного порядка срабатывания. Изменение, выполненное правилом, может вызвать другое правило.

 Вы можете определить собственные правила. Дополнительные сведения о правилах см. [в разделе реагирование на изменения и их распространение](../modeling/responding-to-and-propagating-changes.md).

 Правила не срабатывают после выполнения команды отмены, повтора или отката.

## <a name="transaction-context"></a>Контекст транзакции
 Каждая транзакция имеет словарь, в котором можно хранить любую требуемую информацию:

 `store.TransactionManager`

 `.CurrentTransaction.TopLevelTransaction`

 `.Context.Add(aKey, aValue);`

 Это особенно удобно для передачи данных между правилами.

## <a name="transaction-state"></a>Состояние транзакции
 В некоторых случаях необходимо избежать распространения изменений, если изменение вызвано отменой или повторным выполнением транзакции. Это может произойти, например, при написании обработчика значения свойства, который может обновить другое значение в хранилище. Поскольку операция отмены сбрасывает все значения в хранилище до их предыдущего состояния, нет необходимости вычислять обновленные значения. Используйте следующий код:

```csharp
if (!this.Store.InUndoRedoOrRollback) {...}
```

 Правила могут срабатывать, когда хранилище первоначально загружается из файла. Чтобы не реагировать на эти изменения, используйте:

```csharp
if (!this.Store.InSerializationTransaction) {...}
```
