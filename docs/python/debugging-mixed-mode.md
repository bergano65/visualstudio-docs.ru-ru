---
title: "Смешанный режим отладки для Python в Visual Studio | Документы Майкрософт"
ms.custom: 
ms.date: 07/12/2017
ms.reviewer: 
ms.suite: 
ms.technology: devlang-python
ms.devlang: python
ms.tgt_pltfrm: 
ms.topic: article
caps.latest.revision: "1"
author: kraigb
ms.author: kraigb
manager: ghogen
ms.workload:
- python
- data-science
ms.openlocfilehash: b1a36b387ad9fd8a2212cfaceefbd454edf33dde
ms.sourcegitcommit: 11740fed01cc602252ef698aaa11c07987b00570
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/12/2018
---
# <a name="debugging-python-and-c-together"></a>Совместная отладка Python и C++

Большинство обычных отладчиков Python поддерживает только отладку кода Python. Однако на практике Python используется совместно с C или C++ в сценариях, для которых требуется высокая производительность или возможность напрямую вызывать API-интерфейсы платформ. См. примеры в статье о [создании расширения C++ для Python](cpp-and-python.md). При загрузке проекта Python программа Visual Studio предоставляет интегрированную одновременную отладку в смешанном режиме для Python и машинного кода C/C++, в том числе такие возможности:

- объединенный стек вызовов;
- переход между кодом Python и машинным кодом;
- точки останова в обоих типах кода;
- просмотр представлений Python для объектов во фреймах машинного кода и наоборот;

![Отладка в смешанном режиме](media/mixed-mode-debugging.png) 

Введение в создание, тестирование и отладку модулей машинного кода С с помощью Visual Studio см. в видео [Deep Dive: Creating Native Modules](https://youtu.be/D9RlT06a1EI) (Подробный обзор. Создание собственных модулей) длительностью 9 мин 9 с, размещенном на сайте youtube.com. Это видео относится как к Visual Studio 2015, так и к Visual Studio 2017.

> [!VIDEO https://www.youtube.com/embed/D9RlT06a1EI]

> [!Note]
> Смешанный режим отладки не доступен в Инструментах Python для Visual Studio 1.x.

## <a name="enabling-mixed-mode-debugging"></a>Включение смешанного режима отладки

1. Щелкните проект Python правой кнопкой мыши в обозревателе решений, выберите **Свойства**, откройте вкладку **Отладка** и выберите параметр **Включить отладку машинного кода**. Этот параметр включает смешанный режим для всех сеансов отладки.

    ![Включение отладки машинного кода](media/mixed-mode-debugging-enable-native.png)

    > [!Tip]
    > При включении отладки машинного кода окно вывода Python может исчезнуть сразу после завершения программы без обычной паузы с сообщением "Для продолжения нажмите любую клавишу...". Чтобы сделать паузу принудительно, добавьте параметр `-i` в поле **Запуск > Аргументы интерпретатора** на вкладке **Отладка** при включении отладки машинного кода. Этот аргумент переводит интерпретатор Python в интерактивный режим по завершении кода, после чего он ожидает нажатия клавиш CTRL+Z и ВВОД для выхода.

1. При присоединении к существующему процессу отладчика смешанного режима (**Отладка > Присоединение к процессу**) нажмите кнопку **Выбрать…**, чтобы открыть диалоговое окно **Выбор типа кода**. Выберите параметр **Выполнять отладку кода следующих типов**, затем выберите в списке **Машинный код** и **Python**:

    ![Выбор типов кода Python и машинного кода](media/mixed-mode-debugging-code-type.png)

    Параметры типа кода являются постоянными, поэтому, если позже вам понадобится отключить отладку в смешанном режиме при присоединении к другому процессу, очистите тип кода Python.

    Можно выбрать другие типы кода в дополнение к **машинному коду** или вместо него. Например, если CPython размещается в управляемом приложении, которое, в свою очередь, использует собственные модули расширения, и необходимо выполнить отладку всех трех компонентов, можно одновременно выбрать **Python**, **Машинный код** и **Управляемый код** для единой отладки, в том числе использования объединенных стеков вызовов и переключения между всеми тремя средами выполнения.

1. Когда вы впервые приступите к отладке в смешанном режиме, может отобразиться диалоговое окно **Необходимые символы Python**. См. статью [Символы для отладки в смешанном режиме](debugging-symbols-for-mixed-mode.md). Символы для любой среды Python необходимо установить только один раз. Символы включаются автоматически при установке поддержки Python с помощью установщика Visual Studio 2017.

1. Вам также может потребоваться исходный код Python. Посетите страницу [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/), скачайте архив Python, который подходит для вашей версии, и извлеките его в папку. Укажите Visual Studio на конкретные файлы в этой папке при отображении соответствующего запроса.

### <a name="enable-mixed-mode-debugging-in-a-c-project"></a>Включение смешанного режима отладки в проекте C++

Смешанный режим отладки, как описано в этой статье, включается только в том случае, если в Visual Studio загружен проект Python. Этот проект определяет режим отладки в Visual Studio, что делает доступным параметр смешанного режима.

Если, однако, загружен проект C++ (как и при [внедрении Python в другое приложение, как описано на python.org](https://docs.python.org/3/extending/embedding.html)), то Visual Studio использует собственный отладчик C++, который не поддерживает отладку в смешанном режиме. Но вы можете подключить отладчик отдельно:

1. Запустите проект C++ без отладки (выберите **Отладка > Запуск без отладки** или нажмите клавиши CTRL + F5).
1. Выберите команду **Отладка > Присоединение к процессу**. В открывшемся диалоговом окне выберите соответствующий процесс, затем нажмите кнопку **Выбрать**, чтобы открыть диалоговое окно **Выбор типа кода**, в котором можно выбрать Python:

    ![Выбор Python в качестве типа отладки при подсоединении отладчика](media/mixed-mode-debugging-attach-type.png)

1. Нажмите **ОК**, чтобы закрыть диалоговое окно, затем нажмите **Присоединить** для запуска отладчика. 
1. Может потребоваться добавить соответствующую паузу или задержку в приложение C++, чтобы это приложение не вызывало код Python, отладку которого необходимо выполнить, пока вы не сможете присоединить отладчик.

## <a name="mixed-mode-specific-features"></a>Функции, характерные для смешанного режима

- [Объединенный стек вызовов](#combined-call-stack)
- [Переход между кодом Python и машинным кодом](#stepping-between-python-and-native-code)
- [Представление значений PyObject в машинном коде](#pyobject-values-view-in-native-code)
- [Представление значений машинного кода в коде Python](#native-values-view-in-python-code)

### <a name="combined-call-stack"></a>Объединенный стек вызовов

В окне стека вызовов представлены чередующиеся кадры стеков машинного кода и Python с помеченными переходами.

![Объединенный стек вызовов](media/mixed-mode-debugging-call-stack.png)

Переходы отображаются в виде внешнего кода без указания направления перехода, если задан параметр **Инструменты > Параметры > Отладка > Общие > Включить только мой код**.

Если дважды щелкнуть какой-либо кадр вызова, он станет активным и откроется соответствующий исходный код, если это возможно. Если исходный код недоступен, кадр все равно становится активным и можно проверить локальные переменные.

### <a name="stepping-between-python-and-native-code"></a>Переход между кодом Python и машинным кодом

При использовании команд "Шаг с заходом" (F11) или "Шаг с выходом" (SHIFT+F11) отладчик в смешанном режиме правильно обрабатывает изменения типов кода. Например, когда Python вызывает метод типа, который реализован на языке C, переход с заходом в вызов этого метода останавливается в начале собственной функции, реализующей метод. Аналогичным образом, когда машинный код вызывает функцию API Python, вызывается код Python. Например, шаг с заходом в `PyObject_CallObject` значения функции, которая была изначально определена на языке Python, остановится в начале функции Python. Шаг с заходом из Python в машинный код также поддерживается для функций машинного кода, которые вызываются из Python с помощью модуля [ctypes](http://docs.python.org/3/library/ctypes.html).

### <a name="pyobject-values-view-in-native-code"></a>Представление значений PyObject в машинном коде

Если кадр машинного кода (C или C++) активен, его локальные переменные отображаются в окне локальных переменных отладчика. В собственных модулях расширения Python многие из переменных относятся к типу `PyObject` (который является typedef для `_object`) или к другим базовым типам Python (см. список ниже). При отладке в смешанном режиме эти значения представляют дополнительный дочерний узел с меткой "Представление Python". При развертывании этот узел отображает представление переменной Python, как и в случае, когда локальная переменная, которая ссылается на тот же объект, присутствует в кадре Python. Дочерние узлы данного узла можно изменять.

![Представление Python](media/mixed-mode-debugging-python-view.png)

Чтобы отключить эту функцию, щелкните правой кнопкой мыши в окне локальных переменных и снимите флажок для параметра меню **Python > Show Python View Nodes** (Показать узлы представления Python):

![Включение представления Python](media/mixed-mode-debugging-enable-python-view.png)

Типы C, для которых отображаются узлы представления Python (если включено).

- `PyObject`
- `PyVarObject`
- `PyTypeObject`
- `PyByteArrayObject`
- `PyBytesObject`
- `PyTupleObject`
- `PyListObject`
- `PyDictObject`
- `PySetObject`
- `PyIntObject`
- `PyLongObject`
- `PyFloatObject`
- `PyStringObject`
- `PyUnicodeObject`

Для типов, которые вы создаете самостоятельно, представление Python не отображается автоматически. При создании расширений для Python 3.x обычно это не проблема, так как любой объект в конечном итоге имеет поле `ob_base` одного из типов, перечисленных выше, вследствие чего отображается представление Python.

Для Python 2.x каждый тип объектов обычно объявляет заголовок как коллекцию встроенных полей. При этом отсутствует связь между создаваемыми пользовательскими типами и `PyObject` на уровне системы типов в коде C или C++. Чтобы включить узлы представления Python для таких пользовательских типов, измените `PythonDkm.natvis` в [каталоге установки инструментов Python](installation.md#install-locations) и добавьте другой элемент в XML для структуры C или класса C++.

В качестве альтернативного (и лучшего) варианта можно следовать [PEP 3123](http://www.python.org/dev/peps/pep-3123/) и использовать явное поле `PyObject ob_base;` вместо `PyObject_HEAD`, хотя это может привести к проблемам с обратной совместимостью.

### <a name="native-values-view-in-python-code"></a>Представление значений машинного кода в коде Python

Как и в предыдущем разделе, можно включить представление C++ для значений машинного кода в окне локальных переменных при активном кадре Python. Эта функция отключена по умолчанию. Чтобы включить ее, щелкните правой кнопкой мыши в окне локальных значений и установите флажок для параметра меню **Python > Show C++ View Nodes** (Показать узлы представления C++).

![Включение представления C++](media/mixed-mode-debugging-enable-cpp-view.png)

Узел представления C++ отображает базовую структуру C/C++ для значения, идентичную той, которую вы видите в кадре машинного кода. Например, он отображает экземпляр `_longobject` (для которого `PyLongObject` является определением типа typedef) для длинного целого числа Python и пытается определить типы собственных классов, созданных вручную. Дочерние узлы данного узла можно изменять.

![Представление C++](media/mixed-mode-debugging-cpp-view.png)

Если дочернее поле объекта имеет тип `PyObject` или один из других поддерживаемых типов, он имеет узел представления Python (если включено), что позволит перемещаться по графам объекта, где ссылки не предоставляются непосредственно в Python.

В отличие от узлов представления Python, использующих метаданные объекта Python для определения типа объекта, такого же надежного механизма для представления C++ не существует. В сущности, для заданного значения Python (для ссылки `PyObject`) невозможно точно определить резервную структуру C/C++. Отладчик смешанного режима пытается угадать этот тип, просматривая различные поля типа объекта (например, на `PyTypeObject` ссылается его поле `ob_type`), которые имеют типы указателей функций. Если один из этих указателей ссылается на функцию, которая может быть разрешена, а функция имеет параметр `self` с типом, более точным, чем `PyObject*`, тогда предполагается, что этот тип является резервным. Например, если `ob_type->tp_init` данного объекта указывает на следующую функцию:

```c
static int FobObject_init(FobObject* self, PyObject* args, PyObject* kwds) {
    return 0;
}
```

То отладчик может правильно предположить, что типом C объекта является `FobObject`. Если исходя из `tp_init` не удается определить тип более точно, отладчик переходит к другим полям. Если не удается определить тип на основе любого из этих полей, узел представления C++ представляет объект как экземпляр `PyObject`.

Чтобы всегда получать полезное представление пользовательских типов, рекомендуется зарегистрировать по меньшей мере одну специальную функцию при регистрации типа и использовать строго типизированный параметр `self`. Большинство типов соответствует этому требованию естественным образом. Если это не так, для этой цели обычно лучше всего использовать запись `tp_init`. Фиктивная реализация `tp_init` для типа, которая присутствует только для того, чтобы определить тип отладки, сразу же возвращает ноль, как в приведенном выше примере.

## <a name="differences-from-standard-python-debugging"></a>Отличия от стандартной отладки Python

Отладчик смешанного режима отличается от [стандартного отладчика Python](debugging.md) тем, что в нем представлены некоторые дополнительные функции, но отсутствуют определенные возможности, связанные с Python.

- Неподдерживаемые функции: условные точки останова, интерактивное окно отладки и удаленная отладка между различными платформами.
- Окно интерпретации: доступно, но с ограниченным набором функциональных возможностей, включая все перечисленные здесь ограничения.
- Поддерживаемые версии Python: только CPython 2.7 и 3.3+.
- Оболочка Visual Studio. При использовании Python с оболочкой Visual Studio (например, при выполнении установки с помощью интегрированного средства установки) в Visual Studio не откроются проекты C++, а редактирование файлов C++ будет ограничено возможностями простого текстового редактора. В оболочке полностью поддерживается отладка C/C++ и отладка в смешанном режиме, что позволяет работать с исходным кодом, переходить к машинному коду и вычислять выражения C++ в окнах отладчика.
- Просмотр и развертывание объектов. При просмотре объектов Python в окнах локальных и контрольных значений отладчика смешанного режима будет отображаться только структура объектов. Свойства не вычисляются автоматически, и вычисляемые атрибуты не отображаются. Для коллекций будут отображаться только элементы встроенных типов (`tuple`, `list`, `dict`, `set`). Пользовательские коллекции не визуализируются в виде коллекций, если они наследуются от коллекции встроенного типа.
- Вычисление выражений: см. сведения ниже.

### <a name="expression-evaluation"></a>Вычисление выражений

Стандартный отладчик Python позволяет вычислять произвольные выражения Python в окнах контрольных значений и интерпретации отладчика при приостановке отладки в любой точке кода, если она не заблокирована с помощью операции ввода-вывода или другого аналогичного системного вызова. В смешанном режиме отладки произвольные выражения можно вычислить только при остановке в коде Python после точки останова или при шаге с заходом в код. Выражения можно вычислить только в потоке, где были выполнены вышеуказанные операции.

При остановке в машинном коде или в коде Python, где вышеуказанные условия не применяются (например, после выполнения шага с выходом или в другом потоке), вычисление выражений ограничено доступом к локальным и глобальным переменным в рамках текущего выбранного кадра, а также доступом к их полям и индексированию коллекций встроенных типов с литералами. Например, следующее выражение может вычисляться в любом контексте (при условии, что все идентификаторы ссылаются на существующие переменные и поля соответствующих типов).

```python
foo.bar[0].baz['key']
```

Отладчик смешанного режима разрешает такие выражения по-разному. Все операции доступа к элементам ищут только поля, которые непосредственно принадлежат объекту (например, запись в его `__dict__` или `__slots__` либо поле собственной структуры, которое предоставляется Python с помощью `tp_members`), и игнорируют методы `__getattr__`, `__getattribute__` или логику дескриптора. Аналогичным образом все операции индексирования игнорируют `__getitem__` и получают доступ к внутренним структурам данных коллекций напрямую.

Для обеспечения согласованности такая схема разрешения используется для всех выражений, которые соответствуют ограничениям вычисления выражений вне зависимости от того, разрешены ли произвольные выражения в текущей точке остановки. Чтобы обеспечить правильную семантику Python, когда доступен полнофункциональный вычислитель, заключите выражение в скобки.

```python
(foo.bar[0].baz['key'])
```