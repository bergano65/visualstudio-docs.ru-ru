---
title: Создание расширений C++ для Python
description: Пошаговое руководство по созданию расширения C++ для Python с помощью Visual Studio, CPython и PyBind11, включая отладку в смешанном режиме.
ms.date: 11/19/2018
ms.topic: how-to
author: JoshuaPartlow
ms.author: joshuapa
manager: jmartens
ms.custom: seodec18
ms.workload:
- python
- data-science
ms.openlocfilehash: 461e68979de6c3b711c05cc4be3ef9d5bd761397
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99885941"
---
# <a name="create-a-c-extension-for-python"></a>Создание расширения C++ для Python

Модули, написанные на C++ (или C), обычно используются для расширения возможностей интерпретатора Python, а также для доступа к низкоуровневым возможностям операционной системы. Существует три основных типа модулей:

- Модули акселератора: так как Python — это интерпретируемый язык, для повышения производительности некоторые фрагменты кода могут быть написаны на C++.
- Модули оболочки: предоставляют существующие интерфейсы C/C++ для кода Python или адаптированный API, который удобно использовать в Python.
- Модули низкоуровневого системного доступа: созданы для доступа к низкоуровневым функциям среды выполнения CPython, операционной системы и базового оборудования.

В этой статье рассматривается создание модуля расширения C++ для CPython, вычисляющего гиперболический тангенс и вызывающего его из кода Python. Подпрограмма реализована сначала на языке Python, чтобы продемонстрировать относительный прирост производительности по сравнению с реализацией той же подпрограммы на C++.

В этой статье также показаны два способа сделать C++ доступным для Python:

- Стандартные расширения CPython, как описано в [документации по Python](https://docs.python.org/3/c-api/)
- [PyBind11](https://github.com/pybind/pybind11) (рекомендуется для C++ 11 благодаря своей простоте).

Сравнение этих и других средств описано в разделе [Альтернативные подходы](#alternative-approaches) в конце этой статьи.

Полный пример из этого руководства: [python-samples-vs-cpp-extension](https://github.com/Microsoft/python-sample-vs-cpp-extension) (GitHub).

## <a name="prerequisites"></a>Предварительные требования

- Visual Studio 2017 или более поздней версии с установленными рабочими нагрузками **Разработка классических приложений на C++** и **Разработка на Python** с параметрами по умолчанию.
- В рабочей нагрузке **Разработка на Python** также установите флажок справа для параметра **Собственные средства разработки Python**. Этот параметр позволяет настроить большую часть конфигурации, описанной в этой статье. (Этот параметр также автоматически включает рабочую нагрузку C++.)

    ![Выбор параметра "Собственные средства разработки Python"](media/cpp-install-native.png)

    > [!Tip]
    > При установке рабочей нагрузки **Приложения для обработки и анализа данных и аналитические приложения** по умолчанию включаются среда Python и параметр **Собственные средства разработки Python**.

Дополнительные сведения, в том числе об использовании других версий Visual Studio, см. в руководстве по [установке поддержки Python для Visual Studio](installing-python-support-in-visual-studio.md). Если вы устанавливаете Python отдельно, обязательно выберите параметры **Download debugging symbols** (Скачать отладочные символы) и **Download debug binaries** (Скачать двоичные файлы отладки) в разделе **Дополнительные параметры** установщика. Это гарантирует наличие необходимых отладочных библиотек, если вы решите сделать отладочную сборку.

## <a name="create-the-python-application"></a>Создание приложения Python

1. Создайте проект Python в Visual Studio, выбрав **Файл** > **Создать** > **Проект**. Выполните поиск слова "Python", выберите шаблон **Приложение Python**, назначьте ему подходящее имя и расположение, а затем нажмите кнопку **ОК**.

1. Для работы с C++ необходимо использовать 32-разрядный интерпретатор Python (рекомендуемая версия — Python 3.6 или более поздняя версия). В окне **обозревателя решений** в Visual Studio разверните узел проекта, а затем — узел **окружения Python**. Если 32-разрядное окружение не указано как окружение по умолчанию (не выделено жирным шрифтом или меткой **глобальное значение по умолчанию**), следуйте инструкциям [по выбору окружения Python для проекта](selecting-a-python-environment-for-a-project.md). Если у вас не установлена 32-разрядная версия интерпретатора, см. инструкции по [установке интерпретаторов Python](installing-python-interpreters.md).

1. В файл *.py* проекта вставьте следующий код, отвечающий за тестирование производительности при вычислении гиперболического тангенса (для упрощения сравнения реализуется без использования математической библиотеки). Вы можете ввести код вручную, чтобы оценить некоторые [функции редактирования Python](editing-python-code-in-visual-studio.md).

    ```python
    from itertools import islice
    from random import random
    from time import perf_counter

    COUNT = 500000  # Change this value depending on the speed of your computer
    DATA = list(islice(iter(lambda: (random() - 0.5) * 3.0, None), COUNT))

    e = 2.7182818284590452353602874713527

    def sinh(x):
        return (1 - (e ** (-2 * x))) / (2 * (e ** -x))

    def cosh(x):
        return (1 + (e ** (-2 * x))) / (2 * (e ** -x))

    def tanh(x):
        tanh_x = sinh(x) / cosh(x)
        return tanh_x

    def test(fn, name):
        start = perf_counter()
        result = fn(DATA)
        duration = perf_counter() - start
        print('{} took {:.3f} seconds\n\n'.format(name, duration))

        for d in result:
            assert -1 <= d <= 1, " incorrect values"

    if __name__ == "__main__":
        print('Running benchmarks with COUNT = {}'.format(COUNT))

        test(lambda d: [tanh(x) for x in d], '[tanh(x) for x in d] (Python implementation)')
    ```

1. Запустите программу с помощью команды **Отладка** > **Запуск без отладки** (или нажмите клавиши **CTRL**+**F5**), чтобы просмотреть результаты. Чтобы изменить длительность выполнения тестов производительности, можно настроить переменную `COUNT`. В целях этого руководства задайте значение так, чтобы тест производительности занимал приблизительно две секунды.

> [!TIP]
> При выполнении тестов производительности всегда выбирайте **Отладка** > **Запуск без отладки** во избежание издержки при выполнении кода в отладчике Visual Studio.

## <a name="create-the-core-c-projects"></a>Создание основных проектов C++

Следуйте инструкциям в этом разделе, чтобы создать два идентичных проекта C++ с именами superfastcode и superfastcode2. Позже вы используете в каждом проекте разные способы предоставления кода C++ для Python.

1. Убедитесь, что в переменной среды `PYTHONHOME` указан путь к интерпретатору Python, который вы собираетесь использовать. Проекты C++ в Visual Studio используют эту переменную для поиска различных файлов, например *python.h*, используемых при создании модулей расширения для Python.

1. Щелкните решение в **обозревателе решений** правой кнопкой мыши и выберите **Добавить** > **Новый проект**. Решение Visual Studio может одновременно содержать проекты Python и C++ (одно из преимуществ использования Visual Studio для Python).

1. Выполните поиск "C++", выберите **Пустой проект**, укажите имя superfastcode (superfastcode2 для второго проекта) и выберите **ОК**.

    > [!Tip]
    > Если вы уже установили **собственные средства разработки Python** в Visual Studio, то можете начать с шаблона **Модуль расширения Python**, который уже содержит большую часть описываемых ниже функций. Но в этом пошаговом руководстве начало работы с пустого проекта позволяет шаг за шагом продемонстрировать создание модуля расширения. Когда вы освоите процесс, шаблон позволит вам сэкономить время при написании собственных расширений.

1. Создайте файл C++ в новом проекте. Для этого щелкните правой кнопкой мыши узел **Исходные файлы** и выберите **Добавить** > **Новый элемент**, затем выберите **Файл C++** , присвойте ему имя `module.cpp` и нажмите кнопку **ОК**.

    > [!Important]
    > Файл с расширением *.cpp* нужен, чтобы активировать страницы свойств C++ в последующих шагах.

1. В **обозревателе решений** щелкните проект C++ правой кнопкой мыши и выберите пункт **Свойства**.

1. В верхней части появившегося диалогового окна **Страницы свойств** задайте для параметра **Конфигурация** значение **Все конфигурации**, а для параметра **Платформа** — **Win32**.

1. Задайте определенные свойства, как описано в таблице ниже, а затем нажмите кнопку **ОК**.

    | Вкладка | Свойство. | Значение |
    | --- | --- | --- |
    | **Общие сведения** | **Общие** > **Целевое имя** | Укажите имя модуля, которое будет использоваться из Python в инструкциях `from...import`. Это же имя используется в C++ при определении модуля для Python. Если вы хотите применять имя проекта в качестве имени модуля, сохраните значение по умолчанию **$(ProjectName)** . |
    | | **Общие** > **Целевое расширение** | **.pyd** |
    | | **Проект по умолчанию** > **Тип конфигурации** | **Динамическая библиотека (.dll)** |
    | **C/C++**  > **Общие** | **Дополнительные каталоги включаемых файлов** | Добавьте подходящую для вашей установки папку *include* Python, например `c:\Python36\include`.  |
    | **C/C++**  > **Препроцессор** | **Определения препроцессора** | **Только CPython**. Добавьте `Py_LIMITED_API;` в начало строки (включая точку с запятой). Это определение ограничивает некоторые функции, которые можно вызывать из Python, и расширяет возможности по переносу кода между разными версиями Python. Если вы работаете с PyBind11, не добавляйте это определение. В противном случае вы увидите ошибки сборки. |
    | **C/C++**  > **Создание кода** | **Библиотека времени выполнения** | **Многопоточная DLL (/MD)** (см. предупреждение ниже) |
    | **Компоновщик** > **Общие** | **Дополнительные каталоги библиотек** | Добавьте подходящую для вашей установки папку Python *libs* с файлами *.lib*, например `c:\Python36\libs`. (Обязательно укажите папку *libs*, содержащую файлы *.lib*, но *не* папку *LIb*, содержащую файлы *.py*.) |

    > [!Tip]
    > Если вы не видите вкладку C/C++ в свойствах проекта, значит, в проекте нет файлов, определенных как исходные файлы C и C++. Такая ситуация может возникнуть, если вы создали исходный файл без расширения *.c* или *.cpp*. Например, если ранее вы случайно ввели `module.coo` вместо `module.cpp` в диалоговом окне создания элемента, Visual Studio создает файл, но не задает для него тип "Код C/C+", что требуется для активации вкладки свойств C/C++. Такая неправильная идентификация остается актуальной и в случае переименования файла с использованием `.cpp`. Чтобы правильно задать тип файла, в **обозревателе решений** щелкните файл правой кнопкой мыши, выберите **Свойства**, затем установите для параметра **Тип файла** значение **Код C/C++** .

    > [!Warning]
    > Для параметра **C/C++**  > **Создание кода** > **Библиотека времени выполнения** обязательно задайте значение **Многопоточная библиотека DLL (/MD)** даже для конфигурации отладки, так как этот параметр используется при сборке неотладочных двоичных файлов Python. Если при использовании CPython вы задали параметр **Многопоточная DLL с возможностью отладки (/MDd)** , при сборке конфигурации **Отладка** возникает ошибка **C1189: Py_LIMITED_API несовместим с Py_DEBUG, Py_TRACE_REFS и Py_REF_DEBUG**. Кроме того, если удалить `Py_LIMITED_API` (требуется при использовании CPython, но не PyBind11) во избежание этой ошибки сборки, Python аварийно завершает работу при попытке импортировать модуль. (Этот сбой возникает в вызове библиотеки DLL `PyModule_Create`, как описано ниже, и сопровождается сообщением **Неустранимая ошибка Python: PyThreadState_Get: нет текущего потока**.)
    >
    > Параметр /MDd используется для сборки двоичных файлов отладки Python (например, *python_d.exe*), но его выбор для библиотеки DLL расширения по-прежнему вызывает ошибку сборки `Py_LIMITED_API`.

1. Щелкните проект C++ правой кнопкой мыши и выберите **Сборка**, чтобы протестировать конфигурации (для **отладки** и **выпуска**). Файлы *.pyd* находятся в папке **solution** в каталогах **Debug** и **Release**, а не в самой папке проекта C++.

1. Добавьте следующий код в файл *module.cpp* проекта:

    ```cpp
    #include <Windows.h>
    #include <cmath>

    const double e = 2.7182818284590452353602874713527;

    double sinh_impl(double x) {
        return (1 - pow(e, (-2 * x))) / (2 * pow(e, -x));
    }

    double cosh_impl(double x) {
        return (1 + pow(e, (-2 * x))) / (2 * pow(e, -x));
    }

    double tanh_impl(double x) {
        return sinh_impl(x) / cosh_impl(x);
    }
    ```

1. Еще раз выполните сборку проекта C++, чтобы убедиться в правильности кода.

1. Если вы еще этого не сделали, повторите предыдущие действия, чтобы создать второй проект с именем superfastcode2 с идентичным содержимым.

## <a name="convert-the-c-projects-to-extensions-for-python"></a>Преобразование проекта C++ в расширения для Python

Чтобы превратить библиотеку DLL на C++ в расширение для Python, сначала нужно изменить экспортированные методы для взаимодействия с типами Python. После этого нужно добавить функцию, экспортирующую модуль, а также определения методов модуля.

В последующих разделах объясняется, как выполнять эти действия с помощью расширений CPython и PyBind11.

### <a name="cpython-extensions"></a>Расширения CPython

Пояснения к тому, что показано в этом разделе для Python 3.x, см. в [справочном руководстве по API Python/C](https://docs.python.org/3/c-api/index.html) и, главным образом, в разделе [Module Objects](https://docs.python.org/3/c-api/module.html) (Модульные объекты) на сайте python.org (не забудьте выбрать вашу версию Python в раскрывающемся списке в правом верхнем углу, чтобы увидеть подходящую документацию).

Если вы работаете с Python 2.7, см. статьи [Extending Python 2.7 with C or C++](https://docs.python.org/2.7/extending/extending.html) (Расширение Python 2.7 с помощью C и C++) и [Porting Extension Modules to Python 3](https://docs.python.org/2.7/howto/cporting.html) (Перенос модулей расширения на Python 3) на сайте python.org.

1. В верхнюю часть *module.cpp* включите *Python.h*:

    ```cpp
    #include <Python.h>
    ```

1. Измените метод `tanh_impl`, чтобы он принимал и возвращал типы Python (`PyObject*`):

    ```cpp
    PyObject* tanh_impl(PyObject *, PyObject* o) {
        double x = PyFloat_AsDouble(o);
        double tanh_x = sinh_impl(x) / cosh_impl(x);
        return PyFloat_FromDouble(tanh_x);
    }
    ```

1. Добавьте структуру, определяющую способ представления функции `tanh_impl` C++ для Python:

    ```cpp
    static PyMethodDef superfastcode_methods[] = {
        // The first property is the name exposed to Python, fast_tanh, the second is the C++
        // function name that contains the implementation.
        { "fast_tanh", (PyCFunction)tanh_impl, METH_O, nullptr },

        // Terminate the array with an object containing nulls.
        { nullptr, nullptr, 0, nullptr }
    };
    ```

1. Добавьте структуру, которая определяет модуль так, как вы хотите ссылаться на него в своем коде Python, в частности, при использовании оператора `from...import`. (Сделайте это значением в свойствах проекта в разделе **Свойства конфигурации** > **Общие** > **Целевое имя**.) В приведенном ниже примере имя модуля superfastcode означает, что `from superfastcode import fast_tanh` можно использовать в Python, так как функция `fast_tanh` определена в `superfastcode_methods`. (Внутренние для проекта C++ имена файлов, такие как *module.cpp*, являются несущественными.)

    ```cpp
    static PyModuleDef superfastcode_module = {
        PyModuleDef_HEAD_INIT,
        "superfastcode",                        // Module name to use with Python import statements
        "Provides some functions, but faster",  // Module description
        0,
        superfastcode_methods                   // Structure that defines the methods of the module
    };
    ```

1. Добавьте метод, вызываемый Python при загрузке модуля. Он должен иметь имя `PyInit_<module-name>`, где &lt;module_name&gt; точно соответствует значению свойства **Общие** > **Целевое имя** проекта C++ (то есть соответствует имени файла *.pyd*, созданного проектом).

    ```cpp
    PyMODINIT_FUNC PyInit_superfastcode() {
        return PyModule_Create(&superfastcode_module);
    }
    ```

1. Задайте целевую конфигурацию **Выпуск** и повторно создайте проект C++, чтобы проверить код. Если возникли ошибки, обратитесь к разделу [Устранение проблем](#troubleshooting), расположенному ниже.

### <a name="pybind11"></a>PyBind11

Если вы выполнили действия, описанные в предыдущем разделе, вы наверняка заметили, что использовали много стандартного кода для создания необходимых структур модуля для кода C++. PyBind11 упрощает процесс с помощью макросов в файле заголовка C++, которые достигают того же результата с гораздо меньшим объемом кода. Сведения о концепциях в этом разделе см. в разделе [Основы PyBind11](https://github.com/pybind/pybind11/blob/master/docs/basics.rst) (github.com).

1. Установите PyBind11 с помощью pip: `pip install pybind11` или `py -m pip install pybind11`.

1. В верхнюю часть *module.cpp* включите *pybind11.h*:

    ```cpp
    #include <pybind11/pybind11.h>
    ```

1. В нижней части *module.cpp* используйте макрос `PYBIND11_MODULE`, чтобы определить точку входа в функцию C++:

    ```cpp
    namespace py = pybind11;

    PYBIND11_MODULE(superfastcode2, m) {
        m.def("fast_tanh2", &tanh_impl, R"pbdoc(
            Compute a hyperbolic tangent of a single argument expressed in radians.
        )pbdoc");

    #ifdef VERSION_INFO
        m.attr("__version__") = VERSION_INFO;
    #else
        m.attr("__version__") = "dev";
    #endif
    }
    ```

1. Задайте целевую конфигурацию **Выпуск** и создайте проект C++, чтобы проверить код. Если возникли ошибки, читайте следующий раздел об устранении неполадок.

### <a name="troubleshooting"></a>Устранение неполадок

Модуль C++ может не компилироваться по следующим причинам:

- Не удалось найти *Python.h* (**E1696: не удается открыть исходный файл Python.h** и (или) **C1083: не удается открыть включаемый файл: Python.h: отсутствует такой файл или каталог**): убедитесь, что путь в разделе **C/C++**  > **Общие** > **Дополнительные каталоги включаемых файлов** в свойствах проекта указывает на папку *include* установки Python. См. шаг 6 в разделе [Создание основного проекта C++](#create-the-core-c-projects).

- Не удается найти библиотеки Python. Убедитесь, что путь **Компоновщик** > **Общие** > **Дополнительные каталоги библиотек** в свойствах проекта указывает на папку *libs* установки Python. См. шаг 6 в разделе [Создание основного проекта C++](#create-the-core-c-projects).

- Ошибки компоновщика, связанные с целевой архитектурой. Измените архитектуру целевого проекта C++ в соответствии с вашей установкой Python. Например, если вы хотите использовать в проекте C++ версию Python x64, но у вас установлена версия x86, измените проект C++ для работы с версией х86.

## <a name="test-the-code-and-compare-the-results"></a>Тестирование кода и сравнение результатов

Теперь, когда библиотека DLL структурирована как расширения Python, можно ссылаться на них из проекта Python, импортировать модули и использовать их методы.

### <a name="make-the-dll-available-to-python"></a>Предоставление доступа к библиотеке DLL для Python

Предоставить Python доступ к библиотеке DLL можно двумя способами.

Первый метод работает, если проект Python и проект C++ находятся в одном решении. В **обозревателе решений** щелкните правой кнопкой мыши узел **Ссылки** в проекте Python и затем выберите команду **Добавить ссылку**. В открывшемся диалоговом окне перейдите на вкладку **Проекты**, выберите проекты **superfastcode** и **superfastcode2** и нажмите кнопку **OK**.

![Добавление ссылки на проект superfastcode](media/cpp-add-reference.png)

Альтернативный метод, описанный далее, предполагает установку модуля в глобальной среде Python и предоставление к нему доступа в других проектах Python. (При этом обычно требуется обновить базу данных завершения IntelliSense для этой среды в Visual Studio 2017 версии 15.5 и более ранних версий. Обновление также требуется и при извлечении модуля из среды.)

1. Если вы используете Visual Studio 2017 или более поздней версии, запустите Visual Studio Installer, выберите **Изменить**, затем **Отдельные компоненты** > **Компиляторы, средства сборки и среды выполнения** > **Набор инструментов Visual C++ 2015.3 версии 140**. Этот шаг необходим, так как Python (для Windows) сам создан с помощью Visual Studio 2015 (версия 14.0) и поэтому ожидает наличия этих средств при создании расширения одним из описанных здесь способов. (Обратите внимание, что может потребоваться установить 32-разрядную версию Python и нацелить библиотеку DLL на Win32, а не на x64.)

1. Создайте в проекте C++ файл с именем *setup.py*, щелкнув проект правой кнопкой мыши и выбрав пункт **Добавить** > **Новый элемент**. Выберите тип файла **Файл C++ (.cpp)** , присвойте файлу имя `setup.py` и щелкните **ОК**. (Присвоение файлу расширения *.py* позволяет Visual Studio распознавать его как файл Python несмотря на использование шаблона файла C++.) Когда файл откроется в редакторе, вставьте в него следующий код в зависимости от метода расширения:

    **Расширения CPython (проект superfastcode):**

    ```python
    from distutils.core import setup, Extension, DEBUG

    sfc_module = Extension('superfastcode', sources = ['module.cpp'])

    setup(name = 'superfastcode', version = '1.0',
        description = 'Python Package with superfastcode C++ extension',
        ext_modules = [sfc_module]
        )
    ```

    Документация к этому скрипту приведена в статье о [создании расширений на C и C++](https://docs.python.org/3/extending/building.html) (python.org).

    **PyBind11 (проект superfastcode2):**

    ```python
    import os, sys

    from distutils.core import setup, Extension
    from distutils import sysconfig

    cpp_args = ['-std=c++11', '-stdlib=libc++', '-mmacosx-version-min=10.7']

    sfc_module = Extension(
        'superfastcode2', sources = ['module.cpp'],
        include_dirs=['pybind11/include'],
        language='c++',
        extra_compile_args = cpp_args,
        )

    setup(
        name = 'superfastcode2',
        version = '1.0',
        description = 'Python package with superfastcode2 C++ extension (PyBind11)',
        ext_modules = [sfc_module],
    )
    ```

1. При использовании в командной строке код *setup.py* предписывает Python создать расширение с помощью набора инструментов C++ Visual Studio 2015. Откройте командную строку с повышенными привилегиями, перейдите в папку с проектом C++ (то есть в папку, содержащую *setup.py*), а затем введите следующую команду:

    ```command
    pip install .
    ```

    или

    ```command
    py -m pip install .
    ```

### <a name="call-the-dll-from-python"></a>Вызов библиотеки DLL из Python

После того как вы предоставили библиотеки DLL для Python, как описано в предыдущем разделе, вы можете вызвать функции `superfastcode.fast_tanh` и `superfastcode2.fast_tanh2` из кода Python и сравнить их эффективность с реализацией Python:

1. Добавьте приведенные ниже строки в файл *.py*, чтобы вызвать методы, экспортированные из библиотек DLL, и отобразить их выходные данные:

    ```python
    from superfastcode import fast_tanh
    test(lambda d: [fast_tanh(x) for x in d], '[fast_tanh(x) for x in d] (CPython C++ extension)')

    from superfastcode2 import fast_tanh2
    test(lambda d: [fast_tanh2(x) for x in d], '[fast_tanh2(x) for x in d] (PyBind11 C++ extension)')
    ```

1. Запустите программу Python (**Отладка** > **Запуск без отладки** или **CTRL**+**F5**) и убедитесь, что подпрограмма C++ выполняется примерно в 5–20 раз быстрее, чем реализация Python. Обычно выводится следующий результат.

    ```output
    Running benchmarks with COUNT = 500000
    [tanh(x) for x in d] (Python implementation) took 0.758 seconds

    [fast_tanh(x) for x in d] (CPython C++ extension) took 0.076 seconds

    [fast_tanh2(x) for x in d] (PyBind11 C++ extension) took 0.204 seconds
    ```

    Если команда **Запуск без отладки недоступна**, в **обозревателе решений** щелкните правой кнопкой мыши проект Python и выберите команду **Назначить запускаемым проектом**.

1. Попробуйте увеличить значение переменной `COUNT`, чтобы разница стала еще очевиднее. Кроме того, **отладочная** сборка модуля C++ выполняется медленнее, чем сборка **выпуска**, так как **отладочная** сборка менее оптимизирована и включает в себя разные проверки ошибок. Вы можете свободно переключаться между этими конфигурациями для их сравнения.

> [!NOTE]
> В выходных данных вы увидите, что расширение PyBind11 не такое быстрое, как расширение CPython, хотя все равно значительно быстрее, чем прямая реализация на языке Python. Разница связана с небольшим количеством издержек для отдельных вызовов, которые использует PyBind11, чтобы значительно упростить интерфейс C++. Это различие для одного вызова почти незаметно, но так как тестовый код вызывает функции расширения 500 000 раз, издержки накапливаются. Как правило, функция C++ выполняет гораздо больше работы, чем обычные методы `fast_tanh[2]`, используемые здесь, в этом случае издержки не имеют значения. Но если вы реализуете методы, которые могут вызываться тысячи раз в секунду, подход CPython будет иметь лучшую производительность по сравнению с PyBind11.

## <a name="debug-the-c-code"></a>Отладка кода C++

Visual Studio поддерживает совместную отладку кода на Python и C++. В этом разделе этот процесс рассматривается на примере проекта **superfastcode**. Для проекта **superfastcode2** действия будут аналогичными.

1. Щелкните проект Python правой кнопкой мыши в **обозревателе решений**, выберите **Свойства**, откройте вкладку **Отладка** и выберите **Отладка** > **Разрешить отладку машинного кода**.

    > [!Tip]
    > При включении отладки машинного кода окно вывода Python может исчезнуть сразу после завершения программы без обычной паузы с сообщением **Для продолжения нажмите любую клавишу**. Чтобы сделать паузу принудительно, добавьте параметр `-i` в поле **Запуск** > **Аргументы интерпретатора** на вкладке **Отладка** при включении отладки машинного кода. Этот аргумент переводит интерпретатор Python в интерактивный режим по завершении кода, после чего он ожидает нажатия клавиш **CTRL**+**Z** > **ВВОД** для выхода. (Кроме того, если вы не против изменения кода Python, можно добавить в конец программы операторы `import os` и `os.system("pause")`. Этот код дублирует исходный запрос с паузой.)

1. Чтобы сохранить изменения свойств, выберите пункт меню **Файл** > **Сохранить**.

1. На панели инструментов Visual Studio измените конфигурацию сборки на режим **Отладка**.

    ![Изменение конфигурации сборки на режим "Отладка"](media/cpp-set-debug.png)

1. Так как в отладчике код, как правило, выполняется дольше, может потребоваться уменьшить значение переменной `COUNT` в файле *.py* приблизительно в пять раз (например, вместо `500000` укажите `100000`).

1. В коде C++ установите точку останова в первой строке метода `tanh_impl`, а затем запустите отладчик (**F5** или **Отладка** > **Начать отладку**). При вызове этого кода отладчик останавливается. Если точка останова не сработает, проверьте, выбрана ли конфигурация **отладки** и сохранен ли проект (при запуске отладчика он не сохраняется автоматически).

    ![Остановка на точке останова в коде C++](media/cpp-debugging.png)

1. На этом этапе вы можете пошагово выполнять код на C++, проверять переменные и т. д. Эти возможности подробно описаны в руководстве по [совместной отладке C++ и Python](debugging-mixed-mode-c-cpp-python-in-visual-studio.md).

## <a name="alternative-approaches"></a>Альтернативные подходы

Существуют различные средства для создания расширений Python, как описано в таблице ниже. Первые две записи для CPython и PyBind11 уже обсуждались в этой статье.

| Подход | Появление | Представители | Преимущества | Недостатки |
| --- | --- | --- | --- | --- |
| Модули расширений C/C++ для CPython | 1991 | Стандартная библиотека | [Подробная документация и учебники](https://docs.python.org/3/c-api/). Полный контроль. | Компиляция, переносимость, управление ссылками. Хорошее знание C. |
| [PyBind11](https://github.com/pybind/pybind11) (рекомендуется для C++) | 2015 |  | Упрощенная библиотека заголовков для создания привязок Python к существующему коду C++. Малое число зависимостей. Совместимость с PyPy. | Новый, менее проверенный подход. Частое использование функций C++11. Краткий список поддерживаемых компиляторов (включает Visual Studio). |
| Cython (рекомендуется для C) | 2007 | [gevent](https://www.gevent.org/), [kivy](https://kivy.org/) | Аналогичен Python. Высокая степень зрелости. Высокая производительность. | Компиляция, новый синтаксис, новая цепочка инструментов. |
| [Boost.Python](https://www.boost.org/doc/libs/1_66_0/libs/python/doc/html/index.html) | 2002 | | Работает практически с любым компилятором C++. | Большой и сложный набор библиотек. Содержит много обходных путей для старых компиляторов. |
| ctypes | 2003 | [oscrypto](https://github.com/wbond/oscrypto) | Отсутствие компиляции, широкая доступность. | Обращение к структурам C и их изменение затруднено и подвержено ошибкам. |
| SWIG | 1996 | [crfsuite](http://www.chokkan.org/software/crfsuite/) | Создание привязок сразу для нескольких языков. | Чрезмерные затраты, когда единственной целью является Python. |
| cffi | 2013 | [cryptography](https://cryptography.io/en/latest/), [pypy](https://pypy.org/) | Простота интеграции, совместимость с PyPy. | Новый, менее проверенный подход. |
| [cppyy](https://cppyy.readthedocs.io/en/latest/) | 2017 | | Подобен cffi при использовании C++. | Новый, возможны проблемы с VS 2017. |

## <a name="see-also"></a>См. также

Полный пример из этого руководства: [python-samples-vs-cpp-extension](https://github.com/Microsoft/python-sample-vs-cpp-extension) (GitHub).
