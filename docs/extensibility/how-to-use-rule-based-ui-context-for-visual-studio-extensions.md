---
title: Практическое руководство. Использовать контекст пользовательского интерфейса на основе правил для расширений Visual Studio | Документация Майкрософт
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 8dd2cd1d-d8ba-49b9-870a-45acf3a3259d
author: madskristensen
ms.author: madsk
ms.workload:
- vssdk
ms.openlocfilehash: fd7e091192e0111a9dcf0997af8316daef364adb
ms.sourcegitcommit: e98db44f3a33529b0ba188d24390efd09e548191
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/25/2019
ms.locfileid: "71252330"
---
# <a name="how-to-use-rule-based-ui-context-for-visual-studio-extensions"></a>Практическое руководство. Использовать контекст пользовательского интерфейса на основе правил для расширений Visual Studio

Visual Studio позволяет загружать пакеты VSPackage, когда активированы определенные <xref:Microsoft.VisualStudio.Shell.UIContext>хорошо известные s. Однако эти контексты пользовательского интерфейса не детализированы, что оставляет разработчикам расширений ненужные элементы, но позволяет выбрать доступный контекст пользовательского интерфейса, который активируется до того момента, когда ему действительно требуется загрузить VSPackage. Список хорошо известных контекстов пользовательского интерфейса см. в разделе <xref:Microsoft.VisualStudio.Shell.KnownUIContexts>.

Загрузка пакетов может повлиять на производительность и загружать их быстрее, чем это необходимо, но не является оптимальной практикой. В Visual Studio 2015 появилась концепция контекстов пользовательского интерфейса на основе правил, механизм, позволяющий авторам расширений определять точные условия, при которых активируется контекст пользовательского интерфейса и загружаются связанные пакеты VSPackage.

## <a name="rule-based-ui-context"></a>Контекст пользовательского интерфейса на основе правил

"Правило" состоит из нового контекста пользовательского интерфейса (GUID) и логического выражения, которое ссылается на один или несколько "терминов" в сочетании с логическими операциями "and", "or" и "not". "Условия" оцениваются динамически во время выполнения, и выражение вычисляется повторно при каждом изменении его условий. Если выражение принимает значение true, активируется связанный контекст пользовательского интерфейса. В противном случае контекст пользовательского интерфейса отключается.

Контекст пользовательского интерфейса на основе правил можно использовать различными способами.

1. Укажите ограничения видимости для команд и окон инструментов. Окна команд и средств можно скрыть до тех пор, пока не будет выполнено правило контекста пользовательского интерфейса.

2. Как ограничения автоматической загрузки: автоматическая загрузка пакетов только при соблюдении правила.

3. В качестве отложенной задачи: отложенная загрузка до тех пор, пока не будет пройден указанный интервал, и правило все еще выполняется.

   Этот механизм может использоваться любым расширением Visual Studio.

## <a name="create-a-rule-based-ui-context"></a>Создание контекста пользовательского интерфейса на основе правил
 Предположим, у вас есть расширение с именем Тестпаккаже, которое предоставляет команду меню, применимую только к файлам с расширением *config* . Перед VS2015 лучшим вариантом было Загрузка тестпаккаже при <xref:Microsoft.VisualStudio.Shell.KnownUIContexts.SolutionExistsAndFullyLoadedContext%2A> активации контекста пользовательского интерфейса. Загрузка Тестпаккаже таким образом неэффективна, так как загруженное решение может даже не содержать *config* -файл. В этих шагах показано, как можно использовать контекст ПОЛЬЗОВАТЕЛЬСКОГО интерфейса на основе правил, чтобы активировать контекст пользовательского интерфейса только в том случае, если выбран файл с расширением *config* , и Load тестпаккаже при активации этого контекста пользовательского интерфейса.

1. Определите новый GUID UIContext и добавьте его в класс <xref:Microsoft.VisualStudio.Shell.ProvideAutoLoadAttribute> VSPackage и. <xref:Microsoft.VisualStudio.Shell.ProvideUIContextRuleAttribute>

    Например, предположим, что будет добавлен новый UIContext "Уиконтекстгуид". Созданный GUID (GUID можно создать, щелкнув **инструменты** > **Создать GUID**) — "8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B". Затем добавьте следующее объявление в класс Package:

   ```csharp
   public const string UIContextGuid = "8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B";
   ```

    Для атрибутов добавьте следующие значения: (Сведения об этих атрибутах будут объяснены позже)

   ```csharp
   [ProvideAutoLoad(TestPackage.UIContextGuid)]
   [ProvideUIContextRule(TestPackage.UIContextGuid,
       name: "Test auto load",
       expression: "DotConfig",
       termNames: new[] { "DotConfig" },
       termValues: new[] { "HierSingleSelectionName:.config$" })]
   ```

    Эти метаданные определяют новый UIContext GUID (8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B) и выражение, ссылающееся на один термин "Дотконфиг". Термин "дотконфиг" принимает значение true, когда текущее выделение в активной иерархии имеет имя, совпадающее с шаблоном регулярного выражения "\\. config $" (заканчивается на *. config*). Значение (по умолчанию) определяет необязательное имя для правила, полезное для отладки.

    Значения атрибута добавляются к pkgdef, созданному во время сборки.

2. В файле VSCT для команд Тестпаккаже добавьте к соответствующим командам флаг "Динамиквисибилити":

   ```xml
   <CommandFlag>DynamicVisibility</CommandFlag>
   ```

3. В разделе видимости VSCT свяжите соответствующие команды с новым идентификатором GUID UIContext, определенным в #1:

   ```xml
   <VisibilityConstraints>
       <VisibilityItem guid="guidTestPackageCmdSet" id="TestId"  context="UIContextGuid"/>
   </VisibilityConstraints>
   ```

4. В разделе символы добавьте определение UIContext:

   ```xml
   <GuidSymbol name="UIContextGuid" value="{8B40D5E2-5626-42AE-99EF-3DD1EFF46E7B}" />
   ```

    Теперь команды контекстного меню для  *\*файлов. config* будут видны, только если выбранный элемент в обозревателе решений является файлом *. config* , и пакет не будет загружен до тех пор, пока не выбрана одна из этих команд.

   Затем используйте отладчик, чтобы убедиться, что пакет загружается только в том случае, если предполагается. Для отладки Тестпаккаже:

5. Установите точку останова в <xref:Microsoft.VisualStudio.Shell.Package.Initialize%2A> методе.

6. Создайте Тестпаккаже и начните отладку.

7. Создайте проект или откройте его.

8. Выберите любой файл с расширением, отличным от *. config*. Попадание в точку останова не должно.

9. Выберите файл *app. config* .

   Тестпаккаже загружает и останавливается в точке останова.

## <a name="add-more-rules-for-ui-context"></a>Добавить дополнительные правила для контекста пользовательского интерфейса
 Поскольку правила контекста пользовательского интерфейса являются логическими выражениями, можно добавить более ограниченные правила для контекста пользовательского интерфейса. Например, в приведенном выше контексте пользовательского интерфейса можно указать, что правило применяется только при загрузке решения с проектом. Таким образом, команды не будут отображаться при открытии файла *config* в качестве отдельного файла, а не в составе проекта.

```csharp
[ProvideAutoLoad(TestPackage.UIContextGuid)]
[ProvideUIContextRule(TestPackage.UIContextGuid,
    name: "Test auto load",
    expression: "(SingleProject | MultipleProjects) & DotConfig",
    termNames: new[] { "SingleProject", "MultipleProjects","DotConfig" },
    termValues: new[] { VSConstants.UICONTEXT_SolutionHasSingleProject_string , VSConstants.UICONTEXT_SolutionHasMultipleProjects_string , "HierSingleSelectionName:.config$" })]
```

 Теперь выражение ссылается на три условия. Первые два термина "Синглепрожект" и "Мултиплепрожектс" ссылаются на другие хорошо известные контексты пользовательского интерфейса (по их идентификаторам GUID). Третий термин «Дотконфиг» — это контекст пользовательского интерфейса на основе правил, определенный ранее в этой статье.

## <a name="delayed-activation"></a>Отложенная активация
 Правила могут иметь необязательные "задержки". Задержка указывается в миллисекундах. Если задано значение, задержка приводит к задержке активации или деактивации контекста пользовательского интерфейса правила на этот интервал времени. Если правило изменяется до интервала задержки, ничего не происходит. Этот механизм можно использовать для "пошагового" инициализации, особенно однократная инициализация без использования таймеров или регистрации уведомлений о неактивности.

 Например, можно указать в правиле тестовой нагрузки задержку в 100 миллисекунд:

```csharp
[ProvideAutoLoad(TestPackage.UIContextGuid)]
[ProvideUIContextRule(TestPackage.UIContextGuid,
    name: "Test auto load",
    expression: "DotConfig",
    termNames: new[] { "DotConfig" },
    termValues: new[] { "HierSingleSelectionName:.config$" },
    delay: 100)]
```

## <a name="term-types"></a>Типы терминов

Ниже приведены различные типы поддерживаемых терминов.

|Термин|Описание|
|-|-|
|{nnnnnnnn-NNNN-NNNN-NNNN-нннннннннннн}|Идентификатор GUID ссылается на контекст пользовательского интерфейса. Термин будет иметь значение true, если активен контекст пользовательского интерфейса, и false в противном случае.|
|Хиерсинглеселектионнаме:\<шаблон >|Термин будет иметь значение true, если выбор в активной иерархии является одним элементом, а имя выбранного элемента соответствует регулярному выражению .NET, заданному шаблоном.|
|Усерсеттингссторекуери:\<> запроса|"запрос" представляет полный путь к хранилищу пользовательских параметров, который должен иметь ненулевое значение. Запрос разбивается на "Collection" и "propertyName" по последней косой черте.|
|Конфигсеттингссторекуери:\<> запроса|"запрос" представляет полный путь к хранилищу параметров конфигурации, который должен иметь ненулевое значение. Запрос разбивается на "Collection" и "propertyName" по последней косой черте.|
|Активепрожектфлавор:\<прожекттипегуид >|Термин будет иметь значение true, если текущий выбранный проект является разновидностью (агрегированный) и имеет версию, совпадающую с заданным идентификатором GUID типа проекта.|
|Активидиторконтенттипе:\<ContentType >|Этот термин будет иметь значение true, если выбранный документ является текстовым редактором с данным типом содержимого.|
|Активепрожекткапабилити:\<выражение >|Термин имеет значение true, если возможности активного проекта соответствуют указанному выражению. Выражение может представлять собой нечто вроде VB &#124; CSharp.|
|Солутионхаспрожекткапабилити:\<выражение >|Аналогично выше, но термин имеет значение true, если в решении есть загруженный проект, соответствующий выражению.|
|Солутионхаспрожектфлавор:\<прожекттипегуид >|Термин будет иметь значение true, если в решении имеется проект с установленным флагом (агрегированный) и он имеет версию, совпадающую с идентификатором GUID данного типа проекта.|
|Прожектаддедитем:\<шаблон >| Термин имеет значение true, когда файл, соответствующий "шаблону", добавляется в проект в открытом солуион.|
|Активепрожектаутпуттипе:\<outputType >|Термин имеет значение true, если тип вывода для активного проекта совпадает точно.  Значение outputType может быть целым числом или <xref:Microsoft.VisualStudio.Shell.Interop.__VSPROJOUTPUTTYPE> типом.|
|Активепрожектбуилдпроперти:\<буилдпроперти > =\<Regex >|Термин имеет значение true, если в активном проекте задано указанное свойство сборки, а значение свойства соответствует указанному фильтру регулярных выражений. Дополнительные сведения о свойствах сборки см. в статье [Сохранение данных в файлах проекта MSBuild](internals/persisting-data-in-the-msbuild-project-file.md) .|
|Солутионхаспрожектбуилдпроперти:\<буилдпроперти > =\<Regex >|Термин имеет значение true, если в решении загружен проект с указанным свойством сборки, а значение свойства соответствует указанному фильтру регулярных выражений.|

## <a name="compatibility-with-cross-version-extension"></a>Совместимость с расширением для разных версий

Контексты пользовательского интерфейса на основе правил — это новая функция Visual Studio 2015, которая не будет перенесена в более ранние версии. Отсутствие переноса к более ранним версиям создает проблему с расширениями или пакетами, предназначенными для нескольких версий Visual Studio. Эти версии должны быть загружены в Visual Studio 2013 и более ранних версий, но могут оказаться полезными из контекстов пользовательского интерфейса на основе правил, чтобы предотвратить автоматическую загрузку в Visual Studio 2015.

Чтобы обеспечить поддержку таких пакетов, записи Аутолоадпаккажес в реестре теперь могут содержать флаг в поле "значение", чтобы указать, что запись должна быть пропущена в Visual Studio 2015 и более поздних версиях. Это можно сделать, добавив параметр flags в <xref:Microsoft.VisualStudio.Shell.PackageAutoLoadFlags>. Пакеты VSPackage теперь могут добавить параметр **скипвхенуиконтекструлесактиве** к <xref:Microsoft.VisualStudio.Shell.ProvideAutoLoadAttribute> своему атрибуту, чтобы указать, что запись должна игнорироваться в Visual Studio 2015 и более поздних версиях.
## <a name="extensible-ui-context-rules"></a>Расширяемые правила контекста пользовательского интерфейса

Иногда пакеты не могут использовать статические правила контекста пользовательского интерфейса. Например, предположим, что имеется пакет, поддерживающий расширяемость, так что состояние команды основано на типах редакторов, поддерживаемых импортированными поставщиками MEF. Команда включена, если имеется расширение, поддерживающее текущий тип редактирования. В таких случаях пакет не может использовать статическое правило контекста пользовательского интерфейса, так как термины будут изменяться в зависимости от доступных расширений MEF.

Для поддержки таких пакетов контексты пользовательского интерфейса на основе правил поддерживают жестко закодированное выражение "*", которое указывает на все приведенные ниже термины, которые будут соединены с или. Это позволяет основному пакету определять известный контекст пользовательского интерфейса на основе правил и привязывать его состояние команды к этому контексту. После этого любое расширение MEF, предназначенное для главного пакета, может добавлять свои термины для редакторов, которые он поддерживает, без влияния на другие термины или основное выражение.

В документации <xref:Microsoft.VisualStudio.Shell.ProvideExtensibleUIContextRuleAttribute.%23ctor%2A> по конструктору показан синтаксис для расширенных правил контекста пользовательского интерфейса.
