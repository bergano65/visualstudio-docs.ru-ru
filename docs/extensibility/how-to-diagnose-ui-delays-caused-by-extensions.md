---
title: Диагностика задержки пользовательского интерфейса расширения в Visual Studio | Документация Майкрософт
description: Visual Studio уведомляет вас о том, что задержки пользовательского интерфейса могут быть вызваны расширением. Узнайте, как диагностировать, что в коде расширения вызывает задержки пользовательского интерфейса.
ms.custom: SEO-VS-2020
ms.date: 01/26/2018
ms.topic: conceptual
author: PooyaZv
ms.author: pozandev
manager: jmartens
ms.workload: multiple
ms.openlocfilehash: 508fdd44a1c73f66d88317b7ec304e810f5f12e3
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99890803"
---
# <a name="how-to-diagnose-ui-delays-caused-by-extensions"></a>Практическое руководство: диагностика задержек в пользовательском интерфейсе, связанных с расширениями

Когда пользовательский интерфейс перестает отвечать на запросы, Visual Studio проверяет стек вызовов потока пользовательского интерфейса, начиная с конечного объекта и работая с базой. Если Visual Studio определяет, что кадр стека вызовов принадлежит модулю, который является частью установленного и включенного расширения, он отображает уведомление.

![Уведомление о задержке пользовательского интерфейса (не отвечает)](media/ui-delay-notification-in-vs.png)

Уведомление информирует пользователя о том, что задержка пользовательского интерфейса (то есть немедленная реакция в пользовательском интерфейсе) могла быть вызвана кодом из расширения. Он также предоставляет пользователю возможность отключить расширение или будущие уведомления для этого расширения.

В этом документе описывается, как можно диагностировать, что в коде расширения вызывает отправку уведомлений о задержке пользовательского интерфейса.

> [!NOTE]
> Не используйте экспериментальный экземпляр Visual Studio для диагностики задержек пользовательского интерфейса. Некоторые части анализа стека вызовов, необходимые для уведомлений о задержке пользовательского интерфейса, отключаются при использовании экспериментального экземпляра, то есть уведомления о задержке пользовательского интерфейса могут не отображаться.

Обзор процесса диагностики выглядит следующим образом.
1. Выявление сценария триггера.
2. Перезапустите VS с ведением журнала действий.
3. Запустите трассировку ETW.
4. Снова отобразите уведомление.
5. Останавливает трассировку ETW.
6. Проверьте журнал действий, чтобы получить идентификатор задержки.
7. Проанализируйте трассировку ETW с помощью идентификатора задержки из шага 6.

В следующих разделах мы рассмотрим эти шаги более подробно.

## <a name="identify-the-trigger-scenario"></a>Указание сценария триггера

Чтобы выполнить диагностику задержки пользовательского интерфейса, сначала необходимо определить, что (последовательность действий) заставляет Visual Studio отображать уведомление. Это необходимо для того, чтобы вы могли запустить уведомление позже с включенным ведением журнала.

## <a name="restart-vs-with-activity-logging-on"></a>Перезапуск VS с ведением журнала действий

Visual Studio может создать "журнал действий", который предоставляет сведения, полезные при отладке проблемы. Чтобы включить ведение журнала действий в Visual Studio, откройте Visual Studio с `/log` параметром командной строки. После запуска Visual Studio Журнал действий хранится в следующем расположении:

```DOS
%APPDATA%\Microsoft\VisualStudio\<vs_instance_id>\ActivityLog.xml
```

Дополнительные сведения о том, как найти идентификатор экземпляра VS, см. в разделе [средства для обнаружения экземпляров Visual Studio и управления ими](../install/tools-for-managing-visual-studio-instances.md). Этот журнал действий будет использоваться позже для получения дополнительных сведений о задержках пользовательского интерфейса и связанных уведомлениях.

## <a name="starting-etw-tracing"></a>Запуск трассировки ETW

Чтобы получить трассировку ETW, можно использовать [PerfView](https://github.com/Microsoft/perfview/) . PerfView предоставляет простой в использовании интерфейс как для сбора трассировки ETW, так и для ее анализа. Чтобы получить трассировку, используйте следующую команду:

```DOS
Perfview.exe collect C:\trace.etl /BufferSizeMB=1024 -CircularMB:2048 -Merge:true -Providers:*Microsoft-VisualStudio:@StacksEnabled=true -NoV2Rundown /kernelEvents=default+FileIOInit+ContextSwitch+Dispatcher
```

Это позволяет поставщику Microsoft-VisualStudio, который является поставщиком Visual Studio, использовать для событий, связанных с уведомлениями о задержке пользовательского интерфейса. В нем также указывается ключевое слово для поставщика ядра, который PerfView может использовать для создания представления **стеков времени потока** .

## <a name="trigger-the-notification-to-appear-again"></a>Включение повторного отображения уведомления

После начала сбора трассировки PerfView можно использовать последовательность действий триггера (из шага 1) для повторного отображения уведомления. После отображения уведомления можно отключить сбор данных трассировки для PerfView, чтобы обработать и сформировать выходной файл трассировки.

## <a name="stop-etw-tracing"></a>Отключить трассировку ETW

Чтобы отключить сбор трассировки, просто нажмите кнопку " **Закрыть коллекцию** " в окне PerfView. После завершения сбора трассировки PerfView автоматически обрабатывает события ETW и создает выходной файл трассировки.

## <a name="examine-the-activity-log-to-get-the-delay-id"></a>Проверьте журнал действий, чтобы получить идентификатор задержки.

Как упоминалось ранее, журнал действий можно найти по адресу *%аппдата%\микрософт\висуалстудио \<vs_instance_id>\ActivityLog.xml*. Каждый раз, когда Visual Studio обнаруживает задержку пользовательского интерфейса расширения, он записывает узел в журнал действий, используя в `UIDelayNotifications` качестве источника. Этот узел содержит четыре части сведений о задержке пользовательского интерфейса:

- Идентификатор задержки пользовательского интерфейса — последовательный номер, который однозначно определяет задержку пользовательского интерфейса в сеансе VS.
- Идентификатор сеанса, который однозначно определяет сеанс Visual Studio от начала до закрытия
- Отображается ли уведомление для задержки пользовательского интерфейса
- Расширение, которое может вызвать задержку пользовательского интерфейса

```xml
<entry>
  <record>271</record>
  <time>2018/02/03 12:02:52.867</time>
  <type>Information</type>
  <source>UIDelayNotifications</source>
  <description>A UI delay (Delay ID = 0) has been detected. (Session ID=16e49d4b-26c2-4247-ad1c-488edeb185e0; Blamed extension="UIDelayR2"; Notification shown? Yes.)</description>
</entry>
```

> [!NOTE]
> Не все задержки пользовательского интерфейса приводят к уведомлению. Поэтому всегда следует проверять **отображаемое уведомление?** значение, чтобы правильно определить правильную задержку пользовательского интерфейса.

После того как в журнале действий будет обнаружена правильная Задержка пользовательского интерфейса, запишите идентификатор задержки пользовательского интерфейса, указанный в узле. Идентификатор будет использоваться для поиска соответствующего события ETW на следующем шаге.

## <a name="analyze-the-etw-trace"></a>Анализ трассировки ETW

Затем откройте файл трассировки. Это можно сделать либо с помощью того же экземпляра PerfView, либо путем запуска нового экземпляра и установки текущего пути к папке в левом верхнем углу окна в расположение файла трассировки.

![Задание пути к папке в Perfview](media/perfview-set-path.png)

Затем выберите файл трассировки на левой панели и откройте его, выбрав пункт **Открыть** в контекстном меню.

> [!NOTE]
> По умолчанию PerfView выводит ZIP-архив. При открытии *trace.zip* автоматически распаковывает архив и открывает трассировку. Это можно пропустить, отменив флажок **ZIP** -файла во время сбора трассировки. Однако если вы планируете передавать и использовать трассировки на разных компьютерах, мы настоятельно рекомендуем снять флажок с **ZIP** -файла. Без этого параметра требуемые PDB для сборок Ngen не будут сопровождать трассировку, поэтому символы из сборок Ngen не будут разрешены на конечном компьютере. (Дополнительные сведения о PDB для сборок Ngen см. в [этой записи блога](https://devblogs.microsoft.com/devops/creating-ngen-pdbs-for-profiling-reports/) .)

Процесс PerfView может занять несколько минут и открыть трассировку. После открытия трассировки в ней появится список различных "представлений".

![Представление сводки трассировки PerfView](media/perfview-summary-view-events-selected.png)

Сначала мы будем использовать представление **Events** для получения диапазона времени задержки пользовательского интерфейса:

1. Откройте представление " **события** ", выбрав `Events` узел под трассировкой и выбрав пункт **Открыть** в контекстном меню.
2. Выберите " `Microsoft-VisualStudio/ExtensionUIUnresponsiveness` " на левой панели.
3. Нажмите клавишу ВВОД

Выбор применяется, и все `ExtensionUIUnresponsiveness` события отображаются в правой области.

![Выбор событий в представлении "события"](media/perfview-event-selection.png)

Каждая строка в правой области соответствует задержке пользовательского интерфейса. Событие включает значение "идентификатор задержки", которое должно соответствовать ИДЕНТИФИКАТОРу задержки в журнале действий из шага 6. Так как `ExtensionUIUnresponsiveness` срабатывает в конце задержки пользовательского интерфейса, метка времени события (примерно) отмечает время окончания задержки пользовательского интерфейса. Событие также содержит время задержки. Можно вычесть длительность из метки времени окончания, чтобы получить метку времени начала задержки пользовательского интерфейса.

![Вычисление диапазона времени задержки пользовательского интерфейса](media/ui-delay-time-range.png)

На предыдущем снимке экрана, например, метка времени события — 12 125,679, а длительность задержки — 6 143,085 (МС). Таким образом, выражение
* Задержка начала — 12 125,679-6 143,085 = 5 982,594.
* Диапазон времени задержки пользовательского интерфейса — от 5 982,594 до 12 125,679.

После получения диапазона времени можно закрыть представление " **события** " и открыть представление " **время потока" (с действиями стартстоп)** . Это представление особенно удобно, поскольку частое расширение, блокирующее поток пользовательского интерфейса, просто ожидает другие потоки или операцию, связанную с вводом-выводом. Таким же, представление **стека ЦП** , которое является вариантом "перейти" в большинстве случаев, может не записывать время, затрачиваемое потоком на блокировку, так как оно не использует ЦП в течение этого времени. **Стеки потоков времени** решают эту проблему, правильно отображая время блокировки.

![Время потока (с Стартстоп действиями) узел стеков в представлении сводки PerfView](media/perfview-thread-time-with-startstop-activities-stacks.png)

При открытии представления " **стеки времени открытия потока** " выберите процесс **devenv** , чтобы начать анализ.

![Представление "стеки времени потока" для анализа задержки пользовательского интерфейса](media/ui-delay-thread-time-stacks.png)

В представлении **потоковых стеков** в верхней левой части страницы можно задать диапазон времени для значений, вычисленных на предыдущем шаге, и нажать клавишу **Ввод** , чтобы настроить стеки на этот диапазон времени.

> [!NOTE]
> Определение потока пользовательского интерфейса (Startup) может быть нелогичным, если коллекция трассировки запускается после того, как Visual Studio уже открыта. Однако первые элементы в стеке потока пользовательского интерфейса (Startup), скорее всего, всегда являются файлами DLL операционной системы (*ntdll.dll* и *kernel32.dll*), за которыми следует `devenv!?` , а затем `msenv!?` . Эта последовательность может помочь определить поток пользовательского интерфейса.

 ![Определение потока запуска](media/ui-delay-startup-thread.png)

Кроме того, можно отфильтровать это представление, включив в него только стеки, содержащие модули из пакета.

* Задайте для **грауппатс** пустой текст, чтобы удалить все группирования, добавленные по умолчанию.
* Задайте **инкпатс** , чтобы включить часть имени сборки в дополнение к существующему фильтру процесса. В этом случае он должен быть **devenv; UIDelayR2**.

![Настройка Грауппас и Инкпас в представлении "стеки потоков времени"](media/perfview-tts-group-path-inc-path.png)

PerfView содержит подробные инструкции в меню " **Справка** ", которые можно использовать для выявления узких мест производительности в коде. Кроме того, следующие ссылки содержат дополнительные сведения о том, как использовать интерфейсы API потоков Visual Studio для оптимизации кода:

* [https://github.com/Microsoft/vs-threading/blob/master/doc/index.md](https://github.com/Microsoft/vs-threading/blob/master/doc/index.md)
* [https://github.com/Microsoft/vs-threading/blob/master/doc/cookbook_vs.md](https://github.com/Microsoft/vs-threading/blob/master/doc/cookbook_vs.md)

Вы также можете использовать новые статические анализаторы Visual Studio для расширений (пакет NuGet [здесь](https://www.nuget.org/packages/microsoft.visualstudio.sdk.analyzers)), содержащие рекомендации по созданию эффективных расширений. См. список [анализаторов VS SDK](https://github.com/Microsoft/VSSDK-Analyzers/blob/master/doc/index.md) и [анализаторов потоков](https://github.com/Microsoft/vs-threading/blob/master/doc/analyzers/index.md).

> [!NOTE]
> Если не удается устранить немедленную работу из-за зависимостей, управление которыми не осуществляется (например, если расширение должно вызывать синхронные службы VS в потоке пользовательского интерфейса), мы хотели бы узнать о нем. Если вы являетесь членом нашей партнерской программы Visual Studio, вы можете связаться с нами, отправив запрос в службу поддержки для разработчиков. В противном случае используйте инструмент "сообщить о проблеме", чтобы отправить отзыв и включить `"Extension UI Delay Notifications"` его в заголовок. Также добавьте подробное описание анализа.
