---
title: Шаблоны приложений для Visual Studio | Документация Майкрософт
description: Узнайте о различиях между окнами документов, окнами инструментов и немодальными диалогами, включая шаблоны использования окон для новых функций Visual Studio.
ms.custom: SEO-VS-2020
ms.date: 04/26/2017
ms.topic: conceptual
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
author: acangialosi
ms.author: anthc
manager: jmartens
ms.workload:
- vssdk
ms.openlocfilehash: 1d647a1dbd3bc6bf99f9803870c7b58ead358b41
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99892597"
---
# <a name="application-patterns-for-visual-studio"></a>Шаблоны приложений для Visual Studio
## <a name="window-interactions"></a><a name="BKMK_WindowInteractions"></a> Взаимодействие окон

### <a name="overview"></a>Обзор
В Visual Studio используются два основных типа окон: Редакторы документов и окна инструментов. Редко, но возможно, являются большими немодальными диалогами. Хотя все они немодальны в оболочке, их закономерности существенно отличаются. В этом разделе рассматривается различие между окнами документов, окнами инструментов и немодальными диалогами. Модальные шаблоны диалоговых окон рассматриваются в [диалоговых окнах](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs).

### <a name="comparing-window-usage-patterns"></a>Сравнение шаблонов использования окон
**Окна документов** почти всегда отображаются в контейнере документа. Это дает редактору документов «Центральный этап» для размещения вспомогательных окон инструментов.

**Окно инструментов** чаще всего отображается в виде отдельного, меньшего окна, свернутого к границе интегрированной среды разработки. Это может быть видимый, скрытый или автоматический скрытый. Однако иногда окна инструментов представлены в области документа путем отмены проверки свойства **окна или закрепления** окна. Это приводит к более широкому использованию, но также распространенному решению: при попытке интеграции в Visual Studio необходимо решить, должен ли компонент отображать окно инструментов или окно документа.

**Немодальные диалоговые окна** не рекомендуются в Visual Studio. Большинство немодальных диалоговых окон — это, по определению, плавающие окна инструментов, которые должны быть реализованы таким образом. Немодальные диалоговые окна разрешены в случаях, когда размер обычного окна инструментов, закрепленного на стороне оболочки, будет слишком ограничен. Они также разрешены в тех случаях, когда пользователь скорее всего переместит диалоговое окно на дополнительный монитор.

Подумайте о том, какой тип контейнера вам нужен. В таблице ниже приведены общие рекомендации по шаблону использования для разработки пользовательского интерфейса.

||Окно документа|Окно инструментов|Немодальное диалоговое окно|
|-|---------------------|-----------------|---------------------|
| **Позиция** | Всегда располагается в контейнере документа и не закрепляется вокруг границ интегрированной среды разработки. Его можно отключить, чтобы он переключаться отдельно от основной оболочки. | Обычно закреплены вокруг границ интегрированной среды разработки, но могут быть настроены для перемещения, автоматического скрытия (незакрепленных) или закрепления в документе.|Большое плавающее окно, отделенное от интегрированной среды разработки. |
| **Зафиксировать модель** | *Отложенная фиксация*<br /><br /> Чтобы сохранить данные в документе, пользователь должен выдать команду **файл &gt; сохранить**, **Сохранить как** или **сохранить все** . Окно документа содержит концепцию данных в нем "изменялся", а затем фиксируется в одной из команд Save. При закрытии окна документа все содержимое либо сохраняется на диске, либо теряется. | *Немедленное фиксация*<br /><br /> Нет модели сохранения. Для окон инструментов инспектора, которые помогают в редактировании файла, файл должен быть открыт в активном редакторе или конструкторе, а редактор или конструктор владеет сохранением. | *Отложенная или немедленное фиксация*<br /><br /> Чаще всего в большом немодальном диалоговом окне требуется действие для фиксации изменений и позволяет выполнить операцию отмены, которая откатывает все изменения, внесенные в сеанс диалогового окна.  Это отличает немодальное диалоговое окно от окна инструментов в том, что окна инструментов всегда имеют немедленную модель фиксации. |
| **Видимость** | *Открыть/создать (файл) и закрыть*<br /><br /> Открытие окон документов осуществляется путем открытия существующего документа или с помощью шаблона для создания нового документа. Команда "Открыть" отсутствует \<specific editor> . | *Скрыть и показать*<br /><br /> Окна инструментов с одним экземпляром можно скрыть или отобразить. Содержимое и состояния в окне инструментов сохраняются независимо от представления или скрыты. Окна инструментов с несколькими экземплярами можно закрывать и скрывать. Когда окно инструментов с несколькими экземплярами закрывается, содержимое и состояние в окне инструментов отбрасываются. | *Запуск из команды*<br /><br /> Диалоговые окна запускаются из команды, основанной на задачах. |
| **Экземпляры** | *Несколько экземпляров*<br /><br /> Можно одновременно открыть несколько редакторов и изменить различные файлы, в то время как некоторые редакторы также позволяют открывать один и тот же файл в нескольких редакторах (с помощью команды **Window &gt; New Window** ).<br /><br /> Один редактор может одновременно изменять один или несколько файлов (конструктор проектов). | *Один или несколько экземпляров*<br /><br /> Содержимое изменяется в соответствии с контекстом (как в обозревателе свойств) или принудительной отправки фокуса/контекста другим окнам (список задач, обозреватель решений).<br /><br /> Окна инструментов с одним экземпляром и с несколькими экземплярами должны быть связаны с активным окном документа, если нет особой причины, которой не является. | *Один экземпляр* |
| **Примеры** | **Текстовые редакторы**, например редактор кода<br /><br /> **Поверхности разработки**, например конструктор форм или поверхность моделирования<br /><br /> **Макеты элементов управления, аналогичные диалоговым окнам**, таким как конструктор манифестов | **Обозреватель решений** предоставляет решение и проекты, содержащиеся в решении<br /><br /> **Обозреватель сервера** предоставляет иерархическое представление серверов и подключений к данным, которые пользователь выбирает для открытия в окне. Открытие объекта из иерархии базы данных, например запроса, открывает окно документа и позволяет пользователю редактировать запрос.<br /><br /> В **обозревателе свойств** отображаются свойства объекта, выбранного либо в окне документа, либо в другом окне инструментов. Свойства представлены либо в иерархическом представлении сетки, либо в сложных элементах управления, похожих на диалог, и позволяют пользователю задавать значения этих свойств. | |

## <a name="tool-windows"></a><a name="BKMK_ToolWindows"></a> Окна инструментов

### <a name="overview"></a>Обзор
Окна инструментов поддерживают работу пользователя, которая происходит в окнах документов. Они могут использоваться для отображения иерархии, представляющей фундаментальный корневой объект, предоставляемый Visual Studio и с которыми можно работать.

При рассмотрении нового окна инструментов в интегрированной среде разработки, авторы должны:

- Используйте существующие окна инструментов, соответствующие задачам, и не создавайте новые с аналогичными функциями. Новые окна инструментов следует создавать только в том случае, если они предлагают существенно отличающееся средство или функциональность, которые не могут быть интегрированы в аналогичное окно, или путем включения существующего окна в центр сводных таблиц.

- При необходимости используйте стандартную панель команд в верхней части окна инструментов.

- Должны соответствовать шаблонам, уже присутствующим в других окнах инструментов для управления представлением и навигацией с помощью клавиатуры.

- Должны соответствовать представлениям элементов управления в других окнах инструментов.

- Сделать видимыми окна инструментов для конкретного документа по возможности, чтобы они отображались только при активации родительского документа.

- Убедитесь, что содержимое окна может перемещаться с помощью клавиатуры (клавиши со стрелками поддержки).

#### <a name="tool-window-states"></a>Состояния окна инструментов
Окна инструментов Visual Studio имеют различные состояния, некоторые из которых являются активируемыми пользователем (например, функция автоматического скрытия). Другие состояния, например автоматически видимые, позволяют окнам инструментов отображаться в правильном контексте и скрываться, когда это не требуется. Всего доступно пять состояний окон инструментов.

- **Закрепленные или закрепленные** окна инструментов могут быть присоединены к любой из четырех сторон области документа. Значок канцелярской кнопки отображается в заголовке окна инструментов. Окно инструментов может быть закреплено горизонтально или вертикально вдоль края оболочки и других окон инструментов, а также может быть связано с клавишей TAB.

- **Автоматическое скрытие** окон инструментов не закреплено. Окно может выпустить из анализа, а вкладка (с именем окна инструментов и его значком) — на границе области документа. Окно инструментов, когда пользователь наводит указатель мыши на вкладку.

- **Автоматические видимые** окна инструментов автоматически отображаются при запуске другого элемента пользовательского интерфейса, например редактора, или при получении фокуса.

- **Плавающие** окна инструментов наведите указатель за пределы интегрированной среды разработки. Это полезно для конфигураций с несколькими мониторами.

- Окна инструментов **документа с вкладками** можно закреплять в области документа. Это полезно для крупных окон инструментов, таких как обозреватель объектов, которым требуется больше ценных площадок, чем прикрепление к краям рамки.

![Состояния окна инструментов в Visual Studio](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702 — 01_ToolWindowStates")<br />Состояния окна инструментов в Visual Studio

#### <a name="single-instance-and-multi-instance"></a>Один экземпляр и несколько экземпляров
Окна инструментов являются одним экземпляром или несколькими экземплярами. Некоторые окна инструментов с одним экземпляром могут быть связаны с активным окном документа, в то время как окна инструментов с несколькими экземплярами могут не работать. Окна инструментов с несколькими экземплярами реагируют на команду **окна &gt; New Window** путем создания нового экземпляра окна. На следующем рисунке показано окно инструментов, которое включает команду New Window, если активен экземпляр окна:

![Окно инструментов, которое включает команду "новое окно" при активном экземпляре окна](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702 — 02_ToolWindowEnablingCommand")<br />Окно инструментов, которое включает команду "новое окно" при активном экземпляре окна

Окна инструментов с одним экземпляром можно скрывать или отображать, в то время как окна инструментов с несколькими экземплярами можно закрывать и скрывать. Все окна инструментов могут быть закрепленными, связанными с вкладками, плавающими или задаваться в виде дочернего окна интерфейса Multiple-Document (MDI) (аналогично окну документа). Все окна инструментов должны отвечать на соответствующие команды управления окнами в меню "окно":

![Команды управления окнами в меню окна Visual Studio](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702 — 03_WindowManagementControls")<br />Команды управления окнами в меню окна Visual Studio

#### <a name="document-specific-tool-windows"></a>Окна инструментов для конкретного документа
Некоторые окна инструментов предназначены для изменения в зависимости от конкретного типа документа. Эти Windows постоянно обновляются в соответствии с функциями активного окна документа в интегрированной среде разработки.

Примерами окон инструментов, содержимое которых изменяется в соответствии с выбранным редактором, являются панель элементов и структура документа. Эти окна отображают водяной знак, если в редакторе есть фокус, который не предоставляет контекст для окна.

#### <a name="navigable-list-tool-windows"></a>Окна инструментов списка с возможностью навигации
В некоторых окнах инструментов отображается список элементов навигации, с которыми может взаимодействовать пользователь. В этом типе окна всегда должна быть обратная связь для текущего элемента в списке, даже если окно неактивно. Список должен отвечать на команды **готонекстлокатион** и **готопревлокатион** , также изменяя текущий выбранный элемент в окне

Примерами окон инструментов со списками навигации являются обозреватель решений и окно Результаты поиска.

### <a name="tool-window-types"></a>Типы окон инструментов

#### <a name="common-tool-windows-and-their-functions"></a>Общие окна инструментов и их функции

**Окна иерархических инструментов**

| Окно инструментов | Компонент |
| --- | --- |
| Обозреватель решений | Иерархическое дерево, отображающее список документов, содержащихся в проектах, прочих файлах и элементах решения. Отображение элементов в проектах определяется пакетом, которому принадлежит тип проекта (например, на основе ссылок, на основе каталогов или в смешанном режиме). |
| Представление классов | Иерархическое дерево классов и различных элементов в рабочем наборе документов независимо от самих файлов. |
| Обозреватель серверов | Иерархическое дерево, в котором отображаются все серверы и подключения к данным в решении. |
| Структура документа | Иерархическая структура активного документа. |

**Окна инструментов сетки**

| Окно инструментов | Компонент |
| --- | --- |
| Свойства | Сетка, которая отображает список свойств для выбранного объекта, а также выбор значений для изменения этих свойств. |
| Список задач | Сетка, позволяющая пользователю создавать, изменять и удалять задачи и комментарии. |

**Окна инструментов содержимого**

| Окно инструментов | Компонент |
| --- | --- |
| Справка | Окно, позволяющее пользователям получать доступ к различным методам получения справки, от "практические указания" видео на форумах MSDN. |
| Динамическая справка | Окно инструментов, в котором отображаются ссылки на разделы справки, применимые к текущему выделению. |
| Обозреватель объектов | Набор фреймов с двумя столбцами со списком компонентов иерархических объектов в левой области, а также свойствами и методами объекта в правом столбце. |

**Окна диалоговых окон**

| Окно инструментов | Компонент |
| --- | --- |
| Поиск | Диалоговое окно, позволяющее пользователю находить или находить и заменять различные файлы в решении. |
| Расширенный поиск | Диалоговое окно, позволяющее пользователю находить или находить и заменять различные файлы в решении. |

**Другие окна инструментов**

::: moniker range="vs-2017"

| Окно инструментов | Компонент |
| --- | --- |
| Панель элементов | Окно инструментов, используемое для хранения элементов, которые будут удалены на поверхности разработки, предоставляя единообразный источник перетаскивания для всех конструкторов. |
| Начальная страница | Портал пользователя для Visual Studio с доступом к веб-каналам новостей для разработчиков, справке Visual Studio и последним проектам. Пользователи также могут создавать настраиваемые начальные страницы, копируя файл StartPage. XAML из каталога "Common7\IDE\StartPages \" файлы программ Visual Studio" в папку StartPage в каталоге документов Visual Studio, а затем либо редактируя код XAML вручную, либо открывая его в Visual Studio или другом редакторе кода. |

::: moniker-end

::: moniker range=">=vs-2019"

| Окно инструментов | Компонент |
| --- | --- |
| Панель элементов | Окно инструментов, используемое для хранения элементов, которые будут удалены на поверхности разработки, предоставляя единообразный источник перетаскивания для всех конструкторов. |

::: moniker-end

**Окна инструментов отладчика**

| Окно инструментов | Компонент |
| --- | --- |
| Автоматические ||
| Интерпретация ||
| Выходные данные | Окно вывода можно использовать всякий раз, когда у вас есть текстовые события или состояние для объявления. |
| Память ||
| Точки останова ||
| Запущен ||
| Документы ||
| Стек вызовов ||
| Локальные ||
| Должна ||
| Дизассемблированный код ||
| Регистры ||
| Потоки ||

## <a name="document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a> Соглашения редактора документов

### <a name="document-interactions"></a>Взаимодействие с документами
"Документ хорошо" — это самое крупное пространство в интегрированной среде разработки, в котором пользователь, как правило, имеет особое внимание для выполнения задач, помогая дополнительным окнам инструментов. Редакторы документов представляют фундаментальные единицы работы, которые пользователь открывает и сохраняет в Visual Studio. Они имеют строгое представление о выборе, привязанном к обозреватель решений или другим активным окнам иерархии. Пользователь должен иметь возможность указывать на одну из этих окон иерархии и определять, где находится документ, а также его связь с решением, проектом или другим корневым объектом, предоставленным пакетом Visual Studio.

Для редактирования документов требуется единообразное взаимодействие с пользователем. Чтобы разрешить пользователю сосредоточиться на задаче, а не на управлении окнами и поиске команд, выберите стратегию представления документов, которая наилучшим образом соответствует пользовательским задачам для изменения этого типа документа.

#### <a name="common-interactions-for-the-document-well"></a>Общие взаимодействия с контейнером документа

- Поддержка согласованной модели взаимодействия в общем **новом файле** и **открытых файловых** интерфейсах.

- Обновление связанных функций в связанных окнах и меню при открытии окна документа.

- Команды меню должны быть интегрированы в общие меню, такие как **Редактирование**, **Форматирование** и **Просмотр** меню. Если доступно значительное количество специализированных команд, можно создать новое меню. Это новое меню должно отображаться только в том случае, если документ имеет фокус.

- В верхней части редактора может быть размещена встроенная панель инструментов. Рекомендуется использовать отдельную панель инструментов, которая находится за пределами редактора.

- Всегда сохраняйте выбор в обозреватель решений или аналогичном окне активной иерархии.

- Двойной щелчок по документу в обозреватель решений должен выполнить то же действие, что и **открытая**.

- Если для типа документа можно использовать несколько редакторов, пользователь должен иметь возможность переопределить или сбросить действие по умолчанию для определенного типа документа, используя диалоговое окно **Открыть с** помощью, щелкнув правой кнопкой мыши файл и выбрав пункт **Открыть с помощью** в контекстном меню.

- Не создавайте мастер в контейнере документа.

### <a name="user-expectations-for-specific-document-types"></a>Ожидания пользователей для конкретных типов документов
Существует несколько различных основных типов редакторов документов, каждый из которых имеет набор взаимодействий, совместимых с другими пользователями того же типа.

- **Текстовый редактор:** редактор кода, файлы журналов

- **Область конструктора:** Конструктор форм WPF, Windows Forms

- **Редактор диалоговых окон:** Конструктор манифестов, свойства проекта

- **Конструктор моделей:** конструктор рабочих процессов, codemap, схема архитектуры, прогрессия

Также существует несколько типов, не являющихся редакторами, которые используют контейнер документа. Хотя они не изменяют сами документы, им нужно следовать стандартным действиям для окон документов.

- **Отчеты:** Отчет IntelliTrace, отчет Hyper-V, отчет профилировщика

- **Панель мониторинга:** Центр диагностики

#### <a name="text-based-editors"></a>Текстовые редакторы

- Документ участвует в модели вкладки предварительного просмотра, что позволяет предварительно просматривать документ, не открывая его.

- Структура документа может быть представлена в сопутствующем окне инструментов, например в структуре документа.

- IntelliSense (при необходимости) будет вести себя единообразно с другими редакторами кода.

- Всплывающие или вспомогательные элементы пользовательского интерфейса следуют похожим стилям и шаблонам для существующего аналогичного пользовательского интерфейса, например CodeLens.

- Сообщения о состоянии документа будут представлены в элементе управления информационной панели в верхней части документа или в строке состояния.

- Пользователь должен иметь возможность настраивать внешний вид шрифтов и цветов с помощью страницы **> параметров** на странице «Общие шрифты и цвета» либо в редакторе.

#### <a name="design-surfaces"></a>Поверхности проектирования

- Пустой конструктор должен иметь на поверхности водяной знак, указывающий, как начать работу.

- Механизмы переключения представлений будут следовать существующим шаблонам, таким как двойной щелчок для открытия редактора кода, или вкладок в окне документа, что позволяет взаимодействовать с обеими панелями.

- Добавление элементов в область конструктора должно осуществляться через панель элементов, если не требуется окно инструментов с высоким уровнем специфики.

- Элементы на поверхности будут соответствовать единообразной модели выбора.

- Встроенные панели инструментов содержат только команды для конкретного документа, а не обычные команды, такие как **Save**.

#### <a name="dialog-style-editors"></a>Редакторы диалоговых окон

- Макет элемента управления должен соответствовать обычным соглашениям о макетах диалогового окна.

- Вкладки в редакторе не должны совпадать с видом вкладок документа, они должны соответствовать одному из двух допустимых стилей внутренних вкладок.

- Пользователи должны иметь возможность взаимодействовать с элементами управления только с помощью клавиатуры; либо путем активации редактора и перехода через элементы управления, либо с помощью стандартных мнемоник.

- Конструктор должен использовать общую модель сохранения. На поверхности не должны размещаться общие кнопки сохранения и фиксации, хотя могут быть уместны другие кнопки.

#### <a name="model-designers"></a>Конструкторы моделей

- Пустой конструктор должен иметь на поверхности водяной знак, указывающий, как начать работу.

- Добавление элементов в область конструктора осуществляется с помощью панели элементов.

- Элементы на поверхности будут соответствовать единообразной модели выбора.

- Встроенные панели инструментов содержат только команды для конкретного документа, а не обычные команды, такие как **Save**.

- Условные обозначения могут отображаться на поверхности, на индикативе или в подложке.

- Пользователь должен иметь возможность настроить внешний вид шрифтов и цветов на странице « **инструменты > параметры** », на странице «Общие шрифты и цвета» или в той, которая относится к редактору.

#### <a name="reports"></a>Отчеты

- Отчеты обычно являются информационными и не участвуют в модели сохранения. Однако они могут включать взаимодействие, например ссылки на другие важные сведения или разделы, которые разворачиваются и сворачиваются.

- Большинство команд на поверхности должны быть гиперссылками, а не кнопками.

- Макет должен включать заголовок и следовать стандартным рекомендациям по макету отчета.

#### <a name="dashboards"></a>Панели мониторинга

- Панели мониторинга не имеют самой модели взаимодействия, но служат для предоставления разнообразных средств.

- Они не участвуют в модели сохранения.

- Пользователи должны иметь возможность взаимодействовать с элементами управления только с помощью клавиатуры, либо путем активации редактора и перехода через элементы управления, либо с помощью стандартных назначенных клавиш.

## <a name="dialogs"></a><a name="BKMK_Dialogs"></a> Диалоговые окна

### <a name="introduction"></a>Введение
Обычно диалоговые окна в Visual Studio поддерживают одну дискретную единицу работы пользователя, а затем отменяются.

Если вы определили, что вам понадобится диалоговое окно, у вас есть три варианта в порядке предпочтения:

1. Интегрируйте свои функции в одно из общих диалоговых окон в Visual Studio.

2. Создание собственного диалогового окна с помощью шаблона, найденного в существующем аналогичном диалоговом окне.

3. Создайте новое диалоговое окно, следуя рекомендациям по взаимодействию и макету.

В этом разделе описывается, как выбрать правильную схему диалогового окна в рабочих процессах Visual Studio и общие соглашения для разработки диалогового окна.

### <a name="themes"></a>Темы
В Visual Studio диалоговые окна имеют один из двух базовых стилей:

#### <a name="standard-unthemed"></a>Стандартный (нет)
Большинство диалоговых окон — это стандартные диалоговые окна служебной программы. Не пересоздавайте шаблон общих элементов управления или попытайтесь создать стилизованные кнопки или элементы управления. Элементы управления и оформление хрома соответствуют [стандартным правилам взаимодействия с рабочим столом Windows для диалоговых](/windows/desktop/uxguide/win-dialog-box)окон.

#### <a name="themed"></a>Тематические
Специальные диалоговые окна "подпись" могут быть темами. Диалоговые окна с темой имеют отдельный внешний вид, который также содержит некоторые специальные шаблоны взаимодействия, связанные с этим стилем. Тема диалогового окна, если оно соответствует следующим требованиям:

- Диалоговое окно представляет собой типичную процедуру, которая будет отображаться и использоваться часто или многими пользователями (например, диалоговое окно " **Создание проекта** ").

- Диалоговое окно содержит элементы фирменной символики продукта (например, диалоговое окно " **Параметры учетной записи** ").

- Диалоговое окно отображается в виде неотъемлемой части более крупного потока, включающего другие диалоговые окна (например, диалоговое окно **Добавление подключенной службы** ).

- Диалоговое окно является важной частью процесса, который играет стратегическую роль в повышении или различении версии продукта.

При создании диалогового окна с темой используйте соответствующие цвета среды и следуйте правильным шаблонам макета и взаимодействия. (См. раздел [макет для Visual Studio](../../extensibility/ux-guidelines/layout-for-visual-studio.md).)

### <a name="dialog-design"></a>Разработка диалогового окна
Хорошо спроектированные диалоговые окна позволяют принимать во внимание следующие элементы:

- Поддерживаемая пользовательская задача

- Стиль текста диалогового окна, язык и терминология

- Варианты управления и соглашения пользовательского интерфейса

- Визуальная спецификация макета и выравнивание элемента управления

- Доступ с клавиатуры

#### <a name="content-organization"></a>Организация содержимого
Рассмотрим различия между этими базовыми типами диалоговых окон:

- [Простые диалоговые окна](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs) представляют элементы управления в одном модальном окне. Презентация может включать варианты сложных шаблонов элементов управления, включая средство выбора полей или панель значков.

- [Многослойные диалоговые окна](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs) используются для того, чтобы максимально эффективно использовать экран, если один элемент пользовательского интерфейса состоит из нескольких групп элементов управления. Группирование диалогового окна осуществляется с помощью элементов управления вкладки, элементов управления "список навигации" или кнопок, чтобы пользователь мог выбрать, какую группировку следует просмотреть в любой момент.

- [Мастера](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards) полезны для направления пользователя с помощью логической последовательности шагов в направлении выполнения задачи. Ряд вариантов предлагается в последовательных панелях, а иногда — в различных рабочих процессах ("ветви"), которые зависят от выбора, сделанного на предыдущей панели.

#### <a name="simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a> Простые диалоговые окна
Простое диалоговое окно — это представление элементов управления в одном модальном окне. В эту презентацию могут входить разновидности сложных шаблонов элементов управления, например средство выбора полей. Для простых диалоговых окон следует использовать стандартный общий макет, а также любой конкретный макет, необходимый для группирования сложных элементов управления.

![>создания ключа строгого имени — это пример простого диалогового окна в Visual Studio.](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704 — 01_CreateStrongNameKey")<br />Создание ключа строгого имени — это пример простого диалогового окна в Visual Studio.

#### <a name="layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a> Многоуровневые диалоговые окна
Многоуровневые диалоговые окна включают вкладки, панели мониторинга и внедренные деревья. Они используются для максимизации реальных площадок при наличии нескольких групп элементов управления, предлагаемых в одном фрагменте пользовательского интерфейса. Группирования группируются таким образом, чтобы пользователь мог выбрать, какой из групп будет отображаться в любой момент времени.

В самом простом случае механизм переключения между группированиями является элементом управления "Вкладка". Доступно несколько вариантов. См. раздел Определение приоритетов и уровней для выбора наиболее подходящего стиля.

Диалоговое окно **&gt; Параметры инструментов** представляет собой пример многоуровневого диалогового окна, использующего внедренное дерево:

![Средства > параметры — это пример многоуровневого диалогового окна в Visual Studio.](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704 — 02_ToolsOptions")<br />Средства > параметры — это пример многоуровневого диалогового окна в Visual Studio.

#### <a name="wizards"></a><a name="BKMK_Wizards"></a> Мастера
Мастера полезны для направления пользователя с помощью логической последовательности шагов в завершении задачи. Ряд вариантов предлагается в последовательных панелях, и пользователь должен продолжить каждый шаг, прежде чем переходить к следующему. Когда доступны достаточные значения по умолчанию, кнопка **Готово** становится доступной.

 Модальные мастера используются для задач, которые:

- Содержит ветвление, где предлагаются разные пути в зависимости от выбора пользователя

- Содержат зависимости между шагами, где последующие шаги зависят от пользовательского ввода из предыдущих шагов.

- Достаточно сложно использовать пользовательский интерфейс для объяснения предлагаемых вариантов и возможных результатов на каждом шаге.

- Являются транзакционными, требует выполнения набора шагов целиком перед фиксацией изменений.

### <a name="common-conventions"></a>Распространенные соглашения
Чтобы обеспечить оптимальное проектирование и функциональность диалоговых окон, следуйте этим соглашениям по размеру диалогового окна, положению, стандартам, настройке и выравниванию, тексту пользовательского интерфейса, заголовкам окон, кнопкам управления и ключам доступа.

Рекомендации для конкретных макетов см. в разделе [макет для Visual Studio](../../extensibility/ux-guidelines/layout-for-visual-studio.md).

#### <a name="size"></a>Размер
Диалоговые окна должны соответствовать минимальному разрешению 1024x768 экрана, а размер исходного диалогового окна не должен превышать 900x700 пикселей. Размер диалоговых окон может изменяться, но это не обязательно.

Существует два рекомендации для диалоговых окон с изменяемыми размерами:

1. Этот минимальный размер определен для диалогового окна, которое будет оптимизироваться для набора элементов управления без обрезки, и настроить в соответствии с разумным ростом локализации.

2. Размер масштабируемого пользователя сохраняется из сеанса в сеанс. Например, если пользователь масштабирует диалоговое окно до 150%, при последующем запуске диалогового окна будет отображаться 150%.

#### <a name="position"></a>Положение
Диалоги должны отображаться в центре интегрированной среды разработки при первом запуске. Последнее расположение диалоговых окон без изменения размера не обязательно должно сохраняться, поэтому они будут отображаться по центру при последующих запусках.

Для диалоговых окон с изменяемым размером размер должен сохраняться при последующих запусках. Для изменяемых модальных диалоговых окон расположение не нужно сохранять. Отображение элементов, центрированных в интегрированной среде разработки, предотвращает возможность отображения диалогового окна в непредсказуемой или непригодной для использования позицией при изменении конфигурации отображения пользователя.

Для немодальных диалоговых окон, которые могут быть перемещены, необходимо сохранять местоположение пользователя при последующих запусках, так как диалоговое окно может часто использоваться в качестве неотъемлемой части большего рабочего процесса.

Когда диалоги должны порождать другие диалоговые окна, самое верхнее диалоговое окно должно находиться в каскаде вправо и вниз от родительского элемента, чтобы он был очевидным для пользователя, который перешел к новому месту.

#### <a name="modality"></a>Модальность
Модальное означает, что пользователям необходимо завершить или отменить диалоговое окно, прежде чем продолжить. Поскольку модальные диалоговые окна заблокировали взаимодействие пользователя с другими частями среды, поток задач функции должен использовать их как можно реже. Если требуется модальная операция, в Visual Studio доступно несколько общих диалоговых окон, в которые можно интегрировать функции. Если необходимо создать новое диалоговое окно, следуйте шаблону взаимодействия существующего диалогового окна с аналогичными функциями.

Когда пользователям необходимо выполнить два действия одновременно, например **найти** и **заменить** при написании нового кода, диалоговое окно должно быть немодальным, чтобы пользователь мог легко переключаться между ними. В Visual Studio обычно используются окна инструментов для связанной задачи, поддерживающей редактор.

#### <a name="control-configuration"></a>Конфигурация элемента управления
Должны соответствовать существующим конфигурациям элементов управления, которые выполняют те же задачи в Visual Studio.

#### <a name="title-bars"></a>Заголовки окна

- Текст в строке заголовка должен отражать имя команды, которая его запустила.

- В заголовках диалогового окна не следует использовать значок. В случаях, когда системе требуется одна, используйте эмблему Visual Studio.

- В диалоговых окнах не должно быть кнопок сворачивания и развернуть.

- Кнопки справки в заголовке окна не рекомендуются. Не добавляйте их в новые диалоговые окна. Когда они существуют, они должны запустить раздел справки, который концептуально важен для задачи.

  ![Спецификации рекомендаций для строк заголовка в диалоговых окнах Visual Studio](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704 — 03_TitleBarSpecs")<br />Спецификации рекомендаций для строк заголовка в диалоговых окнах Visual Studio

#### <a name="control-buttons"></a>Кнопки управления
Как правило, кнопки **ОК**, **Отмена** и **Справка** должны быть упорядочены по горизонтали в правом нижнем углу диалогового окна. Альтернативный вертикальный стек разрешен, если в нижней части диалогового окна есть несколько кнопок, которые приведут к визуальной путанице с помощью кнопок управления.

![Допустимые конфигурации для кнопок управления в диалоговых окнах Visual Studio](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704 — 04_ControlButtonConfig")<br />Допустимые конфигурации для кнопок управления в диалоговых окнах Visual Studio

Диалоговое окно должно содержать кнопку элемента управления по умолчанию. Чтобы определить наилучшую команду для использования по умолчанию, выберите один из следующих параметров (в порядке приоритета):

- Выберите наиболее безопасную и безопасную команду по умолчанию. Это означает выбор команды, которая, скорее всего, предотвратит потери данных и позволяет избежать непреднамеренного доступа к системе.

- Если потери и безопасность данных не являются факторами, выберите команду по умолчанию в зависимости от удобства. Включение наиболее вероятной команды в качестве значения по умолчанию позволит улучшить рабочий процесс пользователя, когда диалоговое окно поддерживает частые или повторяющиеся задачи.

Старайтесь не выбирать обратимое действие для команды по умолчанию. Если такая команда имеется, выберите более безопасную команду по умолчанию.

#### <a name="access-keys"></a>Ключи доступа
Не используйте клавиши доступа для кнопок **ОК**, **Отмена** и **Справка** . По умолчанию эти кнопки сопоставляются с сочетаниями клавиш.

| Имя кнопки | Сочетание клавиш |
| --- | --- |
| ОК | ВВОД |
| Отменить | ESC |
| Справка | F1 |

#### <a name="imagery"></a>Изображениях
Использование изображений с осторожностью в диалоговых окнах. Не используйте крупные значки в диалоговых окнах только для использования пространства. Используйте изображения, только если они являются важной частью передачи сообщения пользователю, например значки предупреждений или анимации состояния.

### <a name="prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a> Определение приоритетов и уровней

#### <a name="prioritizing-your-ui"></a>Определение приоритетов пользовательского интерфейса
Может потребоваться перенести определенные элементы пользовательского интерфейса в Forefront и поместить более расширенное поведение и параметры (включая маскировку команд) в диалоговые окна. Применяйте к программе Forefront часто используемые функции, освобождая место для нее и выполнив ее по умолчанию в пользовательском интерфейсе с помощью текстовой метки при отображении диалогового окна.

#### <a name="layering-your-ui"></a>Разслойировать пользовательский интерфейс
Если вы определили, что требуется диалоговое окно, но связанные функции, которые должны быть представлены пользователю, выходят за рамки того, что может быть отображено в простом диалоговом окне, необходимо разслойировать пользовательский интерфейс. Наиболее распространенными методами, используемыми в Visual Studio, являются вкладки и холлах или панели мониторинга. В некоторых случаях могут быть подходящими регионы, которые могут разворачиваться и сворачиваться. Как правило, адаптивный пользовательский интерфейс не рекомендуется в Visual Studio.

Существуют преимущества и недостатки различных методов многоуровневого интерфейса с помощью элементов управления, подобных клавишам Tab. Ознакомьтесь с приведенным ниже списком, чтобы выбрать способ применения к слоям, подходящий для вашей ситуации.

##### <a name="tabbing"></a>Переход по клавише TAB

| Механизм переключения | Преимущества и правильное использование | Недостатки и неуместное использование |
| --- | --- | --- |
| Элемент управления табуляции | Логически сгруппировать страницы диалогового окна в связанные наборы<br /><br />Полезен для менее чем пяти (или количества вкладок, которые помещаются в одной строке в диалоге) страниц связанных элементов управления в диалоговом окне<br /><br />Метки вкладок должны быть короткими: одно или два слова, которые могут легко определять содержимое.<br /><br />Обычный системный стиль диалогового окна<br /><br />Пример: **&gt; свойства элемента обозревателя файлов** | Создание описательных коротких меток может быть затруднено<br /><br />Обычно не масштабирует предыдущие пять вкладок в одном диалоговом окне<br /><br />Не подходит, если имеется слишком много вкладок для одной строки (используйте альтернативный метод слоев).<br /><br />Не расширяемый |
| Навигация по боковой панели | Простое переключение устройства, которое может разместить больше категорий, чем вкладки<br /><br />Плоский список категорий (без иерархии)<br /><br />возможности расширения.<br /><br />Пример. **Настройка... &gt; Добавить команду** | Не рекомендуется использовать горизонтальный пробел, если менее трех групп<br /><br />Задача может быть более подходящей для раскрывающегося списка |
| Элемент управления "Дерево" | Разрешает для неограниченных категорий<br /><br />Разрешает группирование и (или) иерархию категорий<br /><br />возможности расширения.<br /><br />Пример: **Сервис &gt; Параметры** | Сильно вложенные иерархии могут вызвать чрезмерную горизонтальную прокрутку<br /><br />Visual Studio имеет оверабунданце представлений в виде дерева |
| Мастер | Помогает при завершении задачи с помощью последовательного определения пользователя, основанного на задачах. Мастер представляет задачу высокого уровня, а отдельные панели представляют подзадачи, необходимые для выполнения общей задачи.<br /><br />Полезно, когда задача пересекает границы пользовательского интерфейса, как в случае, когда пользователю придется использовать несколько редакторов и окон инструментов для выполнения задачи<br /><br />Полезно, если задаче требуется ветвление<br /><br />Полезно, если задача содержит зависимости между шагами<br /><br />Полезно, когда несколько аналогичных задач с одной вилкой решения могут быть представлены в одном диалоговом окне для сокращения числа различных похожих диалоговых окон. | Не подходит для любой задачи, которая не требует последовательного рабочего процесса<br /><br />Пользователи могут стать перегруженным и запутанным мастером с слишком большим количеством шагов<br /><br />У мастеров есть ограниченные экранные пространства экрана |

##### <a name="hallways-or-dashboards"></a>Холлах или панели мониторинга
Холлах и панели мониторинга — это диалоговые окна или панели, которые служат в качестве пунктов запуска в другие диалоговые окна и окна. Хорошо спроектированный "коридора" сразу отображает только наиболее распространенные параметры, команды и параметры, позволяя пользователю легко выполнять распространенные задачи. Как и в реальном мире коридора предоставляет заталкивает для доступа к комнатам, за которыми они находящиеся, в этом случае менее распространенный пользовательский интерфейс собираются в отдельные "комнаты" (часто это другие диалоговые окна) связанных функций, к которым можно получить доступ из главного коридора.

Кроме того, Пользовательский интерфейс, предлагающий все доступные функции в одной коллекции, а не рефакторинг менее распространенных функций в отдельные расположения, представляет собой просто панель мониторинга.

![Концепция коридора для предоставления дополнительного пользовательского интерфейса в Outlook](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704 — 08_Hallway")<br />Концепция коридора для предоставления дополнительного пользовательского интерфейса в Outlook

##### <a name="adaptive-ui"></a>Адаптивный пользовательский интерфейс
Отображение или скрытие пользовательского интерфейса, основанного на использовании или самостоятельно предоставляемом пользователю, — еще один способ представления необходимого пользовательского интерфейса при скрытии других частей. Это не рекомендуется в Visual Studio, так как алгоритмы, позволяющие решить, когда следует отображать или скрывать пользовательский интерфейс, могут быть несложными, а правила для некоторых наборов вариантов всегда будут неправильными.

## <a name="projects"></a><a name="BKMK_Projects"></a> Макропроекты

### <a name="projects-in-the-solution-explorer"></a>Проекты в обозреватель решений
Большинство проектов классифицируются как ссылочные, основанные на каталогах или смешанные. Все три типа проектов поддерживаются одновременно в обозреватель решений. Корень взаимодействия с пользователем в работе с проектами происходит внутри этого окна. Несмотря на то, что разные узлы проекта являются типами ссылок, каталогов или типов в смешанном режиме, существует общий шаблон взаимодействия, который следует применить в качестве отправной точки перед преобщением в пользовательские шаблоны для конкретного проекта.

Проекты всегда должны:

- Поддержка возможности добавления папок проектов для организации содержимого проекта

- Поддержание единообразной модели для сохранения проекта

Проекты также должны поддерживать согласованные модели взаимодействия для:

- Удаление элементов проекта

- Сохранение документов

- Изменение свойств проекта

- Изменение проекта в альтернативном представлении

- Операции перетаскивания

### <a name="drag-and-drop-interaction-model"></a>Модель взаимодействия с перетаскиванием
Проекты обычно классифицируются как на основе ссылок (возможность сохранения только ссылок на элементы проекта в хранилище), на основе каталогов (возможность сохранения только элементов проекта, физически хранящихся в иерархии проекта) или смешанных (способных сохранять ссылки или физические элементы). Интегрированная среда разработки поддерживает все три типа проектов одновременно в пределах **Обозреватель решений**.

С точки зрения перетаскивания следующие характеристики должны применяться к каждому типу проекта в **Обозреватель решений**:

- **Проект на основе ссылок:** Ключевой момент заключается в том, что проект перемещается вокруг ссылки на элемент в хранилище. Если проект, основанный на ссылке, выступает в качестве источника для операции перемещения, он должен только удалить ссылку на элемент из проекта. Элемент не должен быть фактически удален с жесткого диска. Если проект на основе ссылки выступает в качестве целевого объекта для операции перемещения (или копирования), он должен добавить ссылку на исходный исходный элемент без создания закрытой копии элемента.

- **Проект на основе каталога:** С точки зрения перетаскивания, проект перемещается вокруг физического элемента, а не со ссылки. Если проект на основе каталога выступает в качестве источника для операции перемещения, он должен завершить удаление физического элемента с жесткого диска, а также его удаление из проекта. Если проект на основе каталога выступает в качестве целевого объекта для операции перемещения (или копирования), он должен создать копию исходного элемента в целевом расположении.

- **Проект смешанной цели:** С точки зрения перетаскивания, поведение этого типа проекта основано на характере переперетаскиваемого элемента (ссылка на элемент в хранилище или сам элемент). Правильное поведение для ссылок и физических элементов описано выше.

Если в **Обозреватель решений** был только один тип проекта, операции перетаскивания будут простыми. Поскольку каждая система проектов может определять собственное поведение при перетаскивании, необходимо следовать определенным правилам (на основе поведения перетаскивания проводника Windows), чтобы обеспечить предсказуемое взаимодействие с пользователем.

- Неизмененная операция перетаскивания в **Обозреватель решений** (если не удерживать клавиши CTRL и Shift) должна привести к операции перемещения.

- Операция перетаскивания также должна привести к операции перемещения.

- Операция перетаскивания должна приводить к операции копирования.

- Основанные на ссылках и смешанные системы проектов поддерживают понятие добавления ссылки (или ссылки) к исходному элементу. Если эти проекты являются целью операции перетаскивания (при удерживании **клавиши CTRL + SHIFT** ), это должно привести к добавлению ссылки на элемент, добавляемый в проект.

Не все операции перетаскивания являются разумными для разных сочетаний, основанных на ссылках, каталогов и смешанных проектах. В частности, это может привести к разрешению операции перемещения между исходным проектом на основе каталога и целевым проектом на основе ссылок, поскольку исходный проект на основе каталога должен удалить исходный элемент после завершения перемещения. Затем целевой проект на основе ссылок будет иметь ссылку на удаленный элемент.

Кроме того, в заблуждение, что можно разрешить операцию копирования между этими типами проектов, так как целевой проект на основе ссылок не должен создавать независимую копию исходного элемента. Аналогичным образом не следует использовать сочетание клавиш CTRL + SHIFT для целевого проекта на основе каталога, так как проект на основе каталога не может сохранять ссылки. В случаях, когда операция перетаскивания не поддерживается, интегрированная среда разработки должна запретить удаление и показать пользователю курсор без перетаскивания (показанный в таблице указателя ниже).

Чтобы правильно реализовать поведение перетаскивания, исходный проект перетаскивания должен передавать свою природу в целевой проект. (Например, является ли он ссылкой или на основе каталога?) Эти сведения обозначаются форматом буфера обмена, предлагаемым источником. В качестве источника операции перетаскивания (или копирования буфера обмена) проект должен предлагать `CF_VSREFPROJECTITEMS` или `CF_VSSTGPROJECTITEMS` соответственно, в зависимости от того, основан ли проект на ссылке или на основе каталога. Оба этих формата имеют одно и то же содержимое данных, аналогичное `CF_HDROP` формату Windows, за исключением того, что списки строк, а не имена файлов, являются двойным `NULL` прерванным списком `Projref` строк (как возвращаемое `IVsSolution::GetProjrefOfItem` или `::GetProjrefOfProject` соответственно).

В качестве целевого объекта операции DROP (или вставки в буфер обмена) проект должен принимать `CF_VSREFPROJECTITEMS` и, и `CF_VSSTGPROJECTITEMS` , хотя точная обработка операции перетаскивания зависит от природы целевого проекта и исходного проекта. Исходный проект объявляет свою природу, если он предлагает `CF_VSREFPROJECTITEMS` или `CF_VSSTGPROJECTITEMS` . Цель перетаскивания понимает свою собственную природу и, таким образом, имеет достаточно информации, чтобы принимать решения о том, следует ли выполнять перемещение, копирование или связь. Пользователь также изменяет, какую операцию перетаскивания следует выполнять нажатием клавиш CTRL, Shift или клавиш CTRL и Shift. Важно, чтобы цель перетаскивания правильно указывала, какая операция будет выполнена заранее в своих `DragEnter` `DragOver` методах и. **Обозреватель решений** автоматически знает, является ли исходный проект и целевой проект одним и тем же проектом.

В частности, перетаскивание элементов проекта между экземплярами Visual Studio (например, от одного экземпляра devenv.exe к другому) не поддерживается. **Обозреватель решений** также отключается напрямую.

Пользователь всегда должен иметь возможность определить результат операции перетаскивания, выбрав элемент, перетащив его в целевое расположение и просматривая, какие из следующих указателей мыши появляются перед удалением элемента:

| Указатель мыши | Get-Help | Описание |
| :---: | --- | --- |
| ![Значок мыши "Не бросать"](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706 — 01_MouseNoDrop") | Без перетаскивания | Невозможно удалить элемент в указанное расположение. |
| ![Значок мыши "Копировать"](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706 — 02_MouseCopy") | Копировать | Элемент будет скопирован в целевое расположение. |
| ![Значок мыши "Переместить"](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706 — 03_MouseMove") | Переместить | Элемент будет перемещен в целевое расположение. |
| ![Значок мыши "Добавить ссылку" ](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706 — 04_MouseAddRef") | Добавление ссылки | Ссылка на выбранный элемент будет добавлена в целевое расположение. |

#### <a name="reference-based-projects"></a>Проекты на основе ссылок
 В следующей таблице перечислены операции перетаскивания (а также вырезание, копирование и вставка), которые должны выполняться на основе природы исходного элемента и клавиш-модификаторов, нажатых для целевых проектов на основе ссылок.

| Модификатор | Категория | Исходный элемент: ссылка или ссылка | Исходный элемент: физический элемент или файловая система ( `CF_HDROP` ) |
| --- | --- | --- | --- |
| Без модификатора | Действие | Переместить | Ссылка |
| Без модификатора | Целевой объект | Добавляет ссылку на исходный элемент | Добавляет ссылку на исходный элемент |
| Без модификатора | Источник | Удаляет ссылку на исходный элемент | Оставляет исходный элемент |
| Без модификатора | Результат | `DROPEFFECT_MOVE` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище | `DROPEFFECT_LINK` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище |
| Shift + перетаскивание | Действие | Переместить | Без перетаскивания |
| Shift + перетаскивание | Целевой объект | Добавляет ссылку на исходный элемент | Без перетаскивания |
| Shift + перетаскивание | Источник | Удаляет ссылку на исходный элемент | Без перетаскивания |
| Shift + перетаскивание | Результат | `DROPEFFECT_MOVE` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище | Без перетаскивания |
| Ctrl + перетаскивание | Действие | Копировать | Без перетаскивания |
| Ctrl + перетаскивание | Целевой объект | Добавляет ссылку на исходный элемент | Без перетаскивания |
| Ctrl + перетаскивание | Источник | Оставляет ссылку на исходный элемент | Без перетаскивания |
| Ctrl + перетаскивание | Результат | `DROPEFFECT_COPY` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище | Без перетаскивания |
| Ctrl + Shift + перетаскивание | Действие | Ссылка | Ссылка |
| Ctrl + Shift + перетаскивание | Целевой объект | Добавляет ссылку на исходный элемент | Добавляет ссылку на исходный элемент |
| Ctrl + Shift + перетаскивание | Источник | Оставляет ссылку на исходный элемент | Оставляет исходный элемент |
| Ctrl + Shift + перетаскивание | Результат | `DROPEFFECT_LINK` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище | `DROPEFFECT_LINK` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище |
| Ctrl + Shift + перетаскивание | Примечание | То же, что и при перетаскивании ярлыков в проводнике Windows. ||
| Вырезать/вставить | Действие | Переместить | Ссылка |
| Вырезать/вставить | Целевой объект | Добавляет ссылку на исходный элемент | Добавляет ссылку на исходный элемент |
| Вырезать/вставить | Источник | Оставляет ссылку на исходный элемент|Оставляет исходный элемент |
| Вырезать/вставить | Результат | Элемент остается в исходном расположении в хранилище | Элемент остается в исходном расположении в хранилище |
| Копирование и вставка | Действие | Копировать | Ссылка |
| Копирование и вставка | Источник | Добавляет ссылку на исходный элемент | Добавляет ссылку на исходный элемент |
| Копирование и вставка | Результат | Оставляет ссылку на исходный элемент | Оставляет исходный элемент |
| Копирование и вставка | Действие | Элемент остается в исходном расположении в хранилище | Элемент остается в исходном расположении в хранилище |

#### <a name="directory-based-projects"></a>Проекты на основе каталогов
В следующей таблице перечислены операции перетаскивания (а также вырезание, копирование и вставка), которые должны выполняться на основе природы исходного элемента и клавиш-модификаторов, которые были нажаты для целевых проектов на основе каталога.

| Модификатор | Категория | Исходный элемент: ссылка или ссылка | Исходный элемент: физический элемент или файловая система ( `CF_HDROP` ) |
|-----------------|----------| - | - |
| Без модификатора | Действие | Переместить | Переместить |
| Без модификатора | Целевой объект | Копирует элемент в целевое расположение | Копирует элемент в целевое расположение |
| Без модификатора | Источник | Удаляет ссылку на исходный элемент | Удаляет ссылку на исходный элемент |
| Shift + перетаскивание | Действие | Переместить | Переместить |
| Shift + перетаскивание | Целевой объект | Копирует элемент в целевое расположение | Копирует элемент в целевое расположение |
| Shift + перетаскивание | Источник | Удаляет ссылку на исходный элемент | Удаляет элемент из исходного расположения |
| Shift + перетаскивание | Результат | `DROPEFFECT_MOVE` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище | `DROPEFFECT_MOVE` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище |
| Ctrl + перетаскивание | Действие | Копировать | Копировать |
| Ctrl + перетаскивание | Целевой объект | Копирует элемент в целевое расположение | Копирует элемент в целевое расположение |
| Ctrl + перетаскивание | Источник | Оставляет ссылку на исходный элемент | Оставляет ссылку на исходный элемент |
| Ctrl + перетаскивание | Результат | `DROPEFFECT_COPY` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище | `DROPEFFECT_COPY` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище |
| Ctrl + Shift + перетаскивание | | Без перетаскивания | Без перетаскивания |
| Вырезать/вставить | Действие | Переместить | Переместить |
| Вырезать/вставить | Целевой объект | Копирует элемент в целевое расположение | Копирует элемент в целевое расположение |
| Вырезать/вставить | Источник | Удаляет ссылку на исходный элемент | Удаляет элемент из исходного расположения |
| Вырезать/вставить | Результат | Элемент остается в исходном расположении в хранилище | Элемент удален из исходного расположения в хранилище |
| Копирование и вставка | Действие | Копировать | Копировать |
| Копирование и вставка | Целевой объект | Добавляет ссылку на исходный элемент | Копирует элемент в целевое расположение |
| Копирование и вставка | Источник | Оставляет исходный элемент | Оставляет исходный элемент |
| Копирование и вставка | Результат | Элемент остается в исходном расположении в хранилище | Элемент остается в исходном расположении хранилища |

#### <a name="mixed-target-projects"></a>Проекты смешанных целевых объектов
В следующей таблице перечислены операции перетаскивания (а также вырезание, копирование и вставка), которые должны выполняться на основе природы исходного элемента и клавиш-модификаторов, нажатных для проектов с смешанными целевыми версиями:

| Модификатор | Категория | Исходный элемент: ссылка или ссылка | Исходный элемент: физический элемент или файловая система ( `CF_HDROP` ) |
| --- | --- | --- | --- |
| Без модификатора | Действие | Переместить | Переместить |
| Без модификатора | Целевой объект | Добавляет ссылку на исходный элемент | Копирует элемент в целевое расположение |
| Без модификатора | Источник | Удаляет ссылку на исходный элемент | Удаляет ссылку на исходный элемент |
| Без модификатора | Результат | `DROPEFFECT_ MOVE` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище | `DROPEFFECT_ MOVE` возвращается как действие из `::Drop` , и элемент удаляется из исходного расположения в хранилище |
| Shift + перетаскивание | Действие | Переместить | Переместить |
| Shift + перетаскивание | Целевой объект | Добавляет ссылку на исходный элемент | Копирует элемент в целевое расположение |
| Shift + перетаскивание | Источник | Удаляет ссылку на исходный элемент | Удаляет элемент из исходного расположения |
| Shift + перетаскивание | Результат | `DROPEFFECT_ MOVE` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище | `DROPEFFECT_ MOVE` возвращается как действие из `::Drop` , и элемент удаляется из исходного расположения в хранилище |
| Ctrl + перетаскивание | Действие | Копировать | Копировать |
| Ctrl + перетаскивание | Целевой объект | Добавляет ссылку на исходный элемент | Копирует элемент в целевое расположение |
| Ctrl + перетаскивание | Источник | Оставляет ссылку на исходный элемент | Оставляет исходный элемент |
| Ctrl + перетаскивание | Результат | `DROPEFFECT_ COPY` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище | `DROPEFFECT_ COPY` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище |
| Ctrl + Shift + перетаскивание | Действие | Ссылка | Ссылка |
| Ctrl + Shift + перетаскивание | Целевой объект | Добавляет ссылку на исходный элемент | Добавляет ссылку на исходный элемент источника |
| Ctrl + Shift + перетаскивание | Источник | Оставляет ссылку на исходный элемент | Оставляет исходный элемент |
| Ctrl + Shift + перетаскивание | Результат | `DROPEFFECT_ LINK` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище | `DROPEFFECT_ LINK` возвращается как действие из `::Drop` , и элемент остается в исходном расположении в хранилище |
| Вырезать/вставить | Действие | Переместить | Переместить |
| Вырезать/вставить | Целевой объект | Копирует элемент в целевое расположение | Копирует элемент в целевое расположение |
| Вырезать/вставить | Источник | Удаляет ссылку на исходный элемент | Удаляет элемент из исходного расположения |
| Вырезать/вставить | Результат | Элемент остается в исходном расположении в хранилище | Элемент удален из исходного расположения в хранилище |
| Копирование и вставка | Действие | Копировать | Копировать |
| Копирование и вставка | Целевой объект | Добавляет ссылку на исходный элемент | Копирует элемент в целевое расположение |
| Копирование и вставка | Источник | Оставляет исходный элемент | Оставляет исходный элемент |
| Копирование и вставка | Результат | Элемент остается в исходном расположении в хранилище | Элемент остается в исходном расположении в хранилище |

Эти сведения следует принимать во внимание при реализации перетаскивания в **Обозреватель решений**:

- Разработка для нескольких сценариев выбора.

- Имена файлов (полный путь) должны быть уникальными в пределах целевого проекта, или инструкция DROP не должна быть разрешена.

- Имена папок должны быть уникальными (без учета регистра) на уровне, на котором они удаляются.

- Существуют различия в поведении файлов, открытых или закрытых во время перетаскивания (не упоминалось в сценариях выше).

- Файлы верхнего уровня ведут себя немного иначе, чем файлы в папках.

Еще одна ошибка, о которой следует помнить, заключается в том, как обрабатывать операции перемещения для элементов, имеющих открытые конструкторы или редакторы. Ожидаемое поведение выглядит следующим образом (это применимо ко всем типам проектов):

1. Если в открытом редакторе или конструкторе нет несохраненных изменений, окно редактора или конструктора должно быть закрыто без вмешательства пользователя.

2. Если в открытом редакторе или конструкторе имеются несохраненные изменения, то источник перетаскивания должен ждать завершения операции перетаскивания, а затем попросить пользователя сохранить незафиксированные изменения в открытых документах перед закрытием окна с запросом следующего вида:

    ```
    ==========================================================
         One or more open documents have unsaved changes.
    Do you want to save uncommitted changes before proceeding?
                      [Yes]  [No]  [Cancel]
    ==========================================================
    ```

Это дает пользователю возможность сохранить выполняемую работу до того, как целевой объект выполнит свои копии. Добавлен новый метод `IVsHierarchyDropDataSource2::OnBeforeDropNotify` , позволяющий реализовать эту обработку.

Целевой объект скопирует состояние элемента в том виде, в котором оно находится в хранилище (не включая несохраненные изменения в редакторе, если пользователь выбрал значение **нет**). После того как целевой объект завершит копирование (в `IVsHierarchyDropDataSource::Drop` ), источнику будет предоставлена возможность завершить часть удаления операции перемещения (в `IVsHierarchyDropDataSource::OnDropNotify` ).

Все редакторы с несохраненными изменениями должны оставаться открытыми. Для этих документов с несохраненными изменениями это означает, что часть копирования операции перемещения будет выполнена, но часть удаления будет прервана. В сценарии множественного выбора, когда пользователь выбирает **нет**, эти документы с несохраненными изменениями не следует закрывать или удалять, но без несохраненных изменений они должны быть закрыты и удалены.
