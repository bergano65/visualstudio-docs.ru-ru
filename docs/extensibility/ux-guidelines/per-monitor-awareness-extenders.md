---
title: Поддержка поддержки по каждому монитору для расширений Visual Studio
titleSuffix: ''
description: Узнайте о новой поддержке расширителя для каждого монитора, доступной в Visual Studio 2019.
ms.date: 04/10/2019
helpviewer_keywords:
- Visual Studio, PMA, per-monitor-awareness, extenders, Windows Forms
- Per-Monitor Awareness support for extenders
author: rub8n
ms.author: rurios
manager: anthc
monikerRange: vs-2019
ms.topic: conceptual
dev_langs:
- CSharp
- CPP
ms.openlocfilehash: 09ec5d82251fa4598096fca8a59c9a1fd29e3f27
ms.sourcegitcommit: b83fefa8177c5554cbe2c59c4d102cbc534f7cc6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2019
ms.locfileid: "69585367"
---
# <a name="per-monitor-awareness-support-for-visual-studio-extenders"></a>Поддержка поддержки по каждому монитору для расширений Visual Studio

В версиях, предшествующих Visual Studio 2019, для контекста осведомленности о DPI задано значение «система», а не отслеживание DPI для каждого монитора (ПМА). Выполнение в службе "осведомленность о системе" привело к снижению производительности визуального элемента (например, размытые шрифты или значки), когда Visual Studio пришлось отобразить на мониторах с разными коэффициентами масштабирования или удаленно на компьютерах с разными конфигурациями отображения (например, разными Масштабирование Windows).

Контекст, осведомленный о DPI в Visual Studio 2019, задается как ПМА, когда среда поддерживает ее, позволяя Visual Studio визуализироваться в соответствии с конфигурацией отображения, в которой она размещена, а не отдельной системной конфигурацией. В конечном итоге перейдете в пользовательский интерфейс Always для контактных областей, поддерживающих режим ПМА.

Дополнительные сведения о терминах и общем сценарии, рассмотренных в этом документе, см. в документации по [разработке приложений для настольных компьютеров с высоким разрешением в Windows](/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows) .

## <a name="quickstart"></a>Быстрый старт

- Убедитесь, что Visual Studio работает в режиме ПМА (см. раздел **Включение ПМА**).

- Проверьте правильность работы расширения в наборе распространенных сценариев (см. раздел **тестирование расширений для ПМА проблем**).

- При обнаружении проблем можно использовать стратегии и рекомендации, описанные в этом документе, для диагностики и устранения этих проблем. Кроме того, необходимо добавить новый пакет NuGet [Microsoft. VisualStudio. дпиаваренесс](https://www.nuget.org/packages/Microsoft.VisualStudio.DpiAwareness/) в проект для доступа к необходимым API.

## <a name="enable-pma"></a>Включить ПМА

Чтобы включить ПМА в Visual Studio, необходимо соблюдать следующие требования.

- Обновление Windows 10 от апреля 2018 (v1803, RS4) или более поздней версии
- .NET Framework 4,8 RTM или более поздняя версия
- Visual Studio 2019 с включенным параметром ["оптимизировать отрисовку для экранов с различной плотностью пикселей"](../../ide/reference/general-environment-options-dialog-box.md)

После соблюдения этих требований Visual Studio автоматически включает режим ПМА в процессе.

> [!NOTE]
> Windows Formsное содержимое в Visual Studio (например, обозреватель свойств) поддерживает ПМА только при наличии Visual Studio 2019 версии 16,1 или более поздней.

## <a name="test-your-extensions-for-pma-issues"></a>Тестирование расширений на наличие проблем ПМА

Visual Studio официально поддерживает платформы интерфейса WPF, Windows Forms, Win32 и HTML/JS. Когда Visual Studio переходит в режим ПМА, каждый стек пользовательского интерфейса ведет себя по-разному. Поэтому, независимо от платформы пользовательского интерфейса, рекомендуется выполнить тестовый проход, чтобы обеспечить соответствие всех элементов пользовательского интерфейса режиму ПМА.

Рекомендуется проверить следующие распространенные сценарии.

- Изменение коэффициента масштабирования для одной среды мониторинга во время выполнения приложения.

  Этот сценарий помогает проверить, что пользовательский интерфейс отвечает на изменение динамического DPI в Windows.

- Закрепление и Отстыковка ноутбука, где для подключенного монитора задан первичный монитор, а для подключенного монитора используется другой коэффициент масштабирования, чем у ноутбука во время работы приложения.

  Этот сценарий помогает проверить, что пользовательский интерфейс отвечает на изменение отображаемого DPI, а также на обработку динамически добавляемых или удаленных дисплеев.

- Наличие нескольких мониторов с разными коэффициентами масштабирования и перемещение приложения между ними.

  Этот сценарий помогает проверить, что пользовательский интерфейс отвечает на изменение отображаемого DPI.
    
- Удаленное взаимодействие с компьютером, если на локальных и удаленных компьютерах установлены разные коэффициенты масштабирования для основного монитора.

  Этот сценарий помогает проверить, что пользовательский интерфейс отвечает на изменение динамического DPI в Windows.

Хороший предварительный тест того, может ли пользовательский интерфейс столкнуться с проблемами, заключается в том, использует ли код классы *Microsoft. VisualStudio. Utilities. dpi. дпихелпер*, *Microsoft. VisualStudio. платформуи. дпихелпер*или *VsUI:: кдпихелпер* . Эти старые классы Дпихелпер поддерживают только осведомленность о DPI системы и не всегда работают правильно, если процесс ПМА.

Типичное использование этих Дпихелперс будет выглядеть следующим образом:

```cs
Point screenTopRight = logicalBounds.TopRight.LogicalToDeviceUnits();

POINT screenIntTopRight = new POINT
{
    x = (int)screenTopRIght.X,
    y = (int)screenTopRIght.Y
}

// Declared via P/Invoke
IntPtr monitor = MonitorFromPoint(screenIntTopRight, MONITOR_DEFAULTTONEARST);
```

В предыдущем примере прямоугольник, представляющий логические границы окна, преобразуется в единицы устройства, чтобы его можно было передать в собственный метод Мониторфромпоинт, который ждет координаты устройства, чтобы вернуть точный указатель монитора.

### <a name="classes-of-issues"></a>Классы проблем
Если для Visual Studio включен режим ПМА, Пользовательский интерфейс может реплицировать проблемы несколькими распространенными способами. В большинстве случаев эти проблемы могут возникать в любой из поддерживаемых платформ пользовательского интерфейса Visual Studio. Кроме того, эти проблемы также могут возникать, когда часть пользовательского интерфейса размещается в сценариях масштабирования DPI в смешанном режиме (Дополнительные сведения см. в [документации](/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows) по Windows). 

#### <a name="win32-window-creation"></a>Создание окна Win32
При создании Windows с помощью CreateWindow () или CreateWindowEx () обычно создается окно с координатами (0, 0) (верхний или левый угол основного дисплея), а затем перемещается в конечную точку. Однако это может привести к тому, что окно активирует сообщение об изменении DPI или событие, которое может вызывать другие сообщения или события пользовательского интерфейса и в конечном итоге привести к нежелательному поведению или подготовке к просмотру.

#### <a name="wpf-element-placement"></a>Размещение элементов WPF
При перемещении элементов WPF с помощью старого элемента Microsoft. VisualStudio. Utilities. dpi. Дпихелпер координаты верхнего левого угла могут не рассчитываться правильно, если элементы находятся на непервичном DPI.

#### <a name="serialization-of-ui-element-sizes-or-positions"></a>Сериализация размеров или позиций элементов пользовательского интерфейса
Если размер или положение пользовательского интерфейса (если оно сохранено как единицы устройства) восстанавливается в контексте DPI, отличном от того, на котором оно было сохранено, то оно будет размещено и имеет неправильный размер. Это происходит потому, что единицы устройства имеют встроенную связь DPI.

#### <a name="incorrect-scaling"></a>Неправильное масштабирование
Элементы пользовательского интерфейса, созданные на основном уровне DPI, будут правильно масштабироваться, однако при перемещении на дисплей с разными DPI они не масштабируются и их содержимое слишком велико или слишком мало.

#### <a name="incorrect-bounding"></a>Неправильное ограничение
Точно так же, как и при масштабировании, элементы пользовательского интерфейса правильно рассчитывают свои границы в основном контексте DPI, однако при перемещении в неосновное значение DPI они не будут правильно рассчитывать новые границы. Таким образом, окно содержимого слишком мало или слишком велико по сравнению с пользовательским интерфейсом размещения, что приводит к пустому пространству или отсечению.

#### <a name="drag--drop"></a>Перетаскивание & перетаскиванием
В сценариях в смешанном режиме DPI (например, при отрисовке различных элементов пользовательского интерфейса в разных режимах определения DPI) координаты перетаскивания могут быть неправильными, что приводит к неправильной отсчету конечной точки сброса.

#### <a name="out-of-process-ui"></a>Пользовательский интерфейс вне процесса
Некоторый пользовательский интерфейс создается вне процесса, и если создание внешнего процесса выполняется в режиме, отличном от DPI в Visual Studio, это может привести к любой из предыдущих проблем отрисовки.

#### <a name="windows-forms-controls-images-or-layouts-rendered-incorrectly"></a>Неправильное отображение Windows Forms элементов управления, изображений или макетов
Не все Windows Forms содержимого поддерживают режим ПМА. В результате может отобразиться ошибка отрисовки с неправильными макетами или масштабированием. Возможным решением в этом случае является явное отображение Windows Forms содержимого в "Дпиаваренессконтекст", поддерживающем управление системой (см. статью принудительное выполнение [элемента управления в определенном дпиаваренессконтекст](#force-a-control-into-a-specific-dpiawarenesscontext)).

#### <a name="windows-forms-controls-or-windows-not-displaying"></a>Неотображаемые элементы управления Windows Forms или Windows
Одной из основных причин этой проблемы является то, что разработчики пытаются изменить родительский элемент управления или окна с помощью одного Дпиаваренессконтекст к окну с другим Дпиаваренессконтекст.

На следующих изображениях показаны текущие ограничения операционной системы Windows **по умолчанию** в родительских окнах:

![Снимок экрана с правильным поведением родительского объекта](media/PMA-parenting-behavior.PNG)

> [!Note]
> Это поведение можно изменить, задав поведение размещения потока (см. [Dpi_Hosting_Behavior enumeration](/windows/desktop/api/windef/ne-windef-dpi_hosting_behavior)).

В результате, если установить связь «родители-потомки» между неподдерживаемыми режимами, она завершится ошибкой, а элемент управления или окно может не отображаться должным образом.

### <a name="diagnose-issues"></a>Диагностика проблем

При выявлении проблем, связанных с ПМА, необходимо учитывать множество факторов. 

- Требуются ли в пользовательском интерфейсе или API значения логического или устройства?
    - В пользовательском интерфейсе WPF и интерфейсах API обычно используются логические значения (но не всегда).
    - ИНТЕРФЕЙС Win32 и интерфейсы API обычно используют значения устройств

- Где берутся значения?
    - При получении значений из другого пользовательского интерфейса или API передается устройство или логические значения.
    - Если при получении значений из нескольких источников все они используют или предполагают использование одних и тех же типов значений или преобразования должны быть смешанными и сопоставленными?

- Используются ли константы пользовательского интерфейса и в каких формах?

- Находится ли поток в правильном контексте DPI для получаемых значений?

  Изменения, позволяющие разрешать размещение смешанных точек на дюйм, обычно должны содержать пути кода в правильном контексте, однако работа, выполняемая за пределами основного цикла сообщений или потока событий, может выполняться в неправильном контексте DPI.

- Являются ли значения границами контекста между DPI?

  Перетаскивание & перетаскиванием является распространенной ситуацией, в которой координаты могут пересекать контексты DPI. Окно пытается выполнить нужное действие, но в некоторых случаях может потребоваться выполнить преобразование в пользовательском интерфейсе узла, чтобы обеспечить соответствие границ контекста.

### <a name="pma-nuget-package"></a>Пакет NuGet ПМА
Новые библиотеки Дпиаварнесс можно найти в пакете NuGet [Microsoft. VisualStudio. дпиаваренесс](https://www.nuget.org/packages/Microsoft.VisualStudio.DpiAwareness/) .

### <a name="recommended-tools"></a>Рекомендуемые средства
Следующие средства могут помочь в отладке проблем, связанных с ПМА, в некоторых различных стеках пользовательского интерфейса, поддерживаемых Visual Studio.

#### <a name="snoop"></a>Слежка
Слежка — это средство отладки XAML, которое обладает некоторыми дополнительными функциональными возможностями, которые не имеют встроенных средств Visual Studio XAML. Кроме того, слежка не нуждается в активной отладке Visual Studio, чтобы иметь возможность просматривать и настраивать пользовательский интерфейс WPF. Два основных способа, с помощью которых слежка может оказаться полезным для диагностики проблем ПМА, — проверка логических координат размещения или границ размера, а для проверки пользовательского интерфейса — правого DPI.
 
#### <a name="visual-studio-xaml-tools"></a>Средства Visual Studio XAML
Как и слежка, средства XAML в Visual Studio могут помочь в диагностике проблем ПМА. После обнаружения вероятного виновника можно установить точки останова и использовать активное окно визуального дерева, а также окна отладки для проверки границ пользовательского интерфейса и текущего DPI.

## <a name="strategies-for-fixing-pma-issues"></a>Стратегии устранения проблем ПМА

### <a name="replace-dpihelper-calls"></a>Заменить вызовы Дпихелпер

В большинстве случаев устранение проблем пользовательского интерфейса в режиме ПМА сводится к замене вызовов в управляемом коде старым классам *Microsoft. VisualStudio. Utilities. dpi. дпихелпер* и *Microsoft. VisualStudio. платформуи. дпихелпер* с вызовами нового *метода Вспомогательный класс Microsoft. VisualStudio. Utilities. Дпиаваренесс* . 

```cs
// Remove this kind of use:
Point deviceTopLeft = new Point(window.Left, window.Top).LogicalToDeviceUnits();

// Replace with this use:
Point deviceTopLeft = window.LogicalToDevicePoint(new Point(window.Left, window.Top));
```

Для машинного кода это приведет к замене вызовов к старому классу *VsUI:: кдпихелпер* вызовами нового класса *VsUI:: кдпиаваренесс* . 

```cpp
// Remove this kind of use:
int cx = VsUI::DpiHelper::LogicalToDeviceUnitsX(m_cxS);
int cy = VsUI::DpiHelper::LogicalToDeviceUnitsY(m_cyS);

// Replace with this use:
int cx = m_cxS;
int cy = m_cyS;
VsUI::CDpiAwareness::LogicalToDeviceUnitsX(m_hwnd, &cx);
VsUI::CDpiAwareness::LogicalToDeviceUnitsY(m_hwnd, &cy);
```

Новые классы Дпиаваренесс и Кдпиаваренесс предлагают те же вспомогательные функции преобразования единиц, что и классы Дпихелпер, но им требуется дополнительный входной параметр: элемент пользовательского интерфейса для использования в качестве ссылки для операции преобразования. Важно отметить, что вспомогательные методы масштабирования изображений не существуют в новых вспомогательных механизмах Дпиаваренесс/Кдпиаваренесс, и при необходимости вместо этого следует использовать [ImageService](../image-service-and-catalog.md) .

Управляемый класс Дпиаваренесс предлагает вспомогательные методы для визуальных элементов WPF, Windows Forms элементы управления и Win32 HWND и Хмониторс (как в форме IntPtr), так и в собственном классе Кдпиаваренесс предлагает HWND и ХМОНИТОР вспомогательные методы.

### <a name="windows-forms-dialogs-windows-or-controls-displayed-in-the-wrong-dpiawarenesscontext"></a>Windows Forms диалоговые окна, окна или элементы управления, отображаемые в неправильном Дпиаваренессконтекст
Даже после успешного создания родительского элемента Windows с различными Дпиаваренессконтекстс (из-за поведения Windows по умолчанию) пользователи могут по-прежнему видеть проблемы масштабирования, так как Windows с разными Дпиаваренессконтекстс масштабами. В результате пользователи могут видеть проблемы выравнивания или размытия текста или изображений в пользовательском интерфейсе.

Решение заключается в задании правильной области Дпиаваренессконтекст для всех окон и элементов управления в приложении.

### <a name="top-level-mixed-mode-tlmm-dialogs"></a>Диалоговые окна верхнего уровня в смешанном режиме (ТЛММ)
При создании окон верхнего уровня, таких как модальные диалоговые окна, важно убедиться, что поток находится в правильном состоянии до создания окна (и его маркера). Поток может быть переведен в осведомленность системы с помощью вспомогательного метода Кдпископе в собственном или вспомогательном модуле Дпиаваренесс. Ентердпископе в Managed. (ТЛММ обычно следует использовать в диалоговых окнах и Windows, не являющихся WPF.)

### <a name="child-level-mixed-mode-clmm"></a>Смешанный режим дочернего уровня (КЛММ)
По умолчанию дочерние окна получают контекст поддержки текущего DPI в потоке, если он создан без родителя или контекст осведомленности о DPI родительского объекта при создании с родительским объектом. Чтобы создать дочерний элемент с другим контекстом, осведомленным о DPI, чем его родительский элемент, поток можно перевести в контекст осведомленности о разрешении DPI. Затем дочерний элемент может быть создан без родителя и вручную переноситься к родительскому окну.

#### <a name="clmm-issues"></a>Проблемы КЛММ
Большая часть работы по вычислению пользовательского интерфейса, выполняемой в рамках основного цикла обмена сообщениями или цепочки событий, должна быть уже запущена в контексте, осведомленном о правильном DPI. Однако, если вычисления координат или размера выполняются за пределами этих основных рабочих процессов (например, во время простоя задачи или в потоке пользовательского интерфейса), контекст осведомленности о DPI может быть неправильным, что приводит к неправильному размещению пользовательского интерфейса или проблемам с неправильным изменением размера. Перевод потока в правильное состояние для работы пользовательского интерфейса обычно решает проблему.
 
#### <a name="opt-out-of-clmm"></a>Отказ от КЛММ
Если окно инструментов, не относящегося к WPF, переносится для полной поддержки ПМА, ему нужно отказаться от КЛММ. Для этого необходимо реализовать новый интерфейс: Ивсдпиаваре.

```cs
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
public interface IVsDpiAware
{
    [ComAliasName("Microsoft.VisualStudio.Shell.Interop.VSDPIMode")]
    uint Mode {get;}
}
```

```cpp
IVsDpiAware : public IUnknown
{
    public:
        HRRESULT STDMETHODCALLTYPE get_Mode(__RCP__out VSDPIMODE *dwMode);
};
```

Для управляемых языков лучшее место для реализации этого интерфейса находится в том же классе, который является производным от *Microsoft. VisualStudio. Shell. ToolWindowPane*. Для C++, лучшее место для реализации этого интерфейса находится в том же классе, который реализует *IVsWindowPane* из всшелл. h.

Значение, возвращаемое свойством Mode в интерфейсе, является __VSDPIMODE (и приводится к типу uint в управляемом виде):

```cs
enum __VSDPIMODE
{
    VSDM_Unaware    = 0x01,
    VSDM_System     = 0x02,
    VSDM_PerMonitor = 0x03,
}
```

- Не означает, что окно инструментов должно работать в 96 DPI, и Windows будет работать с масштабированием для всех остальных dpi. В результате содержимое немного размыто.
- Система означает, что окно инструментов должно поддерживать разрешение DPI для основного отображаемого DPI. Все дисплеи с соответствующими DPI будут выглядеть нечеткими, но если DPI не меняется или изменяется во время сеанса, Windows будет обрабатывать масштабирование, и это будет немного размытым.
- Пермонитор означает, что окно инструментов должно поддерживать все DPI на всех дисплеях и при изменении DPI.

> [!NOTE]
> Visual Studio поддерживает только осведомленность о PerMonitorV2, поэтому значение перечисления Пермонитор преобразуется в значение Windows DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2.

#### <a name="force-a-control-into-a-specific-dpiawarenesscontext"></a>Принудительное применение элемента управления к определенному Дпиаваренессконтекст

Устаревший пользовательский интерфейс, который не обновляется для поддержки режима ПМА, может по-прежнему нуждаться в незначительных корректировках для работы, пока Visual Studio работает в режиме ПМА. Одним из таких исправлений является обеспечение того, что пользовательский интерфейс создается в правильном Дпиаваренессконтекст. Чтобы включить пользовательский интерфейс в определенный Дпиаваренессконтекст, можно ввести область DPI с помощью следующего кода:

```cs
using (DpiAwareness.EnterDpiScope(DpiAwarenessContext.SystemAware))
{
    Form form = new MyForm();
    form.ShowDialog();
}
```

```cpp
void MyClass::ShowDialog()
{
    VsUI::CDpiScope dpiScope(DPI_AWARENESS_CONTEXT_SYSTEM_AWARE);
    HWND hwnd = ::CreateWindow(...);
}
```

> [!NOTE]
> Принудительное выполнение Дпиаваренессконтекст работает только в пользовательском интерфейсе, отличном от WPF, и в диалоговых окнах WPF верхнего уровня. При создании пользовательского интерфейса WPF, который должен размещаться в окнах инструментов или конструкторах, как только содержимое будет вставлено в дерево пользовательского интерфейса WPF, оно будет преобразовано в текущий процесс Дпиаваренессконтекст.

## <a name="known-issues"></a>Известные проблемы

### <a name="windows-forms"></a>Windows Forms

Чтобы оптимизировать для новых сценариев в смешанном режиме, Windows Forms изменили способ создания элементов управления и окон, если их родительский элемент не задан явным образом. Ранее элементы управления без явного родителя использовали внутреннее "окно парковки" как временный родительский элемент для создаваемого элемента управления или окна. 

До выхода .NET 4,8 было одним «окном парковки», которое получает его Дпиаваренессконтекст из контекста осведомленности текущего потока в момент создания окна. Любой неродительский элемент управления наследует тот же Дпиаваренессконтекст, что и окно парковки, когда создается маркер элемента управления и будет переноситься к конечному или ожидаемому родителю, который является его разработчиком приложения. Это приведет к сбоям на основе времени, если "окно парковки" имело больший Дпиаваренессконтекст, чем окончательное родительское окно.

Начиная с .NET 4,8, теперь существует "окно парковки" для каждого Дпиаваренессконтекст. Другое основное различие заключается в том, что Дпиаваренессконтекст, используемый для элемента управления, кэшируется при создании элемента управления, а не при создании этого маркера. Это означает, что общее поведение конечного элемента одинаково, но может превратить то, что использовалось для возникновения проблемы с временем, в целостную ошибку. Он также предоставляет разработчикам приложений более детерминированное поведение для написания кода пользовательского интерфейса и правильного определения его области.
