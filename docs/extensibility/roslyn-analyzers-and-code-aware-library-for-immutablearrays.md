---
title: Анализаторы Roslyn и библиотеки с поддержкой кода для Иммутаблеаррайс
titleSuffix: ''
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 0b0afa22-3fca-4d59-908e-352464c1d903
author: acangialosi
ms.author: anthc
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: db3ebbd289feb227506d8c188ade9261dfb53da2
ms.sourcegitcommit: 4ae5e9817ad13edd05425febb322b5be6d3c3425
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/11/2020
ms.locfileid: "90037651"
---
# <a name="roslyn-analyzers-and-code-aware-library-for-immutablearrays"></a>Анализаторы Roslyn и библиотека с поддержкой кода для Иммутаблеаррайс

[.NET Compiler Platform](https://github.com/dotnet/roslyn) ("Roslyn") помогает создавать библиотеки с поддержкой кода. Библиотека с поддержкой кода предоставляет функциональные возможности, которые можно использовать и средства (Roslyn Analyzer), которые помогут вам использовать библиотеку наиболее эффективно или избежать ошибок. В этом разделе показано, как создать реальный Roslyn анализатор для перехвата распространенных ошибок при использовании пакета [System. Collections. неизменяемый](https://www.nuget.org/packages/System.Collections.Immutable) пакет NuGet. В примере также показано, как предоставить исправление кода для проблемы с кодом, обнаруженной анализатором. Пользователи видят исправления кода в пользовательском интерфейсе лампочки Visual Studio и могут автоматически применить исправление для кода.

## <a name="get-started"></a>Начало работы

Для сборки этого примера необходимо следующее:

* Visual Studio 2015 (не экспресс-выпуск) или более поздней версии. Вы можете использовать бесплатный [выпуск Visual Studio Community Edition](https://visualstudio.microsoft.com/vs/community/)
* [Пакет SDK для Visual Studio](../extensibility/visual-studio-sdk.md). При установке Visual Studio также можно проверить **средства расширения Visual Studio** в разделе **Общие средства** для установки пакета SDK одновременно. Если вы уже установили Visual Studio, вы также можете установить этот пакет SDK, перейдя в главный **файл**меню  >  **Новый**  >  **проект**, выбрав **C#** в левой области навигации, а затем выбрав **расширяемость**. При выборе шаблона проекта "**установить средства расширения Visual Studio**" будет предложено скачать и установить пакет SDK.
* [Пакет SDK .NET Compiler Platform ("Roslyn")](https://marketplace.visualstudio.com/items?itemName=VisualStudioProductTeam.NETCompilerPlatformSDK). Вы также можете установить этот пакет SDK, перейдя в главный **файл**меню  >  **Новый**  >  **проект**, выбрав **C#** в левой области навигации, а затем выбрав **расширяемость**. При выборе шаблона проект иерархического проекта "**скачать .NET COMPILER Platform SDK**" будет предложено скачать и установить пакет SDK. Этот пакет SDK включает [Syntax Visualizer Roslyn](https://github.com/dotnet/roslyn/blob/master/docs/wiki/Syntax-Visualizer.md). Это полезное средство поможет понять, какие типы модели кода следует искать в анализаторе. Инфраструктура анализатора обращается к коду для конкретных типов моделей кода, поэтому код выполняется только при необходимости и может сосредоточиться только на анализе соответствующего кода.

## <a name="whats-the-problem"></a>В чем проблема?

Представьте, что вы предоставляете библиотеку с ImmutableArray (например, <xref:System.Collections.Immutable.ImmutableArray%601?displayProperty=fullName> ). Разработчики на C# имеют множество возможностей для массивов .NET. Однако из-за природы методов Иммутаблеаррайс и оптимизации, используемых в реализации, разработчик C# интуитионс приводил к написанию неработающего кода, как описано ниже. Более того, пользователи не видят свои ошибки до времени выполнения, а это не то, что используется в Visual Studio с .NET.

Пользователи знакомы с написанием кода следующим образом:

```csharp
var a1 = new int[0];
Console.WriteLine("a1.Length = { 0}", a1.Length);
var a2 = new int[] { 1, 2, 3, 4, 5 };
Console.WriteLine("a2.Length = { 0}", a2.Length);
```

Создание пустых массивов для заполнения последующими строками кода и использование синтаксиса инициализатора коллекции знакомо разработчикам на C#. Однако при написании того же кода для ImmutableArray сбой во время выполнения:

```csharp
var b1 = new ImmutableArray<int>();
Console.WriteLine("b1.Length = { 0}", b1.Length);
var b2 = new ImmutableArray<int> { 1, 2, 3, 4, 5 };
Console.WriteLine("b2.Length = { 0}", b2.Length);
```

Первая ошибка возникает из-за того, что в реализации ImmutableArray используется структура для упаковки базового хранилища данных. Структуры должны иметь конструкторы без параметров, чтобы `default(T)` выражения могли возвращать структуры со всеми нулевыми или нулевыми членами. При доступе к коду возникает `b1.Length` Ошибка разыменования NULL во время выполнения, так как в структуре ImmutableArray нет базового массива хранения данных. Правильный способ создания пустого ImmutableArray — `ImmutableArray<int>.Empty` .

Ошибка с инициализаторами коллекций происходит потому, что `ImmutableArray.Add` метод возвращает новые экземпляры при каждом его вызове. Поскольку Иммутаблеаррайс никогда не изменяются, при добавлении нового элемента вы получаете новый объект ImmutableArray (который может использовать хранилище для обеспечения производительности с ранее существующим ImmutableArray). Поскольку `b2` указывает на первый ImmutableArray до вызова `Add()` пять раз, `b2` является ImmutableArray по умолчанию. Кроме того, длина вызова в нем завершается сбоем с ошибкой разыменования null. Правильный способ инициализации ImmutableArray без вызова Add вручную — использовать `ImmutableArray.CreateRange(new int[] {1, 2, 3, 4, 5})` .

## <a name="find-relevant-syntax-node-types-to-trigger-your-analyzer"></a>Поиск соответствующих типов узлов синтаксиса для активации анализатора

 Чтобы начать сборку анализатора, сначала выясните, какой тип SyntaxNode необходимо найти. Запустите **Syntax Visualizer** **в меню**  >  **Other Windows**  >  **Syntax Visualizer Roslyn**Windows.

Поместите курсор редактора в строку, которая объявляет `b1` . Вы увидите, Syntax Visualizer отобразится `LocalDeclarationStatement` узел дерева синтаксиса. Этот узел имеет объект `VariableDeclaration` , который, в свою очередь, имеет, который, в свою очередь, имеет, `VariableDeclarator` `EqualsValueClause` и, наконец, существует `ObjectCreationExpression` . При щелчке Syntax Visualizer дереве узлов в окне редактора выделяется код, представленный этим узлом. Имена подтипов SyntaxNode соответствуют именам, используемым в грамматике C#.

## <a name="create-the-analyzer-project"></a>Создание проекта анализатора

В главном меню выберите **файл**  >  **создать**  >  **проект**. В диалоговом окне **Новый проект** в разделе проекты **C#** на панели навигации слева выберите **расширяемость**и в области справа выберите шаблон проект **с исправлением кода** . Введите имя и подтвердите диалоговое окно.

Шаблон открывает файл *DiagnosticAnalyzer.CS* . Выберите вкладку буфер редактора. Этот файл содержит класс анализатора (сформированный на основе имени, присвоенного проекту), производного от класса `DiagnosticAnalyzer` (тип API Roslyn). Новый класс имеет `DiagnosticAnalyzerAttribute` объявление анализатора относится к языку C#, поэтому компилятор обнаруживает и загружает анализатор.

```csharp
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class ImmutableArrayAnalyzerAnalyzer : DiagnosticAnalyzer
{}
```

Анализатор можно реализовать с помощью Visual Basic, предназначенного для кода C#, и наоборот. В Диагностиканализераттрибуте важнее выбрать, предназначен ли анализатору один язык или оба. Более сложные анализаторы, требующие подробного моделирования языка, могут ориентироваться только на один язык. Если анализатор, например, проверяет только имена типов или имена открытых членов, можно использовать стандартную модель Roslyn для предложений в Visual Basic и C#. Например, FxCop предупреждает, что класс реализует <xref:System.Runtime.Serialization.ISerializable> , но класс не имеет <xref:System.SerializableAttribute> атрибута, независимо от языка и работает как в Visual Basic, так и в коде C#.

## <a name="initialize-the-analyzer"></a>Инициализация анализатора

 Прокрутите вниз немного в `DiagnosticAnalyzer` классе, чтобы увидеть `Initialize` метод. Компилятор вызывает этот метод при активации анализатора. Метод принимает `AnalysisContext` объект, позволяющий анализатору получать сведения о контексте и регистрировать обратные вызовы для событий для типов кода, которые необходимо проанализировать.

```csharp
public override void Initialize(AnalysisContext context) {}
```

Откройте новую строку в этом методе и введите "Context". для просмотра списка завершения IntelliSense. В списке завершения можно увидеть множество `Register...` методов для управления событиями различных типов. Например, первый из них `RegisterCodeBlockAction` выполняет обратный вызов к коду для блока, который обычно является кодом между фигурными скобками. Регистрация для блока также выполняет обратный вызов к коду для инициализатора поля, значения, заданного для атрибута, или значения необязательного параметра.

В качестве другого примера, `RegisterCompilationStartAction` метод вызывает обратную передачу кода в начале компиляции, что полезно, когда необходимо получить состояние во многих местах. Можно создать структуру данных, например, чтобы собираются все используемые символы, и при каждом вызове анализатора для некоторого синтаксиса или символа можно сохранить сведения о каждом расположении в структуре данных. При вызове обратно из-за завершения компиляции можно проанализировать все сохраненные расположения, например, чтобы сообщить, какие символы использует код из каждой `using` инструкции.

С помощью **Syntax Visualizer**вы узнали, что вы хотите вызывать, когда компилятор обрабатывает обжекткреатионекспрессион. Этот код используется для настройки обратного вызова:

```csharp
context.RegisterSyntaxNodeAction(c => AnalyzeObjectCreation(c),
                                 SyntaxKind.ObjectCreationExpression);
```

Вы регистрируетесь на узле синтаксиса и фильтруете только узлы синтаксиса создания объектов. По соглашению авторы анализаторов используют лямбда-выражение при регистрации действий, которое помогает в анализе анализаторов без отслеживания состояния. Для создания метода можно использовать функцию Visual Studio, **созданную в результате использования** `AnalyzeObjectCreation` . Это также создает правильный тип параметра контекста.

## <a name="set-properties-for-users-of-your-analyzer"></a>Задание свойств для пользователей анализатора

Чтобы анализатор был правильно отображен в пользовательском интерфейсе Visual Studio, найдите и измените следующую строку кода, чтобы определить анализатор:

```csharp
internal const string Category = "Naming";
```

Измените `"Naming"` на `"API Guidance"`.

Затем найдите и откройте в проекте файл *Resources. resx* с помощью **Обозреватель решений**. Можно добавить описание для анализатора, заголовка и т. д. Можно изменить значение для всех этих элементов на `"Don't use ImmutableArray<T> constructor"` Now. Можно указать аргументы форматирования строки в строке (, и {0} {1} т. д.), а позднее при вызове `Diagnostic.Create()` можно предоставить `params` Массив передаваемых аргументов.

## <a name="analyze-an-object-creation-expression"></a>Анализ выражения создания объекта

`AnalyzeObjectCreation`Метод принимает другой тип контекста, предоставляемый платформой анализатора кода. `Initialize`Метод `AnalysisContext` позволяет регистрировать обратные вызовы действий для настройки анализатора. В `SyntaxNodeAnalysisContext` , например, есть объект `CancellationToken` , который можно передать. Если пользователь начинает вводить текст в редакторе, Roslyn отменяет выполнение анализаторов для сохранения работы и повышения производительности. В качестве другого примера этот контекст имеет свойство Node, которое возвращает узел синтаксиса создания объекта.

Получите узел, который можно предположить, — это тип, для которого отфильтровано действие узла синтаксиса:

```csharp
var objectCreation = (ObjectCreationExpressionSyntax)context.Node;
```

### <a name="launch-visual-studio-with-your-analyzer-the-first-time"></a>Запуск Visual Studio с анализатором в первый раз

Запустите Visual Studio, создав и выполнив анализатор (нажмите клавишу **F5**). Поскольку запускаемый проект в **Обозреватель решений** является проектом VSIX, при выполнении кода выполняется сборка кода и VSIX, а затем запускается Visual Studio с установленным VSIX. При таком запуске Visual Studio запускается с отдельным кустом реестра, чтобы при создании анализаторов не повлияло на использование Visual Studio при тестировании экземпляров. При первом запуске такого способа Visual Studio выполняет несколько инициализаций, аналогичных при первом запуске Visual Studio после его установки.

Создайте консольный проект, а затем введите код массива в метод Main для консольных приложений:

```csharp
var b1 = new ImmutableArray<int>();
Console.WriteLine("b1.Length = {0}", b1.Length);
var b2 = new ImmutableArray<int> { 1, 2, 3, 4, 5 };
Console.WriteLine("b2.Length = {0}", b2.Length);
```

Строки кода `ImmutableArray` содержат волнистые линии, так как необходимо получить неизменяемый пакет NuGet и добавить в `using` код инструкцию. Нажмите кнопку с правом указателя в узле проекта в **Обозреватель решений** и выберите **Управление пакетами NuGet**. В диспетчере NuGet введите "неизменяемый" в поле поиска и выберите элемент **System. Collections. unmutable** (не выбирайте **Microsoft. BCL. unmutable**) на левой панели и нажмите кнопку **установить** в правой области. При установке пакета добавляется ссылка на ссылки проекта.

В разделе будут отображаться красные волнистые линии `ImmutableArray` , поэтому поместите курсор в этот идентификатор и нажмите клавишу **CTRL** + **.** (точка) для открытия предлагаемого меню исправления и добавления соответствующей `using` инструкции.

**Сохраните все и закройте** второй экземпляр Visual Studio, чтобы перейти в режим очистки, чтобы продолжить.

## <a name="finish-the-analyzer-using-edit-and-continue"></a>Завершение работы с анализатором с помощью команды "изменить и продолжить"

В первом экземпляре Visual Studio установите точку останова в начале `AnalyzeObjectCreation` метода, нажав клавишу **F9** с курсором в первой строке.

Запустите анализатор снова с помощью **F5**, а во втором экземпляре Visual Studio снова откройте консольное приложение, созданное в последний раз.

Вы вернетесь к первому экземпляру Visual Studio в точке останова, так как компилятор Roslyn обнаружил выражение создания объекта и вызываемое в анализатор.

**Возвращает узел создания объекта.** Проведите шаг над строкой, которая задает `objectCreation` переменную, нажав клавишу **F10**, и в **окне Интерпретация** Вычислите выражение `"objectCreation.ToString()"` . Вы видите, что узел синтаксиса, на который указывает переменная, — это код `"new ImmutableArray<int>()"` , который вы ищете.

**Получить объект типа ImmutableArray<T \> .** Необходимо проверить, является ли создаваемый тип ImmutableArray. Сначала вы получаете объект, представляющий этот тип. Вы проверяете типы с помощью семантической модели, чтобы убедиться в том, что имеется именно правильный тип, и не сравниваете строку из `ToString()` . В конце функции введите следующую строку кода:

```csharp
var immutableArrayOfTType =
    context.SemanticModel
           .Compilation
           .GetTypeByMetadataName("System.Collections.Immutable.ImmutableArray`1");
```

Вы назначаете универсальные типы в метаданных с обратными импульсами (') и числом универсальных параметров. Именно поэтому вы не видите "... ImmutableArray \<T> "в имени метаданных.

Семантическая модель имеет много полезных вещей, которые позволяют задавать вопросы о символах, потоке данных, времени жизни переменных и т. д. Roslyn отделяет синтаксические узлы от семантической модели для различных инженерных целей (производительность, моделирование ошибочного кода и т. д.). Необходимо, чтобы модель компиляции выполняла поиск информации, содержащейся в ссылках, для точного сравнения.

Желтый указатель выполнения можно перетащить в левой части окна редактора. Перетащите его в строку, которая задает `objectCreation` переменную и проведите шаг над новой строкой кода с помощью клавиши **F10**. Если навести указатель мыши на переменную `immutableArrayOfType` , вы увидите, что в семантической модели обнаружен точный тип.

**Возвращает тип выражения создания объекта.** "Тип" используется несколькими способами в этой статье, но это означает, что при наличии выражения "New foo" необходимо получить модель foo. Необходимо получить тип выражения создания объекта, чтобы определить, является ли он \<T> типом ImmutableArray. Используйте семантическую модель еще раз, чтобы получить символьную информацию для символа типа (ImmutableArray) в выражении создания объекта. В конце функции введите следующую строку кода:

```csharp
var symbolInfo = context.SemanticModel.GetSymbolInfo(objectCreation.Type).Symbol as INamedTypeSymbol;
```

Поскольку анализатору требуется обработку неполного или неверного кода в буферах редактора (например, отсутствует `using` оператор), следует проверить на наличие `symbolInfo` `null` . Чтобы завершить анализ, необходимо получить именованный тип (Инамедтипесимбол) из объекта символьной информации.

**Сравните типы.** Поскольку существует открытый универсальный тип T, который мы ищем, а тип в коде является конкретным универсальным типом, вы запрашиваете сведения о символах для того, как создается тип (открытый универсальный тип), и сравниваете результат с `immutableArrayOfTType` . В конце метода введите следующую команду:

```csharp
if (symbolInfo != null &&
    symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType))
{}
```

**Сообщите о диагностике.** Создание отчетов о диагностике довольно просто. Созданное вами правило используется в шаблоне проекта, который определен перед методом Initialize. Поскольку такая ситуация в коде является ошибкой, можно изменить строку, для которой инициализировано правило, заменить `DiagnosticSeverity.Warning` (Зеленая волнистая) на `DiagnosticSeverity.Error` (красная волнистая линия). Оставшаяся часть правила инициализируется из ресурсов, измененных в начале этого пошагового руководства. Также необходимо сообщить расположение волнистой линии, которая является расположением спецификации типа выражения создания объекта. Введите этот код в `if` блоке:

```csharp
context.ReportDiagnostic(Diagnostic.Create(Rule, objectCreation.Type.GetLocation()));
```

Функция должна выглядеть следующим образом (возможно, отформатированным по-другому):

```csharp
private void AnalyzeObjectCreation(SyntaxNodeAnalysisContext context)
{
    var objectCreation = (ObjectCreationExpressionSyntax)context.Node;
    var immutableArrayOfTType =
        context.SemanticModel
               .Compilation
               .GetTypeByMetadataName(
                   "System.Collections.Immutable.ImmutableArray`1");
    var symbolInfo = context.SemanticModel.GetSymbolInfo(objectCreation.Type).Symbol as
        INamedTypeSymbol;
    if (symbolInfo != null &&
        symbolInfo.ConstructedFrom.Equals(immutableArrayOfTType))
    {
        context.ReportDiagnostic(
            Diagnostic.Create(Rule, objectCreation.Type.GetLocation()));
    }
}
```

Удалите точку останова, чтобы убедиться, что анализатор работает (и прекращает возврат к первому экземпляру Visual Studio). Перетащите указатель выполнения в начало метода и нажмите клавишу **F5** , чтобы продолжить выполнение. При переключении обратно на второй экземпляр Visual Studio компилятор начнет изучать код еще раз и будет вызывать анализатор. В можно увидеть волнистую линию `ImmutableType<int>` .

## <a name="adding-a-code-fix-for-the-code-issue"></a>Добавление "исправления кода" для проблемы с кодом

Прежде чем начать, закройте второй экземпляр Visual Studio и завершите отладку в первом экземпляре Visual Studio (на котором разрабатывается анализатор).

**Добавьте новый класс.** Используйте контекстное меню (кнопка с правой кнопкой мыши) в узле проекта в **Обозреватель решений** и выберите Добавить новый элемент. Добавьте класс с именем `BuildCodeFixProvider` . Этот класс должен быть производным от `CodeFixProvider` , и потребуется использовать **CTRL** + **.** (точка) для вызова исправления кода, добавляющего правильную `using` инструкцию. Этот класс также должен иметь аннотации с `ExportCodeFixProvider` атрибутом, и необходимо добавить `using` инструкцию для разрешения `LanguageNames` перечисления. У вас должен быть файл класса со следующим кодом:

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeFixes;

namespace ImmutableArrayAnalyzer
{
    [ExportCodeFixProvider(LanguageNames.CSharp)]
    class BuildCodeFixProvider : CodeFixProvider
    {}
```

**Заглушка для производных членов.** Теперь поместите курсор редактора в идентификатор `CodeFixProvider` и нажмите клавишу **CTRL** + **.** (точка) для создания заглушки реализации для этого абстрактного базового класса. При этом создается свойство и метод.

**Реализуйте свойство.** Заполните `FixableDiagnosticIds` текст свойства `get` следующим кодом:

```csharp
return ImmutableArray.Create(ImmutableArrayAnalyzerAnalyzer.DiagnosticId);
```

Roslyn объединяет диагностику и исправления, сопоставляя эти идентификаторы, которые являются просто строками. Шаблон проекта создал идентификатор диагностики, и вы можете изменить его. Код в свойстве просто возвращает идентификатор из класса Analyzer.

**Метод Регистеркодефиксасинк принимает контекст.** Контекст важен, поскольку исправление кода может применяться к нескольким диагностическим сведениям, или в одной строке кода может быть несколько проблем. Если ввести "Context". в теле метода в списке завершения IntelliSense будут показаны некоторые полезные члены. Существует элемент CancellationToken, который позволяет проверить, нужно ли отменить исправление. Существует элемент документа, который имеет множество полезных элементов и позволяет перейти к объектам модели проекта и решения. Существует элемент span, который является началом и концом расположения кода, указанного при обнаружении диагностики.

**Сделайте метод асинхронным.** Первое, что нужно сделать, это исправить объявление созданного метода как `async` метод. Исправление кода для создание заглушек реализации абстрактного класса не включает `async` ключевое слово, хотя метод возвращает `Task` .

**Возвращает корень дерева синтаксиса.** Чтобы изменить код, необходимо создать новое дерево синтаксиса с изменениями, которые делает исправление кода. `Document`Для вызова требуется объект из контекста `GetSyntaxRootAsync` . Это асинхронный метод, поскольку неизвестна работа по получению дерева синтаксиса, возможно, включая получение файла с диска, его синтаксический анализ и сборку модели кода Roslyn. В это время пользовательский интерфейс Visual Studio должен отвечать на запросы, что `async` позволяет использовать. Замените строку кода в методе следующим:

```csharp
var root = await context.Document
                        .GetSyntaxRootAsync(context.CancellationToken);
```

**Найдите узел с проблемой.** Вы передаете диапазон контекста, но искомый узел может не быть кодом, который необходимо изменить. Сообщаемая диагностическая диагностика предоставляла только диапазон для идентификатора типа (где наступило бесконечную волнистую линию), но необходимо заменить все выражение создания объекта, включая `new` ключевое слово в начале и круглые скобки в конце. Добавьте в метод следующий код (и используйте **клавишу CTRL** + **.** Добавление `using` оператора для `ObjectCreationExpressionSyntax` ):

```csharp
var objectCreation = root.FindNode(context.Span)
                         .FirstAncestorOrSelf<ObjectCreationExpressionSyntax>();
```

**Зарегистрируйте исправление кода для пользовательского интерфейса лампочки.** При регистрации исправления кода Roslyn автоматически подключается к пользовательскому интерфейсу лампочки Visual Studio. Конечные пользователи увидят, что они смогут использовать **сочетание клавиш CTRL** + **.** (период), когда анализатор волнистым линиями неверно `ImmutableArray<T>` использует конструктор. Поскольку поставщик исправления кода выполняется только при возникновении проблемы, можно предположить, что у вас есть искомое выражение для создания объектов. В параметре context можно зарегистрировать новое исправление кода, добавив в конец метода следующий код `RegisterCodeFixAsync` :

```csharp
context.RegisterCodeFix(
            CodeAction.Create("Use ImmutableArray<T>.Empty",
                              c => ChangeToImmutableArrayEmpty(objectCreation,
                                                               context.Document,
                                                               c)),
            context.Diagnostics[0]);
```

Необходимо поместить курсор редактора в идентификатор, `CodeAction` а затем нажать **клавишу CTRL** + **.** (точка), чтобы добавить соответствующий `using` оператор для этого типа.

Затем поместите курсор редактора в `ChangeToImmutableArrayEmpty` идентификатор и используйте **клавишу CTRL** + **.** Опять же, для создания этой заглушки метода.

Последний добавленный фрагмент кода регистрирует исправление кода, передав `CodeAction` идентификатор диагностики и для обнаруженного типа проблемы. В этом примере существует только один идентификатор диагностики, в котором этот код предоставляет исправления для, поэтому можно просто передать первый элемент массива идентификаторов диагностики. При создании `CodeAction` вы передаете текст, который пользовательский интерфейс лампочки должен использовать в качестве описания исправления кода. Вы также передаете функцию, которая принимает CancellationToken и возвращает новый документ. Новый документ содержит новое дерево синтаксиса, включающее исправленный код, вызывающий `ImmutableArray.Empty` . Этот фрагмент кода использует лямбда-выражение, чтобы его можно было закрыть через узел Обжекткреатион и документ контекста.

**Создайте новое дерево синтаксиса.** В `ChangeToImmutableArrayEmpty` методе, заглушке которого вы создали ранее, введите строку кода: `ImmutableArray<int>.Empty;` . При повторном просмотре окна инструментов **Syntax Visualizer** можно увидеть, что этот синтаксис является симплемемберакцессекспрессион узлом. Именно этот метод должен создавать и возвращать новый документ.

Первое изменение в `ChangeToImmutableArrayEmpty` добавляется `async` до тех пор `Task<Document>` , пока генераторы кода не могут предположить, что метод должен быть асинхронным.

Заполните текст следующим кодом, чтобы метод выглядел примерно следующим образом:

```csharp
private async Task<Document> ChangeToImmutableArrayEmpty(
    ObjectCreationExpressionSyntax objectCreation, Document document,
    CancellationToken c)
{
    var generator = SyntaxGenerator.GetGenerator(document);
    var memberAccess =
        generator.MemberAccessExpression(objectCreation.Type, "Empty");
    var oldRoot = await document.GetSyntaxRootAsync(c);
    var newRoot = oldRoot.ReplaceNode(objectCreation, memberAccess);
    return document.WithSyntaxRoot(newRoot);
}
```

Необходимо вставить курсор редактора в `SyntaxGenerator` идентификатор и нажать **клавишу CTRL** + **.** (точка), чтобы добавить соответствующий `using` оператор для этого типа.

В этом коде используется `SyntaxGenerator` , который является полезным типом для создания нового кода. После получения генератора для документа, который имеет ошибку кода, `ChangeToImmutableArrayEmpty` вызывает `MemberAccessExpression` , передает тип, имеющий элемент, к которому нужно получить доступ, и передает имя члена в виде строки.

Затем метод извлекает корневой элемент документа, и так как это может привести к произвольной работе в общем случае, код ожидает этот вызов и передает токен отмены. Модели кода Roslyn являются неизменяемыми, как и при работе со строкой .NET. При обновлении строки возвращается новый строковый объект. При вызове возвращается `ReplaceNode` новый корневой узел. Большая часть дерева синтаксиса является общей (так как она неизменяема), но `objectCreation` узел заменяется `memberAccess` узлом, а также все родительские узлы вплоть до корня дерева синтаксиса.

## <a name="try-your-code-fix"></a>Попробуйте исправить код

Теперь можно нажать клавишу **F5** , чтобы запустить анализатор во втором экземпляре Visual Studio. Откройте проект консоли, который вы использовали ранее. Теперь должна появиться лампочка, где будет создано новое выражение для создания объекта `ImmutableArray<int>` . При нажатии клавиши **CTRL** + **.** (period) вы увидите исправление кода, и вы увидите в пользовательском интерфейсе "лампочка" предварительный просмотр разницы в коде. Roslyn создает это.

**Совет по Pro:** Если вы запускаете второй экземпляр Visual Studio и не видите лампочку с исправлением кода, вам может потребоваться очистить кэш компонентов Visual Studio. Очистка кэша заставляет Visual Studio повторно исследовать компоненты, поэтому Visual Studio должен выбрать последний компонент. Сначала завершите работу второго экземпляра Visual Studio. Затем в **проводнике Windows**перейдите по адресу *%LocalAppData%\Microsoft\VisualStudio\16.0Roslyn \\ *. (Значение "16,0" меняется с версии на версию до версии Visual Studio.) Удалите подкаталог *компонентмоделкаче*.

## <a name="talk-video-and-finish-code-project"></a>Проект кода для видео и завершения проекта

Вы можете увидеть, что этот пример был разработан и обсуждается далее в [этом разговоре](https://channel9.msdn.com/events/Build/2015/3-725). В этом разговоре демонстрируется работающий анализатор и пошаговое руководство по его созданию.

Весь готовый код можно просмотреть [здесь](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers). Вложенные папки *донотусеиммутаблеаррайколлектионинитиализер* и *Донотусеиммутаблеаррайктор* имеют файл c# для поиска проблем и файл c#, который реализует исправления кода, отображаемые в пользовательском интерфейсе лампочки Visual Studio. Обратите внимание, что завершенный код имеет немного более абстракцию, чтобы избежать повторной выборки \<T> объекта типа ImmutableArray. Он использует вложенные зарегистрированные действия для сохранения объекта типа в контексте, который доступен при выполнении вложенных действий (анализ создания объекта и анализ инициализации коллекции).

## <a name="see-also"></a>См. также раздел

* [\\\Буилд 2015](https://channel9.msdn.com/events/Build/2015/3-725)
* [Завершенный код на GitHub](https://github.com/DustinCampbell/CoreFxAnalyzers/tree/master/Source/CoreFxAnalyzers)
* [Несколько примеров на сайте GitHub, сгруппированных в три вида анализаторов](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Analyzer%20Samples.md)
* [Другие документы на сайте OSS для GitHub](https://github.com/dotnet/roslyn/tree/master/docs/analyzers)
* [Правила FxCop, реализованные с анализаторами Roslyn на GitHub](https://github.com/dotnet/roslyn/tree/master/src/Features/Core/Portable/Diagnostics/Analyzers)
