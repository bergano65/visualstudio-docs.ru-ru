---
title: Анализ использования памяти JavaScript в приложениях UPW | Документация Майкрософт
description: Сведения об анализаторе памяти JavaScript, который помогает получать информацию об использовании памяти и находить утечки памяти в приложениях универсальной платформы Windows, разработанных для Windows с использованием JavaScript.
ms.custom: ''
ms.date: 11/04/2016
ms.topic: how-to
dev_langs:
- JavaScript
helpviewer_keywords:
- dominators, memory analyzer (JavaScript)
- memory leaks (JavaScript)
- heap memory, JavaScript
- leaks, memory (JavaScript)
- snapshots, memory analyzer (JavaScript)
- JavaScript Memory Analyzer
- analyzing memory, JavaScript
- memory analyzer, JavaScript
author: mikejo5000
ms.author: mikejo
manager: jmartens
monikerRange: vs-2017
ms.workload:
- multiple
ms.openlocfilehash: f6fb446890c1485b6af249fd593cc9065bdba5aa
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99918127"
---
# <a name="analyze-javascript-memory-usage-in-uwp-apps"></a>Анализ использования памяти JavaScript в приложениях UPW
Анализатор памяти JavaScript доступен в Visual Studio и помогает получать информацию об использовании памяти и находить утечки памяти в приложениях универсальной платформы Windows, разработанных для Windows с использованием JavaScript. К поддерживаемым приложениям относятся приложения для универсальных приложений Windows.

 Анализатор памяти JavaScript помогает решать следующие задачи:

- быстро выявлять проблемы использования памяти в приложении, выделяя наиболее важные данные.

     Пользователь получает эти данные в сводках снимков, показывающих различия между двумя моментальными снимками и содержащих ссылки на более подробные представления.

- получать представления доминаторов, типов и корней, которые помогают изолировать проблемы;

- уменьшать объем информации, не предполагающей действий, в данных кучи JavaScript.

     Объекты, которые не создаются непосредственно в коде приложения, автоматически отфильтровываются. Можно также фильтровать данные по именам объектов.

## <a name="run-the-javascript-memory-analyzer"></a>Запуск анализатора памяти JavaScript
 Анализатор памяти можно использовать, когда в Visual Studio открыто работающее приложение UWP.

#### <a name="to-run-the-memory-analyzer"></a>Запуск анализатора памяти

1. Запустите Visual Studio.

2. При запуске приложения из Visual Studio в списке **Начать отладку** на панели инструментов **Стандартная** выберите целевой объект отладки проекта: **локальный компьютер** или **устройство**.

3. В строке меню выберите **Отладка** > **Профилировщик производительности**.

     По умолчанию анализируется текущий запускаемый проект. Если требуется изменить целевой объект анализа, выберите **Изменить целевой объект**.

     ![Изменение целевого объекта анализа](../profiling/media/js_tools_target.png "JS_Tools_Target")

     В качестве целевого объекта анализа предусмотрены следующие параметры:

    - **Запускаемый проект**. Анализирует текущий запускаемый проект. При запуске приложения на удаленном компьютере необходимо выбрать этот параметр (он устанавливается по умолчанию);

    - **Выполняемое приложение**. Позволяет выбрать приложение универсальной платформы Windows из списка выполняющихся. При запуске приложения на удаленном компьютере этот параметр использовать нельзя.

         Этот параметр следует использовать для анализа использования памяти приложениями, запущенными на локальном компьютере при отсутствии доступа к исходному коду;

    - **Установленное приложение**. Позволяет выбрать установленное приложение универсальной платформы Windows, которое необходимо проанализировать. При запуске приложения на удаленном компьютере этот параметр использовать нельзя.

         Этот параметр следует использовать для анализа использования памяти приложениями, установленными на локальном компьютере при отсутствии доступа к исходному коду. Этот параметр также может быть полезен, если необходимо проанализировать использование памяти любым приложением, не относящимся к приложениям, которые вы разрабатываете.

4. В разделе **Доступные инструменты** установите флажок **Память JavaScript** , а затем выберите **Запуск**.

5. При запуске анализатора памяти в окне "Контроль учетных записей" может быть запрошено разрешение на запуск файла Collector.exe трассировки событий Windows Visual Studio. Выберите **Да**.

     Поработайте с приложением для тестирования соответствующих сценариев использования памяти и просмотра диаграммы памяти, как описано ниже.

6. Перейдите в Visual Studio, нажав клавиши **ALT**+**TAB**.

7. Чтобы просмотреть данные, собираемые анализатором памяти, щелкните **Создать снимок кучи**. См. раздел [View a snapshot summary](#view-a-snapshot-summary) далее в этой статье.

## <a name="check-memory-usage"></a>Проверка использования памяти
 С помощью различных представлений в анализаторе памяти JavaScript можно попытаться выявить утечки памяти. Если есть подозрение на утечку памяти в приложении, см. раздел [Isolate a memory leak](#isolate-a-memory-leak) предлагаемый рабочий процесс.

 Для выявления утечек памяти в приложении предусмотрены следующие представления.

- [Просмотр сводки использования памяти в реальном времени](#view-live-memory-usage-summary). Граф использования памяти можно использовать для поиска внезапных скачков использования памяти или постоянного увеличения использования памяти в результате каких-либо действий. Представление сводки использования памяти в реальном времени можно использовать для создания снимков кучи. Снимки появятся в виде коллекции под графом использования памяти.

    > [!TIP]
    > При создании снимка экрана будет отмечен пик в использовании памяти. Используйте сводки снимка для более точного обозначения роста.

- [View a snapshot summary](#view-a-snapshot-summary). Можно просматривать сводную информацию о снимках во время или после сеанса профилирования памяти. Из сводки снимков можно переходить к сведениям о снимках и разностным представлениям снимков.

    > [!TIP]
    > Как правило, именно разностные представления снимков позволяют получить наиболее полезную информацию об утечках памяти.

- [Просмотр сведений о снимке](#view-snapshot-details). Содержит подробные сведения об использовании памяти для отдельного снимка.

- [Просмотр разницы между снимками](#view-a-snapshot-diff). Отображает разностные значения между снимками. Эти представления позволяют увидеть различия в размерах объектов и числе объектов.

## <a name="isolate-a-memory-leak"></a>Isolate a memory leak
 Перечисленные ниже действия представляют собой предлагаемый рабочий процесс, позволяющий обеспечить более эффективное использование анализатора памяти JavaScript. Эти действия могут быть полезны, если есть подозрение, что в приложении существует утечка памяти. Руководство по процедуре поиска утечек памяти в работающем приложении см. в статье [Пошаговое руководство. Поиск утечек памяти (JavaScript)](javascript-memory.md).

1. Откройте приложение в Visual Studio.

2. Запустите анализатор памяти JavaScript (см. предыдущие шаги).

3. Запустите приложение через сценарий, который необходимо протестировать. Например, сценарий может включать в себя большое изменение модели DOM при загрузке определенной страницы или при запуске приложения.

4. Повторите сценарий дополнительно 1-4 раза.

   > [!TIP]
   > Повторяя тестовые сценарий несколько раз можно добиться фильтрации работы инициализации в результатах.

5. Перейдите в Visual Studio (нажмите клавиши **ALT**+**TAB**).

6. Сделайте базовый снимок кучи, выбрав **Создать снимок кучи**.

    На следующем рисунке показан пример базового снимка.

    ![Базовый снимок](../profiling/media/js_mem_leak_workflow_baseline.png "JS_Mem_Leak_Workflow_Baseline")

   > [!TIP]
   > Для более точного контроля над временем создания снимков используйте команду [Associate source code with memory usage data](#associate-source-code-with-memory-usage-data) в своем коде.

7. Переключитесь в приложение и повторите (только одни раз) тестируемый сценарий.

8. Перейдите в Visual Studio и сделайте второй снимок.

9. Переключитесь в приложение и повторите (только одни раз) тестируемый сценарий.

10. Перейдите в Visual Studio и сделайте третий снимок.

     На следующем рисунке показан пример второго и третьего снимков.

     ![Второй и третий снимок](../profiling/media/js_mem_leak_workflow.png "JS_Mem_Leak_Workflow")

     Делая базовый, второй и третий снимки рабочего процесса, можно проще отфильтровывать изменения, которые не связаны с утечкой памяти. Например, это могут быть ожидаемые изменения, такие как обновление верхнего и нижнего колонтитулов на странице, которые обуславливают некоторые изменения в использовании памяти, но вряд ли связаны с утечками.

11. На третьем снимке выберите ссылку на одно из разностных представлений:

    - Разностный размер кучи (левая ссылка под размером кучи). Текст ссылки показывает разницу между размером кучи текущего снимка и размером кучи предыдущего снимка.

    - Разностное число объектов (правая ссылка под числом объектов). Текст ссылки отображает два значения (например +1858 / –1765): первое значение — число новых объектов, добавленных с момента предыдущего снимка; второе значение — число объектов, удаленных с момента предыдущего снимка.

      По этим ссылкам открывается разностное представление сведений о снимках для типов кучи, отсортированное или по полному размеру, или по количеству объектов, в зависимости от открываемой ссылки.

12. Чтобы выявить проблемы с использованием памяти, выберите один из этих параметров фильтра **Область** :

    - **Объекты, оставшиеся после снимка №2**.

    - **Объекты, добавленные в период между снимками №2 и №3**

    > [!TIP]
    > Отфильтрованное представление объектов, оставшихся после предыдущего снимка, можно использовать для изучения утечек памяти. Например, если разностное число объектов равно +205 / -195, в этом представлении будут показаны 10 оставшихся объектов, из-за которых, вероятно, и происходят утечки памяти.

     На следующем рисунке показано разностное представление объектов, оставшихся после снимка №2.

     ![Представление различий между снимками, отображающее типы](../profiling/media/js_mem_snapshot_diff.png "JS_Mem_Snapshot_Diff")

     На предыдущем рисунке показаны два объекта, оставшихся после предыдущего снимка. Изучите, является ли такое поведение ожидаемым для вашего конкретного приложения. Если нет, значит, возможно, имеется утечка памяти.

13. Чтобы увидеть, как объекты в разностных представлениях связаны с глобальным объектом, который не позволяет сборщику мусора их удалить, откройте контекстное меню для объекта и выберите **Показать в корневом представлении**. Большое число объекта могут случайно сохраняться в памяти, потому что на них ссылается один или несколько объектов, которые связаны с глобальным объектом.

14. Если в представлении показано слишком много оставшихся объектов, попробуйте ограничить период, в который происходит утечка памяти, и затем повторно сделать три снимка. Для дальнейшей локализации утечек памяти используйте команду [Associate source code with memory usage data](#associate-source-code-with-memory-usage-data), [Associate source code with memory usage data](#associate-source-code-with-memory-usage-data)и другие данные об использовании памяти, доступные в анализаторе памяти.

## <a name="view-live-memory-usage-summary"></a>Просмотр сводки использования памяти в реальном времени
 Представление сводки использования памяти в реальном времени содержит граф использования памяти для выполняющегося приложения и коллекцию всех плиток сводки снимков. В этом представлении можно выполнять основные задачи, такие как создание снимков, анализ сводных сведений и переход к другим представлениям. При остановке сбора данных граф памяти исчезает и остается только представление [View a snapshot summary](#view-a-snapshot-summary)

 Граф памяти показывает использование памяти процессом приложения в реальном времени, включая байты исключительного использования и кучу JavaScript. Граф памяти представляет собой прокручиваемое представление памяти процесса. Вот как оно выглядит:

 ![График распределения памяти из анализатора памяти JavaScript](../profiling/media/js_mem_memory_graph.png "JS_Mem_Memory_Graph")

 Если в код приложения были добавлены пользовательские отметки (см. раздел [Associate source code with memory usage data](#associate-source-code-with-memory-usage-data)), на графе использования памяти будет присутствовать перевернутый треугольник, показывающий, когда был достигнут этот раздел кода.

 Часть памяти, показанной на графе, выделяется средой выполнения JavaScript. В приложении невозможно контролировать использование этой памяти. Показываемое на графе использование памяти увеличивается при создании первого снимка, а затем увеличивается с минимальным шагом для каждого дополнительного снимка.

## <a name="view-a-snapshot-summary"></a>View a snapshot summary
 Чтобы сделать снимок текущего состояния использования памяти приложением, щелкнув **Создать снимок кучи** на графе памяти. Плитка сводки снимков, которая отображается как в сводке использования памяти в реальном времени (во время выполнения приложения), так и в сводке снимков (когда приложение остановлено), содержит сведения о куче JavaScript и ссылки на более подробные сведения. При наличии двух или более снимков снимок будет содержать дополнительную информацию, сравнивающую его данные с предыдущим снимком.

> [!NOTE]
> Анализатор памяти JavaScript принудительно проводит сборку мусора перед каждым снимком. Это позволяет гарантировать, что результаты различных запусков будут менее противоречивы.

 Ниже приведен пример сводки снимков при создании несколько снимков.

 ![Сводка снимков](../profiling/media/js_mem_snapshot_summary.png "JS_Mem_Snapshot_Summary")

 Сводка снимков включает:

- заголовок снимка и отметку времени;

- число потенциальных проблем (отмечено синим значком информации). Это число, если оно присутствует, свидетельствует о потенциальных проблемах памяти, например об узлах, которые не связаны с моделью DOM. Это число является ссылкой на представление "Типы" снимка, отсортированное по типам проблем, что позволяет быстрее обнаруживать потенциальные проблемы. Подсказка содержит описание проблемы;

- размер кучи. Это число включает объекты и элементы DOM, которые среда выполнения JavaScript, добавляет в кучу JavaScript. Размер кучи является ссылкой на представление "Типы" снимка.

- разностный размер кучи. Это значение показывает разницу между размером кучи текущего снимка и размером кучи предыдущего снимка. Значение сопровождается красной стрелкой вверх, если имело место увеличение памяти, или зеленой стрелкой вниз, если имело место уменьшение памяти. Если размер кучи не изменился между снимками, вместо числа будет отображен текст **Без изменений** . Для первого снимка будет отображен текст **Базовый**. Разностный размер кучи является ссылкой на разностное представление "Типы" снимка.

- число объектов. Этот счетчик показывает только объекты, созданные в приложении, и не учитывает объекты, созданные средой выполнения JavaScript. Число объекта является ссылкой на представление "Типы" сведений о снимке;

- разностное число объектов. Здесь отображается два значения: первое значение — число новых объектов, добавленных с момента предыдущего снимка; второе значение — число объектов, удаленных с момента предыдущего снимка. Например, иллюстрация показывает, что с момента создания снимка №1 было добавлено 1 859 объектов, удалено — 1 733 объекта. Эта информация сопровождается красной стрелкой вверх, если общее число объектов увеличилось, или зеленой стрелкой вниз, если число объектов уменьшилось. Если число объектов не изменилось между снимками, вместо числа будет отображен текст **Без изменений** . Для первого снимка будет отображен текст **Базовый**. Разностное число объектов является ссылкой на разностное представление "Типы" снимка;

- Снимок экрана в момент создания снимка.

## <a name="view-snapshot-details"></a>Просмотр сведений о снимке
 Подробные сведения об использовании памяти можно просматривать для каждого отдельного снимка в представлении сведений о снимке.

 В представлении сводки снимков выберите ссылку, чтобы увидеть сведения о снимках. Например, ссылка размера кучи по умолчанию открывает представление "Типы" сведений.

 На этом рисунке показано представление "Типы" в сведениях о снимке, а данные об использовании памяти отсортированы по полному размеру.

 ![Представление сведений о снимке, отображающее потенциальные проблемы](../profiling/media/js_mem_snapshot_details.png "JS_Mem_Snapshot_Details")

 В представлении сведений о снимке можно просматривать данные об использовании памяти по типам, корням или доминаторам, выбирая нужный параметр на панели инструментов:

- **Типы**. Отображает число экземпляров и общий размер объектов в куче, сгруппированных по типам. По умолчанию список сортируется по числу экземпляров.

  > [!TIP]
  > Обычно разностные представления типов кучи объектов являются наиболее полезными для определения утечки памяти; в таких представлениях имеется фильтр **Область** , который помогает обнаружить оставшиеся объекты.

- **Корни**. Отображает иерархическое представление объектов из корневых объектов через дочерние ссылки. По умолчанию дочерние узлы сортируются по убыванию значения в столбце полного размера.

- **Доминаторы**. Отображает список объектов в куче с монопольными ссылками на другие объекты. Доминаторы сортируются по полному размеру.

  > [!TIP]
  > При удалении доминатора из памяти возвращаются все удерживаемые объектом ресурсы памяти. Для некоторых приложений при помощи представления "Доминаторы" можно уточнить полные объемы памяти, потому что есть возможность изучить полную цепочку ссылок на объект.

  Все три представления содержат похожие типы значений, в том числе следующие.

- **Идентификаторы**. Имена, определяющие объекты. Например, для элементов HTML в сведениях снимка отображается значение атрибута ID, если он используется.

- **Тип**. Тип объекта (например, элемент link или div в HTML).

- **Размер**. Размер объекта без учета размера объектов, на которые он ссылается.

- **Полный размер**. Размер объекта плюс размеры всех его дочерних объектов, у которых нет других родительских объектов. С практической точки зрения эта сумма представляет собой полный объем памяти объекта, поэтому при удалении объекта высвобождается именно этот объем памяти.

- **Число**. Количество экземпляров объекта. Это значение отображается только в представлении "Типы".

## <a name="view-a-snapshot-diff"></a>Просмотр разницы между снимками
 В анализаторе памяти JavaScript можно сравнить снимок с предыдущим снимком в разностных представлениях снимков.

 В представлении сводки снимков можно просматривать разностные сведения о снимках, щелкая ссылки разностного размера кучи или числа объектов после создания двух или более снимков.

 Кроме того, можно просматривать разностные сведения о типах, корнях и доминаторах. В разностном представлении отображаются сведения, например об объектах, которые были добавлены в кучу между двумя снимками.

 На этом рисунке показано представление "Типы" для разницы между снимками.

 ![Представление различий между снимками, отображающее типы](../profiling/media/js_mem_snapshot_diff.png "JS_Mem_Snapshot_Diff")

 В окне разницы между снимками такие представления, как "Доминаторы", "Типы" и "Корни", не отличаются от окна [Просмотр сведений о снимке](#view-snapshot-details) . В разностных представлениях снимков отображается та же информация, что и в представлении сведений о снимке, а также следующие дополнительные значения.

- **Разница размера**. Разница между размером объекта в текущем снимке и его размером в предыдущем снимке без учета размера объектов, на которые он ссылается.

- **Разница полного размера**. Разница между полным размером объекта в текущем снимке и его полным размером в предыдущем снимке. Полный размер включает размер самого объекта и всех его дочерних объектов, у которых нет других родительских объектов. С практической точки зрения полный размер представляет собой весь объем памяти, связанной с объектом, поэтому при удалении объекта высвобождается именно этот объем памяти.

  Чтобы отфильтровать сведения о разности между снимками, выберите один их фильтров **Область** в верхней части разностных представлений.

- **Объекты, оставшиеся после снимка №\<number>** . Фильтр показывает разницу между объектами, добавленными в кучу и удаленными из кучи, по сравнению с базовым и предыдущим снимками. Например, если в сводке снимков число объектов равно +205 / -195, этот фильтр покажет 10 объектов, которые были добавлены, но не были удалены.

  > [!TIP]
  > Чтобы вывести на экран наиболее полезную информацию в данном фильтре, следуйте инструкциям, описанным в подразделе [Isolate a memory leak](#isolate-a-memory-leak).

- **Объекты, добавленные между снимками №\<number> и №\<number>** . Фильтр показывает все объекты, добавленные в кучу с предыдущего снимка.

- **Все объекты, оставшиеся после снимка №\<number>** . Настройки этого фильтра не отсеивают каких-либо объектов кучи.

  Чтобы вывести на экран ссылки на объекты, которые не соответствуют текущему фильтру **Область**, выберите **Показать несовпадающие ссылки** в ![раскрывающемся списке параметров в анализаторе памяти](../profiling/media/js_mem_settings.png "JS_Mem_Settings") в правом верхнем углу области. При включении этого параметра несоответствующие ссылки отображаются серым текстом

> [!TIP]
> Рекомендуется следовать инструкциям в разделе [Isolate a memory leak](#isolate-a-memory-leak) , а затем использовать фильтр **Область** оставшихся объектов, чтобы определить объекты, из-за которых происходит утечка памяти.

## <a name="view-objects-by-dominator"></a>Просмотр объектов по доминатору
 В представлениях "Доминаторы" и "Типы" можно просматривать объекты, помещенные в папки своих доминаторов (это представление по умолчанию на вкладке **Доминаторы**). При выборе этого представления в представлении верхнего уровня объектов показываются только доминаторы. (дочерние объекты неглобальных объектов в представлении верхнего уровня скрыты). Благодаря снижению шума в данных в некоторых приложениях это может помочь выявить объекты, вызывающие утечки памяти.

 Чтобы переключиться на просмотр объектов по доминатору, нажмите кнопку **Поместить объекты в папки по доминатору** . ![Свертывание объектов в их доминаторы](../profiling/media/js_mem_fold_objects.png "JS_Mem_Fold_Objects")

 Дополнительные сведения о доминаторах см. в разделе [Просмотр сведений о снимке](#view-snapshot-details).

## <a name="filter-data-by-identifier"></a>Фильтрация данных по идентификатору
 В представлениях "Доминаторы" и "Типы" можно фильтровать данные с помощью поиска по определенным идентификаторам. Для поиска идентификатора просто введите его имя в текстовое поле **Фильтр идентификаторов** в правом верхнем углу. По мере ввода идентификаторы, которые не содержат введенные символы, отфильтровываются.

 Каждое представление имеет свой собственный фильтр, поэтому фильтр не сохраняется при переходе в другое представление.

## <a name="find-an-object-in-the-object-tree"></a>Поиск объекта в дереве объектов
 В представлениях "Типы" и "Доминаторы" можно видеть связь между определенным объектом и объектом `Global` . Объекты, связанные с объектом `Global` не будут удалены сборщиком мусора. Можно легко находить известный объект в представлении "Корни" без поиска по дереву объектов `Global` . Для этого откройте контекстное меню объекта в представлении "Доминаторы" или "Тип" и выберите **Показать в корневом представлении**.

## <a name="view-shared-object-references"></a>Просмотр общих ссылок на объекты
 В представлениях "Типы" и "Доминаторы" нижняя область содержит список ссылок на объекты, в котором указаны общие ссылки. При выборе объекта в верхней области в списке ссылок на объекты отображаются все объекты, которые указывают на данный объект.

> [!NOTE]
> Циклические ссылки показываются со звездочкой (*) в виде информационной подсказки и не могут быть развернуты. В противном случае, они бы препятствовали проходу вверх по дереву ссылок и определению объектов, удерживающих память.

 Если вам требуется дополнительная помощь при определении эквивалентных объектов, нажмите **Показать идентификаторы объектов** в ![раскрывающемся списке параметров в анализаторе памяти](../profiling/media/js_mem_settings.png "JS_Mem_Settings") в правом верхнем углу верхней области. После этого рядом с именами объектов будут указываться их идентификаторы в списке **Идентификаторы** (идентификатор отображается во всех представлениях, а не только в списке ссылок на объект). Объекты с одинаковыми идентификаторами являются общими ссылками.

 На следующем рисунке показан список ссылок на объекты для выбранного элемента с отображением идентификаторов.

 ![Ссылки на объекты с отображаемыми идентификаторами](../profiling/media/js_mem_shared_refs.png "JS_Mem_Shared_Refs")

## <a name="show-built-in-objects"></a>Отображение встроенных объектов
 По умолчанию в представлениях "Доминаторы" и "Типы" отображаются только объекты, которые создаются в приложении. Это помогает отфильтровать ненужные сведения и изолировать проблемы, связанные с приложением. Однако иногда бывает удобно посмотреть все объекты, созданные для приложения средой выполнения JavaScript.

 Для вывода на экран этих объектов выберите **Показать встроенные объекты** в ![раскрывающемся списке параметров в анализаторе памяти](../profiling/media/js_mem_settings.png "JS_Mem_Settings") в правом верхнем углу области.

## <a name="save-diagnostic-session-files"></a>Сохранение файлов диагностических сеансов
 Сводки диагностических снимков, а также связанные представления сведений, сохраняются в файлах *DIAGSESSION*. **Обозреватель решений** отображает предыдущие диагностические сеансы в папке диагностических сеансов. В **обозревателе решений** можно открыть предыдущие сеансы, удалить или переименовать файлы.

## <a name="associate-source-code-with-memory-usage-data"></a>Associate source code with memory usage data
 Чтобы изолировать раздел кода с проблемой памяти, воспользуйтесь следующими методами.

- Найдите имена классов и идентификаторы элементов DOM в представлении данных и представлении дифференциала.

- Найдите строковые значения в представлениях данных и дифференциала, которые могут быть связаны с исходным кодом.

- Используйте команду [Поиск объекта в дереве объектов](#find-an-object-in-the-object-tree) , чтобы пройти вверх по дереву объекта. Возможно, это поможет идентифицировать связанный исходный код.

- Добавьте команды анализатора памяти в исходный код.

  В исходном коде можно использовать следующие команды.

- `console.takeHeapSnapshot` делает снимок кучи, который отображается в анализаторе памяти JavaScript. Эта команда является частью набора [JavaScript Console commands](../debugger/javascript-console-commands.md).

- `performance.mark` устанавливает пользовательскую отметку (перевернутый треугольник), который отображается на временной шкале графа памяти в сводном представлении во время выполнения приложения. Эта команда принимает один строковый аргумент, который представляет описание события и отображается в виде всплывающей подсказки на графе памяти. Этот описание не может быть длиннее 100 знаков.

> [!TIP]
> Команду `console.takeHeapSnapshot` можно использовать для ускорения анализа повторяющихся сценариев использования памяти.

 Эти команды создают исключение, если добавить их в приложение и запустить приложение вне анализатора памяти JavaScript. Однако перед использованием команды можно проверить, существует ли она. (Команды не существуют на раннем этапе запуска сеанса.) Чтобы узнать, можно ли осуществить безопасный вызов `takeHeapSnapshot`, используйте следующий код:

```javascript
if (console && console.takeHeapSnapshot) {
    console.takeHeapSnapshot();
}
```

 Чтобы узнать, можно ли осуществить безопасный вызов `performance.mark`, используйте следующий код:

```javascript
if (performance && performance.mark) {
    performance.mark("message_string");
}

```

 Ниже показан граф памяти с несколькими пользовательскими отметками и всплывающей подсказкой для текущей выбранной отметки, для которой строковый аргумент `performance.mark` имеет значение "data generated":

 ![Использование метки профилирования](../profiling/media/js_mem_performance_marks.png "JS_Mem_Performance_Marks")

## <a name="tips-to-identify-memory-issues"></a>Советы по выявлению проблем с использованием памяти

- Следуйте рабочему процессу, описанному в разделе [Локализация утечки памяти](#isolate-a-memory-leak), и используйте фильтр **Объекты, оставшиеся после снимка №\<number>** в разностном представлении, чтобы выявить вероятных кандидатов, вызывающих утечки памяти.

- Команду [Поиск объекта в дереве объектов](#find-an-object-in-the-object-tree) При помощи представления можно узнать, где в иерархии памяти находятся ссылки на объект. Представление "Корни" показывает как объект связан с глобальным объектом, из-за которого невозможно удаление сборщиком мусора.

- Когда не удается установить причину проблем с памятью, можно использовать разные представления ("Доминаторы" и "Типы") для поиска совпадений, в особенности для того найти один или несколько объектов, которые содержат ссылки на множество других объектов, показанных в представлении.

- Попробуйте найти объекты, которые случайно сохраняются в памяти после перехода пользователя на новую страницу, что является распространенной причиной проблем с памятью. Пример:

  - Например, к этой проблеме может привести неправильное использование функции [URL.CreateObjectUrl](https://developer.mozilla.org/docs/Web/API/URL/createObjectURL) .

  - Некоторые объекты могут содержать метод `dispose` и рекомендации по использованию. Например, необходимо вызвать `dispose` для [WinJS.Binding.List](/previous-versions/windows/apps/hh700774\(v\=win.10\)) , если вы вызываете `createFiltered` метод списка и затем уходите со страницы.

  - Возможно, потребуется удалить один или несколько прослушивателей событий. Дополнительные сведения см. в разделе [View DOM event listeners](../debugger/quickstart-debug-html-and-css.md).

- Посмотрите последнюю часть [этого видео](https://channel9.msdn.com/Events/Build/2013/3-316) с конференции Build 2013 об анализаторе памяти JavaScript.

- См. статью [Управление памятью в приложениях универсальной платформы Windows](/archive/msdn-magazine/2012/windows-8-special-issue/javascript-managing-memory-in-windows-store-apps).

- Попробуйте временно изменить код, чтобы изолировать проблемы. Например, можно сделать следующее:

  - используйте команды `console.takeSnapshot` и `performance.mark`анализатора памяти. (См. раздел [Associate source code with memory usage data](#associate-source-code-with-memory-usage-data)).

    С помощью этих команд можно изолировать проблемы, которые не удается изолировать вручную с помощью снимка кучи.

  - Создайте тестовый объект и отслеживайте его в представлениях анализатора памяти JavaScript, например в представлении "Типы". Например, можно прикрепить очень большой объект к другому объекту, чтобы увидеть, был ли определенный объект или элемент удален сборщиком мусора.