---
title: Анализ использования ЦП | Документация Майкрософт
ms.custom: seodec18
ms.date: 11/04/2018
ms.technology: vs-ide-debug
ms.topic: conceptual
ms.assetid: 7501a20d-04a1-480f-a69c-201524aa709d
author: mikejo5000
ms.author: mikejo
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 4b3d4d6a352d2ff1b71796d64c34992af493867a
ms.sourcegitcommit: 708f77071c73c95d212645b00fa943d45d35361b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/07/2018
ms.locfileid: "53063267"
---
# <a name="analyze-cpu-usage"></a>Анализ использования ЦП 

Хороший способ начать исследование проблем производительности в приложении — определить загрузку ЦП. Средство оценки производительности **Загрузка ЦП** показывает время и процент ресурсов ЦП, затраченные на выполнение кода в приложениях C++, C#/Visual Basic и JavaScript. 

Средство **Загрузка ЦП** может выполняться для открытого проекта Visual Studio, для установленного приложения Microsoft Store либо подключаться к запущенному приложению или процессу. Вы можете запустить это средство на локальном или удаленном компьютерах либо в симуляторе или эмуляторе. Дополнительные сведения см. в разделе [Запуск средств профилирования с отладчиком или без него](../profiling/running-profiling-tools-with-or-without-the-debugger.md). 

Средство **Загрузка ЦП** можно запустить с отладкой или без нее. В отладчике можно включить и отключать профилирование ЦП, а также просмотреть распределение загрузки ЦП по отдельным функциям. Вы можете просмотреть результаты загрузки ЦП при приостановленном выполнении, например в точке останова.  

Ниже показано, как использовать средство **Загрузка ЦП** без отладчика, используя **Профилировщик производительности** Visual Studio. В примерах используется сборка выпуска на локальном компьютере. Сборки выпуска дают наилучшее представление о фактической производительности приложения. Сведения об анализе загрузки ЦП с использованием сборок отладки см. в разделе [Руководство по профилированию производительности для начинающих](../profiling/beginners-guide-to-performance-profiling.md).

Обычно выполнение установленного приложения лучше всего отражается на локальном компьютере. Для приложений Windows Phone сбор данных непосредственно из устройства позволяет получить наиболее точные данные. Чтобы собрать данные с удаленного устройства, запустите приложение непосредственно на устройстве, не используя подключение к удаленному рабочему столу. 

>[!NOTE]
>Для использования [Профилировщика производительности](../profiling/profiling-feature-tour.md) требуется Windows 7 или более поздней версии.
  
##  <a name="collect-cpu-usage-data"></a>Сбор данных об использовании ЦП  
  
1. В проекте Visual Studio установите для решения конфигурацию **Выпуск** и выберите цель развертывания **Локальный компьютер**.  
  
    ![Выбор выпуска и локального компьютера](../profiling/media/cpuuse_selectreleaselocalmachine.png "Выбор выпуска и локального компьютера")  
  
1. Выберите **Отладка** > **Профилировщик производительности**.  
  
1. В разделе **Доступные инструменты** выберите **Загрузка ЦП** и затем **Запустить**.  
  
    ![Выбор загрузки ЦП](../profiling/media/cpuuse_lib_choosecpuusage.png "Выбор загрузки ЦП")  
  
4. После запуска приложения начинается диагностический сеанс, который отображает данные о загрузке ЦП. Когда вы закончите сбор данных, выберите **Остановить сбор данных**.  
  
   ![Остановка сбора данных о загрузке ЦП](../profiling/media/cpu_use_wt_stopcollection.png "Остановка сбора данных о загрузке ЦП")  
  
   Инструмент "Использование ЦП" анализирует данные и отображает отчет.  
  
   ![Отчет о загрузке ЦП](../profiling/media/cpu_use_wt_report.png "Отчет о загрузке ЦП")  
  

## <a name="analyze-the-cpu-usage-report"></a>Анализ отчета об использовании ЦП  
  
Диагностический отчет отсортирован по параметру **Общая активность ЦП** в порядке убывания. Измените порядок сортировки или столбец сортировки, выбирая заголовки столбцов. Используйте раскрывающийся список **Фильтр**, чтобы выбрать или отменить выбор отображаемых потоков, и поле **Поиск**, чтобы найти определенный поток или узел. 

###  <a name="BKMK_Call_tree_data_columns"></a> Столбцы данных о загрузке ЦП  

|||  
|-|-|  
|**Общая активность ЦП [единица измерения, %]**|![Уравнение для данных процента общей активности](../profiling/media/cpu_use_wt_totalpercentequation.png "CPU_USE_WT_TotalPercentEquation")<br /><br /> Миллисекунды и процент ресурсов ЦП, потраченные на вызовы функции и функций, которые вызывала данная функция, в выбранный период времени. Это отличается от графика временной шкалы **Использование ЦП**, который сравнивает общую активность ЦП за период времени с общими доступными ресурсами ЦП.|  
|**Собственная активность ЦП [единица измерения, %]**|![Уравнение для процента собственной активности](../profiling/media/cpu_use_wt_selflpercentequation.png "CPU_USE_WT_SelflPercentEquation")<br /><br /> Миллисекунды и процент ресурсов ЦП, потраченные на вызовы функции в выбранный период времени, за исключением функций, которые вызывала данная функция.|  
|**Модуль**|Имя модуля, содержащего функцию.   
  
###  <a name="BKMK_The_CPU_Usage_call_tree"></a> Дерево вызовов средства "Использование ЦП" 

Чтобы просмотреть дерево вызовов, выберите родительский узел в отчете. Открывается страница **Загрузка CPU** с представлением **Вызывающий/вызываемый**. В раскрывающемся списке **Текущее представление** выберите **Дерево вызовов**.  
  
####  <a name="BKMK_Call_tree_structure"></a> Структура дерева вызовов  

 ![Структура дерева вызовов](../profiling/media/cpu_use_wt_getmaxnumbercalltree_annotated.png "Структура дерева вызовов")  
  
|||  
|-|-|  
|![Шаг 1](../profiling/media/procguid_1.png "ProcGuid_1")|Узел верхнего уровня в деревьях вызовов для использования ЦП представляет собой псевдоузел.|  
|![Шаг 2](../profiling/media/procguid_2.png "ProcGuid_2")|В большинстве приложений при отключенном параметре **Показать внешний код** узлом второго уровня является узел **[Внешний код]**. Он содержит код системы и инфраструктуры, запускающий и останавливающий приложение, отрисовывающий пользовательский интерфейс, управляющий планированием потоков и предоставляющий приложению другие низкоуровневые службы.|  
|![Шаг 3](../profiling/media/procguid_3.png "ProcGuid_3")|Дочерними элементами узла второго уровня являются методы пользовательского кода и асинхронные подпрограммы, которые вызываются или создаются кодом системы и инфраструктуры на втором уровне.|  
|![Шаг 4](../profiling/media/procguid_4.png "ProcGuid_4")|Дочерние узлы метода содержат данные только для вызова родительского метода. Если параметр **Показать внешний код** отключен, методы приложения также могут содержать узел **[Внешний код]** .|  
  
####  <a name="BKMK_External_Code"></a> Внешний код  

 Функции системы и платформы, исполняемые вашим кодом, называются *внешним кодом*. Функции внешнего кода запускают и останавливают приложение, отрисовывают пользовательский интерфейс, управляют потоками и предоставляют приложению другие низкоуровневые службы. В большинстве случаев внешний код вас интересовать не будет, поэтому дерево вызовов средства "Использование ЦП" собирает внешние функции пользовательского метода в один узел **[Внешний код]**.  
  
 Чтобы посмотреть пути к вызовам внешнего кода, на главной странице диагностического отчета выберите **Показать внешний код** в раскрывающемся списке **Фильтр** и выберите **Применить**. Представление **Дерево вызовов** на странице **Загрузка ЦП** развертывает вызовы внешнего кода.  
  
 ![Показать внешний код](../profiling/media/cpu_use_wt_filterview.png "Показать внешний код")  
  
 Многие цепочки вызовов имеют глубокий уровень вложенности, поэтому ширина цепочки может превышать отображаемую ширину столбца **Имя функции**. Тогда имена функций отображаются в виде **...**.  
  
 ![Вложенный внешний код в дереве вызовов](../profiling/media/cpu_use_wt_showexternalcodetoowide.png "Вложенный внешний код в дереве вызовов")  
  
 Чтобы найти имя нужной функции, используйте поле поиска. Наведите указатель мыши на выбранную строку или используйте горизонтальную полосу прокрутки для просмотра данных.  
  
 ![Поиск вложенного внешнего кода](../profiling/media/cpu_use_wt_showexternalcodetoowide_found.png "Поиск вложенного внешнего кода")  
  
###  <a name="BKMK_Asynchronous_functions_in_the_CPU_Usage_call_tree"></a> Асинхронные функции в дереве вызовов средства "Использование ЦП"  

 Если компилятор обнаруживает асинхронный метод, он создает скрытый класс для контроля выполнения этого метода. По сути, этот класс представляет собой конечный автомат. Класс содержит созданные компилятором функции, которые асинхронно вызывают исходные методы, а также обратные вызовы, планировщик и итераторы, необходимые для их выполнения. При вызове исходного метода родительским методом компилятор удаляет метод из контекста выполнения родительского метода и выполняет методы скрытого класса в контексте кода системы и платформы, который управляет выполнением приложения. Асинхронные методы часто, но не всегда выполняются в отдельном потоке (или в нескольких потоках). Этот код отображается в дереве вызовов средства **Загрузка ЦП** в виде дочерних элементов узла **[Внешний код]** сразу под верхним узлом дерева.  

В следующем примере два первых узла в узле **[Внешний код]** представляют собой созданные компилятором методы класса конечного автомата. Третий узел является вызовом исходного метода. 
  
![Асинхронный узел](media/cpu_use_wt_getmaxnumberasync_selected.png "Асинхронный узел")  

Разверните созданные методы, чтобы узнать, как это работает:

![Развернутый асинхронный узел](media/cpu_use_wt_getmaxnumberasync_expandedcalltree.png "Развернутый асинхронный узел")  

- `MainPage::GetMaxNumberAsyncButton_Click` просто управляет списком значений задач, вычисляет максимальное значение на основе результатов и отображает выходные данные.
  
- `MainPage+<GetMaxNumberAsyncButton_Click>d__3::MoveNext` показывает время ЦП, затраченное на планирование и запуск 48 задач, которые являются оболочкой вызова `GetNumberAsync`.
  
- `MainPage::<GetNumberAsync>b__b` показывает время ЦП, затраченное на выполнение задач, которые вызывают `GetNumber`.
