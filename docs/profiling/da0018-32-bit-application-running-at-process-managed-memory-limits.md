---
title: 'DA0018: 32-разрядное приложение, выполняющееся с ограничениями управляемой памяти процесса | Документация Майкрософт'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.performance.18
- vs.performance.DA0018
- vs.performance.rules.DA0018
ms.assetid: 98eb2d96-f92f-42f9-915c-e5ac2330ffbf
author: mikejo5000
ms.author: mikejo
manager: jmartens
monikerRange: vs-2017
ms.workload:
- dotnet
ms.openlocfilehash: f5730e96a47e7e931606269341d5f1cca302a0e5
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99886396"
---
# <a name="da0018-32-bit-application-running-at-process-managed-memory-limits"></a>DA0018. 32-битное приложение выполняется с ограничениями управляемой памяти процесса

|Элемент|Значение|
|-|-|
|Идентификатор правила|DA0018|
|Категория|Использование средств профилирования|
|Способ профилирования|Дискретизация|
|Сообщение|Распределения управляемой памяти практически достигли стандартного ограничения для 32-разрядного процесса. Возможно, память вашего приложения ограничена.|
|Тип правила|Предупреждение|

 При профилировании с помощью выборки, памяти .NET или методов разрешения конфликтов ресурсов необходимо собрать минимум 10 выборок, чтобы активировать это правило.

## <a name="cause"></a>Причина:
 Системные данные, собранные во время профилирования, указывают на то, что кучи памяти .NET Framework близки к максимальному размеру управляемых куч в 32-разрядном процессе. Максимальный размер — это значение по умолчанию. Он рассчитывается по общему объему адресного пространства процесса, который может быть выделен для байтов исключительного пользования. Результат определяется как максимальное наблюдаемое значение размера куч за время активности профилируемого процесса. Рекомендуется повторить профилирование, используя метод профилирования памяти .NET и оптимизировать использование управляемых ресурсов приложением.

 Когда размер управляемых куч приближается к ограничению, заданному по умолчанию, процесс автоматической сборки мусора начинает запускаться чаще. Это увеличивает затраты на управление памятью.

 Это правило применяется только для 32-разрядных приложений, выполняющихся на 32-разрядных компьютерах.

## <a name="rule-description"></a>Описание правила
 Среда CLR Microsoft .NET обеспечивает автоматический механизм управления памятью, использующий сборщик мусора для удаления из памяти объектов, которые приложение больше не использует. Сборщик мусора ориентирован на поколение, исходя из той предпосылки, что многие выделения памяти являются краткосрочными. Например, срок жизни локальных переменных должен быть небольшим. Вновь созданные объекты сначала находятся в поколении 0 (gen 0), а затем переходят в поколение 1, если они сохраняются после выполнения сборки мусора и, наконец, переходят в поколение 2, если приложение по-прежнему использует их.

 Управляемые объекты, размер которых превышает 85 КБ, размещаются в кучи для массивных объектов, где они реже подвергаются процедуре сборки мусора и уплотнения, чем более мелкие объекты. Крупные объекты размещаются отдельно, так как предполагается, что они являются более постоянными, а смешивание постоянных и массивных объектов с маленькими и часто размещаемыми объектами может привести к очень сильной фрагментации кучи.

 По мере того как общий размер управляемых куч приближается к ограничению, заданному по умолчанию, затраты на управление памятью возрастают до такого значения, когда они начинают влиять на время отклика и масштабируемость приложения.

## <a name="how-to-investigate-a-warning"></a>Изучение причин предупреждения
 Дважды щелкните сообщение в окне "Список ошибок", чтобы перейти к представлению [Метки](../profiling/marks-view.md). Найдите столбцы **Память CLR .NET\\Байт во всех кучах** и **Всего фиксировано байт**. Определите, есть ли такие этапы выполнения программы, когда распределение управляемой памяти больше, чем на других этапах. Сравните значения в столбце **Байт во всех кучах** с частотой сборки мусора, которая отображается в столбцах **Память CLR .NET\\Сборов мусора для поколения 0**, **Память CLR .NET\\Сборов мусора для поколения 1** и **Память CLR .NET\\Сборов мусора для поколения 2**, чтобы определить, влияет ли схема распределения управляемой памяти на частоту сборки мусора.

 В приложении .NET Framework среда CLR ограничивает общий размер управляемых куч величиной чуть меньше половины максимального размера закрытой части адресного пространства процесса. Для 32-разрядных процессов, выполняющихся на 32-разрядном компьютере, верхний предел размера закрытой части адресного пространства процесса — 2 ГБ. По мере того, как общий размер управляемых куч начинает приближаться к предельному значению, заданному по умолчанию, затраты на управление памятью увеличиваются, что может привести к снижению производительности приложения.

 Если затраты на управление памятью становятся проблемой, рассмотрите возможность применения следующих мер.

- Оптимизация использования приложением ресурсов управляемой памяти.

   -или-

- Сокращение архитектурных ограничений на максимальный размер виртуальной памяти для 32-разрядных процессов.

  Чтобы оптимизировать использование приложением ресурсов управляемой памяти, собирайте данные о выделении управляемой памяти в сеансе профилирования выделения памяти .NET. Для лучшего понимания схемы выделения памяти в приложении просмотрите отчеты [Представления данных в памяти .NET](../profiling/dotnet-memory-data-views.md).

  Используйте [Представление "Время существования объекта"](../profiling/object-lifetime-view.md) чтобы определить, какие объекты данных программы остаются в поколении, а затем из него удаляются.

  Используйте [Представление "Выделения"](../profiling/dotnet-memory-allocations-view.md) для определения путей выполнения, которые приводят к появлению таких выделений памяти.

  Дополнительные сведения о повышении производительности сборки мусора см. в технической статье по .NET Framework на веб-сайте MSDN [Сведения о повышении производительности сборки мусора](/previous-versions/dotnet/articles/ms973837(v=msdn.10)).

  Чтобы ослабить архитектурные ограничения виртуальной памяти на размер закрытой части адресного пространства процесса, попытайтесь запустить этот 32-разрядный процесс на 64-разрядном компьютере.  32-разрядный процесс на 64-разрядном компьютере может получить до 4 ГБ виртуальной памяти исключительного пользования.

  64-разрядный процесс, выполняющийся на 64-разрядном компьютере, может получить до 8 ТБ виртуальной памяти. Рекомендуется перекомпилировать приложение для выполнения его в качестве собственного 64-разрядного приложения. Это правило используется только для сведения и не требует обязательных действий по исправлению.
