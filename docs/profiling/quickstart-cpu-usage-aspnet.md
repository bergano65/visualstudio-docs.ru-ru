---
title: Анализ данных о загрузке ЦП (ASP.NET)
description: Измерение производительности приложения в приложениях ASP.NET с помощью средства диагностики "Загрузка ЦП"
ms.custom: mvc
ms.date: 12/05/2017
ms.technology: vs-ide-debug
ms.topic: quickstart
helpviewer_keywords:
- Profiling Tools, quick start
- Diagnostics Tools, CPU Usage
author: mikejo5000
ms.author: mikejo
manager: douge
ms.workload:
- aspnet
ms.openlocfilehash: 00704c236e8e0c0453a36add4cb4603b76c31bd9
ms.sourcegitcommit: 0aafcfa08ef74f162af2e5079be77061d7885cac
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2018
ms.locfileid: "34477292"
---
# <a name="quickstart-analyze-cpu-usage-data-in-visual-studio-aspnet"></a>Краткое руководство. Анализ данных по использованию ЦП в Visual Studio (ASP.NET)

Visual Studio предоставляет множество эффективных возможностей для анализа проблем с производительностью приложения. В этой статье вы ознакомитесь с некоторыми основными возможностями. Мы рассмотрим средство, позволяющее выявлять узкие места производительности, возникающие из-за высокой загрузки ЦП. Средства диагностики поддерживаются для разработки приложений .NET в Visual Studio, включая ASP.NET, и для разработки машинного кода или кода C++.

Центр диагностики предоставляет различные возможности по запуску сеансов диагностики и управлению ими. Если описываемое здесь средство **Загрузка ЦП** не предоставляет необходимые данные, можно воспользоваться [другими средствами профилирования](../profiling/Profiling-Tools.md), предоставляющими другие виды информации, которая может оказаться полезной. Как правило, проблемы производительности приложения могут вызываться другими компонентами помимо ЦП, такими как память, отрисовка пользовательского интерфейса или время запроса сети.

> [!NOTE]
> Для .NET Core и ASP.NET Core средство загрузки ЦП в настоящее время предоставляет неточные результаты для переносимых PBD-файлов. Используйте вместо этого полные PDB-файлы.

## <a name="create-a-project"></a>Создание проекта

1. В Visual Studio последовательно выберите **Файл > Создать проект**.

1. В разделе **Visual C#** выберите **Веб**, а затем в средней области выберите **Веб-приложение ASP.NET (.NET Framework)**.

    > [!NOTE]
    > Средство анализа загрузки ЦП в настоящее время не поддерживается в ASP.NET Core.

1. Введите имя, например **MyProfilingApp_MVC**, и нажмите кнопку **ОК**.

1. В открывшемся диалоговом окне выберите в средней области **MVC**, а затем нажмите кнопку **ОК**.

    Visual Studio создаст проект. В обозревателе решений (правая область) отображаются файлы проекта.

1. В обозревателе решений щелкните папку Models правой кнопкой мыши и выберите команду **Добавить** > **Класс**.

1. Назовите новый класс `Data.cs` и нажмите кнопку **Добавить**.

1. В обозревателе решений откройте файл `Models/Data.cs` и добавьте в его начало следующий оператор `using`:

    ```csharp
    using System.Threading;
    ```

1. В файле Data.cs замените код

    ```csharp
    public class Data
    {
    }
    ```

    следующим кодом:

    ```csharp
    public class ServerClass
    {
        const int MIN_ITERATIONS = int.MaxValue / 1000;
        const int MAX_ITERATIONS = MIN_ITERATIONS + 10000;

        long m_totalIterations = 0;
        readonly object m_totalItersLock = new object();
        // The method that will be called when the thread is started.
        public void GenerateData()
        {
            Console.WriteLine(
                "ServerClass.InstanceMethod is running on another thread.");

            var x = GetNumber();
        }

        private int GetNumber()
        {
            var rand = new Random();
            var iters = rand.Next(MIN_ITERATIONS, MAX_ITERATIONS);
            var result = 0;
            lock (m_totalItersLock)
            {
                m_totalIterations += iters;
            }
            // we're just spinning here  
            // and using Random to frustrate compiler optimizations  
            for (var i = 0; i < iters; i++)
            {
                result = rand.Next();
            }
            return result;
        }
    }

    public class Simple
    {
        int numberOfThreads = 200;

        public Simple()
        {
            for (int i = 0; i < numberOfThreads; i++)
            {
                CreateThreads();
            }
        }
        public static void CreateThreads()
        {
            ServerClass serverObject = new ServerClass();

            Thread InstanceCaller = new Thread(new ThreadStart(serverObject.GenerateData));
            // Start the thread.
            InstanceCaller.Start();

            Console.WriteLine("The Main() thread calls this after "
                + "starting the new InstanceCaller thread.");

        }

        public int GetData()
        {
            // Not returning any meaningful data.
            return numberOfThreads;
        }
    }
    ```

1. В обозревателе решений откройте файл Controller/HomeControllers.cs и замените код

    ```csharp
    public ActionResult About()
    {
        ViewBag.Message = "Your application description page.";

        return View();
    }
    ```

    следующим кодом:

    ```csharp
    public ActionResult About()
    {
        Models.Simple s = new Models.Simple();

        ViewBag.Message = "Your application description page.";

        return View(s.GetData());
    }
    ```

##  <a name="BKMK_Quick_start__Collect_diagnostic_data"></a> Шаг 1. Сбор данных профилирования 
  
1.  Сначала установите точку останова в приложении в следующей строке кода в конструкторе `Simple`:

    `for (int i = 0; i < 200; i++)`

    Чтобы установить точку останова, щелкните во внешнем поле слева от строки кода.

1.  Затем установите вторую точку останова в закрывающей фигурной скобке в конце конструктора `Simple`:

     ![Установка точек останова для профилирования](../profiling/media/quickstart-cpu-usage-breakpoints-aspnet.png)

    > [!TIP]
    > С помощью двух точек останова можно ограничить сбор данных частями кода, которые требуется проанализировать.
  
1.  Окно **Средства диагностики** должно отображаться, если вы не отключали эту функцию. Чтобы снова открыть окно, щелкните **Отладка | Окна | Показать средства диагностики**.

1.  Щелкните **Отладка | Начать отладку** (**Запустить** на панели инструментов или **F5**).

1.  По завершении загрузки приложения щелкните ссылку **About** (Сведения) в верхней части веб-страницы, чтобы запустить новый код.

1.  Просмотрите появившееся представление **Сводка** Средств диагностики.

1.  Приостановив отладчик, включите сбор данных по загрузке ЦП, выбрав параметр **Запись профиля ЦП**, а затем откройте вкладку **Загрузка ЦП**.

     ![Средства диагностики, "Включить профилирование ЦП"](../profiling/media/quickstart-cpu-usage-summary.png)

     Когда сбор данных включен, на кнопке записи отображается красный кружок.

     При выборе параметра **Запись профиля ЦП** Visual Studio начнет записывать функции и сведения о времени их выполнения, а также будет выводить временной график, с помощью которого можно сосредоточить внимание на определенных частях сеанса профилирования. Эти собранные данные можно просматривать только в том случае, если приложение останавливается в точке останова.

6.  Нажмите клавишу F5, чтобы запустить приложение до второй точки останова.

     Теперь у вас есть данные о производительности приложения именно для той области кода, которая выполняется между двумя точками останова.

     Профилировщик начинает подготавливать данные потока. Дождитесь завершения этой операции.
  
     Средство "Загрузка ЦП" выведет отчет на вкладке **Загрузка ЦП**.

     На этом этапе можно начать анализировать данные.

## <a name="Step2"></a> Шаг 2. Анализ данных о загрузке ЦП

Мы рекомендуем начать анализ данных с проверки списка функций на вкладке "Загрузка ЦП" и выявления функций, выполняющих основную часть работы, а затем подробно рассмотреть каждую из этих функций.

1. В списке функций изучите функции, которые выполняют большую часть работы.

     ![Вкладка "Загрузка ЦП" в средствах диагностики](../profiling/media/quickstart-cpu-usage-cpu-aspnet.png)

    > [!TIP]
    > Функции перечисляются, начиная с тех, которые выполняют большую часть работы (а не в порядке вызова). Это позволяет быстро находить функции, которые выполнялись дольше всего.

2. В списке функций дважды щелкните функцию `MyProfilingApp_MVC.Models.ServerClass::GetNumber`.

    В левой области откроется представление **Вызывающий/вызываемый**. 

    ![Представление "Вызывающий/вызываемый" в средствах диагностики](../profiling/media/quickstart-cpu-usage-caller-callee-aspnet.png)

    В этом представлении выбранная функция отображается в заголовке и в поле **Текущая функция** (в этом примере `ServerClass::GetNumber`). Функция, вызывавшая текущую функцию, отображается в левой части окна в разделе **Вызывающая функция**, а все функции, вызываемые текущей функцией, отображаются в поле **Вызываемые функции** справа. (Можно выбрать любое поле, чтобы изменить текущую функцию.)

    В этом представлении показано общее время (мс) и доля общего времени выполнения приложения, затраченного на выполнение функции.

    В поле **Тело функции** также показан общий объем времени (и доля времени), затраченного в теле функции за исключением времени, затраченного в вызываемых и вызывающих функциях. (В этом примере в теле функции затрачено 2220 из 2235 мс, а остальное время (меньше 20 мс) затрачено во внешнем коде, вызванном этой функцией.) Фактические значения будут отличаться в зависимости от среды.

    > [!TIP]
    > Высокие значения в поле **Тело функции** могут свидетельствовать о проблемах производительности внутри самой функции.

## <a name="next-steps"></a>Следующие шаги

- [Анализируйте использование памяти](../profiling/memory-usage.md) для выявления узких мест производительности.
- [Анализируйте загрузку ЦП](../profiling/cpu-usage.md) для получения более подробных сведений о загрузке ЦП.
- Анализируйте загрузку ЦП без подключения отладчика или путем указания выполняющегося приложения. Дополнительные сведения см. в разделе [Сбор данных профилирования без отладки](../profiling/running-profiling-tools-with-or-without-the-debugger.md#collect-profiling-data-without-debugging) и в статье [Выполнение средств профилирования с отладчиком и без него](../profiling/running-profiling-tools-with-or-without-the-debugger.md).

## <a name="see-also"></a>См. также  

 [Профилирование в Visual Studio](../profiling/index.md)  
 [Обзор возможностей профилирования](../profiling/profiling-feature-tour.md)
