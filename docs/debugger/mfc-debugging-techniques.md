---
title: Методы отладки MFC | Документация Майкрософт
description: Сведения о методах отладки программ MFC, таких как закодированные точки останова, трассировка, обнаружение утечек памяти, дампы памяти объектов и уменьшение размера программы.
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
f1_keywords:
- AfxEnableMemoryTracking
- CMemoryState
- delayFreeMemDF
- checkAlwaysMemDF
- vs.debug.mfc
- vs.debug.objects.dump
- vs.debug.memory.dump
- allocMemDF
- afxMemDF
dev_langs:
- CSharp
- VB
- FSharp
- C++
helpviewer_keywords:
- debugging [MFC]
ms.assetid: b154fc31-5e90-4734-8cbd-58dd9fe1f750
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: b4a3f0f675df70643876b7bb5480cb8c885d8854
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99845000"
---
# <a name="mfc-debugging-techniques"></a>Методы отладки MFC
Эти методы могут пригодиться при отладке программы MFC.

## <a name="in-this-topic"></a><a name="BKMK_In_this_topic"></a> Содержание раздела
[Функция AfxDebugBreak](#BKMK_AfxDebugBreak)

[Макрос TRACE](#BKMK_The_TRACE_macro)

[Обнаружение утечек памяти в MFC](#BKMK_Memory_leak_detection_in_MFC)

- [Отслеживание операций выделения памяти](#BKMK_Tracking_memory_allocations)

- [Включение диагностики памяти](#BKMK_Enabling_memory_diagnostics)

- [Получение снимков памяти](#BKMK_Taking_memory_snapshots)

- [Просмотр статистики памяти](#BKMK_Viewing_memory_statistics)

- [Получение дампов объектов](#BKMK_Taking_object_dumps)

  - [Интерпретация дампов памяти](#BKMK_Interpreting_memory_dumps)

  - [Настройка дампов объектов](#BKMK_Customizing_object_dumps)

  - [Сокращение размера отладочной сборки MFC](#BKMK_Reducing_the_size_of_an_MFC_Debug_build)

  - [Сборка приложения MFC с отладочной информацией для избранных модулей](#BKMK_Building_an_MFC_app_with_debug_information_for_selected_modules)

## <a name="afxdebugbreak"></a><a name="BKMK_AfxDebugBreak"></a> Функция AfxDebugBreak
MFC предоставляет особую функцию [AfxDebugBreak](/cpp/mfc/reference/diagnostic-services#afxdebugbreak) для жесткого задания точек останова в исходном коде:

```cpp
AfxDebugBreak( );
```

На платформах Intel `AfxDebugBreak` создает следующий код, останавливающий выполнение исходного кода, а не кода ядра:

```cpp
_asm int 3
```

На других платформах `AfxDebugBreak` просто вызывает `DebugBreak`.

Не забывайте удалять `AfxDebugBreak` при создании окончательного построения или используйте `#ifdef _DEBUG` до и после этих операторов.

[Содержание раздела](#BKMK_In_this_topic)

## <a name="the-trace-macro"></a><a name="BKMK_The_TRACE_macro"></a> Макрос TRACE
Чтобы сообщения программы отображались в [окне "Вывод"](../ide/reference/output-window.md)отладчика, можно применить макрос [ATLTRACE](/previous-versions/6xkxyz08(v=vs.140)) или MFC-макрос [TRACE](/previous-versions/6w95a4ha(v=vs.140)) . Подобно [утверждениям](../debugger/c-cpp-assertions.md), макросы трассировки активны только в отладочной версии программы, а в окончательной версии они исчезают после компиляции.

Следующие примеры показывают несколько способов применения макроса **TRACE** . Подобно `printf`макрос **TRACE** может обрабатывать несколько аргументов.

```cpp
int x = 1;
int y = 16;
float z = 32.0;
TRACE( "This is a TRACE statement\n" );

TRACE( "The value of x is %d\n", x );

TRACE( "x = %d and y = %d\n", x, y );

TRACE( "x = %d and y = %x and z = %f\n", x, y, z );
```

Макрос TRACE правильно обрабатывает параметры char\* и wchar_t\*. Следующие примеры демонстрируют использование макро TRACE вместе с различными типами строковых параметров.

```cpp
TRACE( "This is a test of the TRACE macro that uses an ANSI string: %s %d\n", "The number is:", 2);

TRACE( L"This is a test of the TRACE macro that uses a UNICODE string: %s %d\n", L"The number is:", 2);

TRACE( _T("This is a test of the TRACE macro that uses a TCHAR string: %s %d\n"), _T("The number is:"), 2);
```

Дополнительные сведения о макросе **TRACE** см. в разделе [Службы диагностики](/cpp/mfc/reference/diagnostic-services).

[Содержание раздела](#BKMK_In_this_topic)

## <a name="detecting-memory-leaks-in-mfc"></a><a name="BKMK_Memory_leak_detection_in_MFC"></a> Обнаружение утечек памяти в MFC
MFC предоставляет классы и функции, позволяющие обнаруживать выделенную, но не освобожденную память.

### <a name="tracking-memory-allocations"></a><a name="BKMK_Tracking_memory_allocations"></a> Отслеживание операций выделения памяти
В MFC вместо оператора [new](/previous-versions/tz7sxz99(v=vs.140)) для обнаружения утечек памяти можно применять макрос **DEBUG_NEW** . В отладочной версии программы `DEBUG_NEW` отслеживает имя файла и номер строки для каждого объекта, которому выделяется память. При компиляции окончательной версии программы `DEBUG_NEW` становится простой операцией **new** без данных об имени файла и номере строки. Таким образом, окончательная версия программы выполняется с необходимой скоростью.

Чтобы не переписывать программу, используя `DEBUG_NEW` вместо **new**, можно в исходных файлах определить данный макрос:

```cpp
#define new DEBUG_NEW
```

Если создается [дамп объекта](#BKMK_Taking_object_dumps), каждый объект, память для которого выделяется с помощью `DEBUG_NEW` , показывает файл и номер строки, где было выполнено выделение, позволяя точнее выявить источник утечки памяти.

В отладочной версии структуры MFC макрос `DEBUG_NEW` используется автоматически, но в коде, разумеется, нет. Если же требуется воспользоваться преимуществами `DEBUG_NEW`, то нужно явно указать `DEBUG_NEW` или **#define new** , как показано выше.

[Содержание раздела](#BKMK_In_this_topic)

### <a name="enabling-memory-diagnostics"></a><a name="BKMK_Enabling_memory_diagnostics"></a> Включение диагностики памяти
Прежде чем воспользоваться возможностями диагностики памяти, нужно включить диагностическую трассировку.

**Включение или выключение диагностики памяти**

- Вызовите глобальную функцию [AfxEnableMemoryTracking](/previous-versions/hzsxb6e8(v=vs.140)) , чтобы включить или выключить выделение памяти с диагностикой. Поскольку диагностика памяти обычно включена по умолчанию в отладочной библиотеке, эта функция будет применяться для ее временного отключения — это позволит увеличить скорость выполнения программы и уменьшит вывод диагностических сообщений.

  **Выбор функции диагностики памяти с помощью afxMemDF**

- Если необходимо обеспечить более точное управление функциями диагностики памяти, можно задать значение глобальной переменной MFC [afxMemDF](/previous-versions/ahe4a83t(v=vs.140)), которая позволяет выборочно включать и отключать отдельные функции. Эта переменная может принимать следующие значения, заданные перечисляемым типом **afxMemDF**:

  |Значение|Описание|
  |-----------|-----------------|
  |**allocMemDF**|Включает выделение памяти с диагностикой (по умолчанию).|
  |**delayFreeMemDF**|Задерживает освобождение памяти до выхода из программы при вызове `delete` или `free` . Это позволяет обеспечить выделение максимального объема памяти.|
  |**checkAlwaysMemDF**|Вызывает [AfxCheckMemory](/cpp/mfc/reference/diagnostic-services#afxcheckmemory) каждый раз при выделении или освобождении памяти.|

  Эти значения можно комбинировать с помощью логической операции ИЛИ, как показано ниже:

  ```C++
  afxMemDF = allocMemDF | delayFreeMemDF | checkAlwaysMemDF;
  ```

  [Содержание раздела](#BKMK_In_this_topic)

### <a name="taking-memory-snapshots"></a><a name="BKMK_Taking_memory_snapshots"></a> Получение снимков памяти

1. Создайте объект [CMemoryState](/previous-versions/visualstudio/visual-studio-2010/2ads32e2(v=vs.100)) и вызовите функцию-член [CMemoryState::Checkpoint](/cpp/mfc/reference/cmemorystate-structure#checkpoint) . В результате будет создан первый снимок памяти.

2. После того как программа выполнит операцию по выделению или освобождению памяти, создайте другой объект `CMemoryState` и вызовите функцию `Checkpoint` уже для него. Так получится второй снимок памяти.

3. Создайте третий объект `CMemoryState` и вызовите его функцию-член [CMemoryState::Difference](/cpp/mfc/reference/cmemorystate-structure#difference) , используя в качестве аргументов два предыдущих объекта `CMemoryState` . Если между двумя состояниями памяти есть различия, функция `Difference` вернет отличное от нуля значение. Это значение будет свидетельствовать о наличии неосвобожденных блоков памяти.

    Пример кода выглядит следующим образом:

    ```cpp
    // Declare the variables needed
    #ifdef _DEBUG
        CMemoryState oldMemState, newMemState, diffMemState;
        oldMemState.Checkpoint();
    #endif

        // Do your memory allocations and deallocations.
        CString s("This is a frame variable");
        // The next object is a heap object.
        CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );

    #ifdef _DEBUG
        newMemState.Checkpoint();
        if( diffMemState.Difference( oldMemState, newMemState ) )
        {
            TRACE( "Memory leaked!\n" );
        }
    #endif
    ```

    Обратите внимание, что операторы проверки памяти заключаются в блоки **#ifdef _DEBUG / #endif**, поэтому они компилируются только в отладочных версиях программы.

    Теперь, когда известно о наличии утечки, можно применить другую функцию-член — [CMemoryState::DumpStatistics](/cpp/mfc/reference/cmemorystate-structure#dumpstatistics) , по которой можно найти конкретное место утечки.

    [Содержание раздела](#BKMK_In_this_topic)

### <a name="viewing-memory-statistics"></a><a name="BKMK_Viewing_memory_statistics"></a> Просмотр статистики памяти
Функция [CMemoryState::Difference](/cpp/mfc/reference/cmemorystate-structure#difference) просматривает два объекта-состояния памяти и определяет, какие объекты не были освобождены из кучи между начальным и конечным состоянием. После того как сделаны снимки памяти и выполнено их сравнение с помощью функции `CMemoryState::Difference`, можно вызвать функцию [CMemoryState::DumpStatistics](/cpp/mfc/reference/cmemorystate-structure#dumpstatistics) и получить сведения о неосвобожденных объектах.

Рассмотрим следующий пример.

```cpp
if( diffMemState.Difference( oldMemState, newMemState ) )
{
    TRACE( "Memory leaked!\n" );
    diffMemState.DumpStatistics();
}
```

Образец дампа из примера выглядит следующим образом:

```cpp
0 bytes in 0 Free Blocks
22 bytes in 1 Object Blocks
45 bytes in 4 Non-Object Blocks
Largest number used: 67 bytes
Total allocations: 67 bytes
```

Свободные блоки — это блоки, освобождение которых задерживается, если `afxMemDF` была установлена в `delayFreeMemDF`.

Обычные блоки объектов, показанные во второй строке, остаются выделенными в куче.

Блоки без объектов включают в себя массивы и структуры, созданные с помощью `new`. В этом случае четыре блока без объектов были созданы в куче, но не освобождены.

`Largest number used` показывает наибольшее количество памяти, используемой программой в любое время.

`Total allocations` показывает общее количество памяти, используемой программой.

[Содержание раздела](#BKMK_In_this_topic)

### <a name="taking-object-dumps"></a><a name="BKMK_Taking_object_dumps"></a> Получение дампов объектов
В программе MFC можно использовать функцию [CMemoryState::DumpAllObjectsSince](/cpp/mfc/reference/cmemorystate-structure#dumpallobjectssince) для помещения в дамп описания всех объектов кучи, которые не были освобождены. `DumpAllObjectsSince` помещает в дамп все объекты, размещенные с момента последней проверки состояния памяти [CMemoryState::Checkpoint](/cpp/mfc/reference/cmemorystate-structure#checkpoint). Если вызова `Checkpoint` не было, `DumpAllObjectsSince` отображает все объекты и не-объекты, находящиеся в памяти на данный момент.

> [!NOTE]
> Перед тем как использовать функцию создания дампа объектов MFC, необходимо [включить диагностическую трассировку](#BKMK_Enabling_memory_diagnostics).

> [!NOTE]
> MFC автоматически отображает все потерянные объекты при выходе из программы, поэтому в точке выхода не нужно создавать для этого дополнительный код.

Следующий код — тест на утечку памяти путем сравнения двух состояний памяти и отображения всех объектов, если таковая обнаружилась.

```cpp
if( diffMemState.Difference( oldMemState, newMemState ) )
{
    TRACE( "Memory leaked!\n" );
    diffMemState.DumpAllObjectsSince();
}
```

Содержимое дампа выглядит следующим образом:

```cmd
Dumping objects ->

{5} strcore.cpp(80) : non-object block at $00A7521A, 9 bytes long
{4} strcore.cpp(80) : non-object block at $00A751F8, 5 bytes long
{3} strcore.cpp(80) : non-object block at $00A751D6, 6 bytes long
{2} a CPerson at $51A4

Last Name: Smith
First Name: Alan
Phone #: 581-0215

{1} strcore.cpp(80) : non-object block at $00A7516E, 25 bytes long
```

Числа в фигурных скобках в начале большинства строк указывают порядок размещения объектов в памяти. Объект, размещенный в последнюю очередь, имеет наибольший номер и появляется вверху дампа.

Чтобы извлечь из дампа объекта максимальное количество сведений, можно переопределить функцию-член `Dump` любого объекта, производного от `CObject`, чтобы настроить дамп объекта оптимальным образом.

Можно установить точку останова на определенном выделении памяти, задав глобальной переменной `_afxBreakAlloc` значение, показанное в фигурных скобках. При перезапуске программы отладчик остановит выполнение именно там, где происходит это выделение памяти. Теперь можно посмотреть стек вызовов и проанализировать, как программа дошла до этого места.

В библиотеке времени выполнения языка C тоже есть подобная функция, [_CrtSetBreakAlloc](/cpp/c-runtime-library/reference/crtsetbreakalloc), которая применяется для выделений памяти во время выполнения в языке C.

[Содержание раздела](#BKMK_In_this_topic)

#### <a name="interpreting-memory-dumps"></a><a name="BKMK_Interpreting_memory_dumps"></a> Интерпретация дампов памяти
Рассмотрим этот дамп объекта более подробно:

```cmd
{5} strcore.cpp(80) : non-object block at $00A7521A, 9 bytes long
{4} strcore.cpp(80) : non-object block at $00A751F8, 5 bytes long
{3} strcore.cpp(80) : non-object block at $00A751D6, 6 bytes long
{2} a CPerson at $51A4

Last Name: Smith
First Name: Alan
Phone #: 581-0215

{1} strcore.cpp(80) : non-object block at $00A7516E, 25 bytes long
```

Программа, которая создала этот дамп, выделяла память явным образом только дважды — один раз в стеке, а другой раз в куче:

```cpp
// Do your memory allocations and deallocations.
CString s("This is a frame variable");
// The next object is a heap object.
CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );
```

`CPerson` получает три аргумента — указатели на тип `char`, используемые для инициализации переменных-членов `CString` . В дампе памяти объект `CPerson` размещается вместе с тремя не-объектными блоками (3, 4 и 5). Они содержат знаки для переменных-членов `CString` и не будут удалены в случае вызова деструктора объекта `CPerson` .

Блок номер 2 — собственно объект `CPerson` . `$51A4` представляет собой адрес блока, за которым следует содержимое объекта, выводимое `CPerson`::`Dump` при вызове с помощью [DumpAllObjectsSince](/cpp/mfc/reference/cmemorystate-structure#dumpallobjectssince).

Нетрудно догадаться, что блок номер 1 связан с переменной фрейма `CString` , это видно из порядкового номера и размера, соответствующего количеству знаков в переменной фрейма `CString` . Переменные, размещенные во фрейме, автоматически освобождаются, когда фрейм выходит за пределы области действия.

**Переменные фрейма**

В основном можно не волноваться по поводу объектов кучи, связанных с переменными фрейма, потому что они автоматически освобождаются, когда эти переменные выходят за пределы области действия. Чтобы избежать беспорядка в диагностическом дампе, следует располагать вызовы `Checkpoint` так, чтобы они находились вне области действия переменных фрейма. Например, поместите фигурные скобки так, чтобы они окружали код предыдущего выделения памяти:

```cpp
oldMemState.Checkpoint();
{
    // Do your memory allocations and deallocations ...
    CString s("This is a frame variable");
    // The next object is a heap object.
    CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );
}
newMemState.Checkpoint();
```

С квадратными скобками в этих местах дамп памяти для этого примера выглядит следующим образом:

```cmd
Dumping objects ->

{5} strcore.cpp(80) : non-object block at $00A7521A, 9 bytes long
{4} strcore.cpp(80) : non-object block at $00A751F8, 5 bytes long
{3} strcore.cpp(80) : non-object block at $00A751D6, 6 bytes long
{2} a CPerson at $51A4

Last Name: Smith
First Name: Alan
Phone #: 581-0215
```

**Не-объектные выделения**

Следует отметить, что выделения бывают "объектными" (например, `CPerson`) и "не-объектными". Необъектные выделения — это выделения для объектов, которые не являются производными от `CObject`, а также выделения простых типов языка С, таких как `char`, `int`или `long`. Если класс, производный от <strong>CObject</strong>, выделяет дополнительное пространство, например внутренний буфер, такие объекты отобразят и объектное, и не-объектное выделение.

**Предотвращение утечек памяти**

Заметьте: в приведенном выше коде блок памяти, связанный с переменной фрейма `CString` , был освобожден автоматически и не отобразился как утечка. Автоматическое освобождение, обусловленное правилами ограничения области видимости, предотвращает большинство утечек памяти, связанных с переменными фрейма.

Однако для объектов, распределенных в куче, во избежание утечки памяти нужно явно удалять объект. Чтобы очистить последнюю утечку памяти в предыдущем примере, удалите объект `CPerson` , размещенный в куче:

```cpp
{
    // Do your memory allocations and deallocations.
    CString s("This is a frame variable");
    // The next object is a heap object.
    CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );
    delete p;
}
```

[Содержание раздела](#BKMK_In_this_topic)

#### <a name="customizing-object-dumps"></a><a name="BKMK_Customizing_object_dumps"></a> Настройка дампов объектов
Если класс наследуется от [CObject](/cpp/mfc/reference/cobject-class), можно переопределить функцию-член `Dump` , чтобы получить больше сведений при использовании [DumpAllObjectsSince](/cpp/mfc/reference/cmemorystate-structure#dumpallobjectssince) для вывода объектов в [Окне вывода](../ide/reference/output-window.md).

Функция `Dump` записывает текстовое представление переменных-членов объекта в контекст дампа ([CDumpContext](/cpp/mfc/reference/cdumpcontext-class)). Контекст дампа подобен потоку ввода-вывода. Для отправки данных в **<<** &lt;&lt; `CDumpContext`.

При переопределении функции `Dump` следует вначале вызвать версию `Dump` базового класса для вывода содержимого объектов базового класса. Затем вывести текстовое описание и значение для каждой переменной-члена производного класса.

Объявление функции `Dump` выглядит следующим образом:

```cpp
class CPerson : public CObject
{
public:
#ifdef _DEBUG
    virtual void Dump( CDumpContext& dc ) const;
#endif

    CString m_firstName;
    CString m_lastName;
    // And so on...
};
```

Поскольку формирование дампа объекта имеет смысл только при отладке программы, объявление функции `Dump` заключается в блок **#ifdef _DEBUG / #endif** .

В следующем примере функция `Dump` сначала вызывает функцию `Dump` для базового класса. Затем пишет короткое описание каждой переменной-члена и вместе со значением этой переменной направляет его в диагностический поток.

```cpp
#ifdef _DEBUG
void CPerson::Dump( CDumpContext& dc ) const
{
    // Call the base class function first.
    CObject::Dump( dc );

    // Now do the stuff for our specific class.
    dc << "last name: " << m_lastName << "\n"
        << "first name: " << m_firstName << "\n";
}
#endif
```

Для указания, куда будут направлены выходные данные дампа, следует применить аргумент `CDumpContext` . Отладочная версия MFC использует предопределенный объект `CDumpContext` с именем `afxDump` , который направляет выходные данные в отладчик.

```cpp
CPerson* pMyPerson = new CPerson;
// Set some fields of the CPerson object.
//...
// Now dump the contents.
#ifdef _DEBUG
pMyPerson->Dump( afxDump );
#endif
```

[Содержание раздела](#BKMK_In_this_topic)

## <a name="reducing-the-size-of-an-mfc-debug-build"></a><a name="BKMK_Reducing_the_size_of_an_MFC_Debug_build"></a> Сокращение размера отладочной сборки MFC
Отладочная информация для большого MFC-приложения может занимать значительное дисковое пространство. Для уменьшения размера можно использовать одну из описанных ниже процедур.

1. Перестройте библиотеки MFC, используя параметр [/Z7, /Zi, /ZI (формат отладочной информации)](/cpp/build/reference/z7-zi-zi-debug-information-format) вместо **/Z7**. С помощью этих параметров строится один файл программной базы данных (PDB), содержащий отладочную информацию для всей библиотеки, тем самым сохраняется место на диске.

2. Перестройте библиотеки MFC, не указывая отладочную информацию (не используя параметр [/Z7, /Zi, /ZI (формат отладочной информации)](/cpp/build/reference/z7-zi-zi-debug-information-format)). В этом случае из-за отсутствия отладочной информации использовать большинство возможностей отладчика внутри кода библиотеки MFC не удастся, но, так как библиотеки MFC уже отлажены, это не будет проблемой.

3. Соберите собственное приложение с отладочной информацией только для избранных модулей, используя описанную ниже процедуру.

    [Содержание раздела](#BKMK_In_this_topic)

### <a name="building-an-mfc-app-with-debug-information-for-selected-modules"></a><a name="BKMK_Building_an_MFC_app_with_debug_information_for_selected_modules"></a> Сборка приложения MFC с отладочной информацией для избранных модулей
Построение избранных модулей с отладочными библиотеками MFC позволяет использовать пошаговое выполнение и другие отладочные функции в этих модулях. Эта процедура использует конфигурации Debug и Release для проекта, таким образом создавая необходимость изменений, описанных ниже (и также вынуждая "перестроить все", когда потребуется построение окончательной версии).

1. Выберите проект в Обозревателе решений.

2. В меню **Вид** выберите **Страницы свойств**.

3. Сначала создайте новую конфигурацию проекта.

   1. В диалоговом окне **\<Project>Страницы свойств** нажмите кнопку **Диспетчер конфигураций**.

   2. В диалоговом окне [Диспетчер конфигураций](/previous-versions/visualstudio/visual-studio-2010/t1hy4dhz(v=vs.100))найдите нужный проект в таблице. В столбце **Конфигурация** выберите **\<New...>** .

   3. В диалоговом окне [Создание конфигурации проекта](/previous-versions/visualstudio/visual-studio-2010/0eh8w4cf(v=vs.100))введите имя новой конфигурации, например, "Неполная отладка" в поле **Имя конфигурации проекта** .

   4. В списке **Копировать параметры из** выберите **Выпуск**.

   5. Нажмите кнопку **ОК**, чтобы закрыть диалоговое окно **Создание конфигурации проекта**.

   6. Закройте диалоговое окно **Диспетчер конфигураций** .

4. Теперь нужно настроить параметры для всего проекта.

   1. В диалоговом окне **Страницы свойств** в папке **Свойства конфигурации** выберите категорию **Общие** .

   2. В таблице параметров проекта разверните **Параметры проекта по умолчанию** (если нужно).

   3. В **Параметрах проекта по умолчанию** найдите **Использовать MFC**. В правом столбце таблицы появится текущее значение параметра. Измените его на **Использовать MFC в статической библиотеке**.

   4. В левой области диалогового окна **Страницы свойств** откройте папку **C/C++** и выберите **Препроцессор**. В таблице свойств найдите **Определения препроцессора** и замените NDEBUG на _DEBUG.

   5. В левой области диалогового окна **Страницы свойств** откройте папку **Компоновщик** и выберите категорию **Ввод** . В таблице свойств найдите **Дополнительные зависимости**. Для свойства **Дополнительные зависимости** введите NAFXCWD.LIB и LIBCMT.

   6. Нажмите **OK** , чтобы сохранить новые параметры построения, и закройте диалоговое окно **Страницы свойств** .

5. Из меню **Построение** выберите подпункт **Перестроить**. Это действие удалит всю отладочную информацию из модулей, но не затронет библиотеку MFC.

6. Теперь нужно добавить отладочную информацию в избранные модули приложения. Помните, что можно задавать точки останова и выполнять другие отладочные действия только в тех модулях, которые скомпилированы с отладочной информацией. Для каждого файла проекта, в который нужно включить отладочную информацию, проделайте следующие действия:

   1. В обозревателе решений откройте папку **Исходные файлы** , расположенную в проекте.

   2. Выберите файл, для которого нужно настроить отладочную информацию.

   3. В меню **Вид** выберите **Страницы свойств**.

   4. В диалоговом окне **Страницы свойств** в папке **Параметры конфигурации** откройте папку **C/C++** и выберите категорию **Общие** .

   5. В таблице свойств найдите **Формат отладочной информации.**

   6. Щелкните **Формат отладочной информации** и выберите нужный параметр (обычно **/ZI**.

   7. Если приложение создано с использованием мастера создания приложений или имеет предкомпилированные заголовки, следует эти заголовки выключить или перекомпилировать их перед компиляцией остальных модулей. Иначе будет получено предупреждение C4650 и сообщение об ошибке C2855. Предварительно откомпилированные заголовки можно отключить, изменив параметр **Создать/Использовать предварительно откомпилированные заголовки** в диалоговом окне **\<Project> Свойства** (папка **Свойства конфигурации**, вложенная папка **C/C++** , категория **Предварительно откомпилированные заголовки**).

7. В меню **Построение** выберите **Построить** для перестройки устаревших файлов проекта.

   Как альтернативу описанному здесь способу для настройки отдельных параметров каждого файла можно использовать внешний сборочный файл проекта. В этом случае помните: чтобы подключить отладочные библиотеки MFC, следует определить флаг [_DEBUG](/cpp/c-runtime-library/debug) для каждого модуля. Если необходимо использовать конечную версию библиотеки MFC, нужно определить NDEBUG. Дополнительные сведения о создании внешних сборочных файлов проекта см. в [Справочнике NMAKE](/cpp/build/running-nmake).

   [Содержание раздела](#BKMK_In_this_topic)

## <a name="see-also"></a>См. также
[Отладка машинного кода](../debugger/debugging-native-code.md)