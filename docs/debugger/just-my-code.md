---
title: Отладка пользовательского кода только мой код | Документация Майкрософт
ms.date: 10/22/2018
ms.topic: conceptual
ms.assetid: 0f0df097-bbaf-46ad-9ad1-ef5f40435079
author: mikejo5000
ms.author: mikejo
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 99c31291e31821f79e23f507e37003c571a8ab7c
ms.sourcegitcommit: 37fb7075b0a65d2add3b137a5230767aa3266c74
ms.translationtype: MTE95
ms.contentlocale: ru-RU
ms.lasthandoff: 01/02/2019
ms.locfileid: "53952051"
---
# <a name="debug-only-user-code-with-just-my-code"></a>Отладка пользовательского кода только мой код 

*Только мой код* представляет собой возможность отладки Visual Studio, автоматически последовательность шагов обходом вызовов системы, платформы и другие не написанный пользователем код. В **стек вызовов** окна, Just My Code сворачивает эти вызовы в **[внешний код]** кадров. 

Только мой код по-разному работает в проектах .NET Framework, C++ и JavaScript.

##  <a name="BKMK_Enable_or_disable_Just_My_Code"></a> Включение или отключение режима "Только мой код"  

В большинстве языков программирования Just My Code включена по умолчанию. 

- Чтобы включить или отключить только мой код в Visual Studio, в разделе **средства** > **параметры** (или **Отладка** > **параметры**) > **Отладка** > **Общие**, установите или снимите **включить только мой код**.
  
 ![Включить только мой код в диалоговом окне Параметры](../debugger/media/dbg_justmycode_options.png "включить только мой код")  
  
> [!NOTE]
> **Включить только мой код** — это глобальный параметр, который применяется ко всем проектам Visual Studio на всех языках.  
  
##  <a name="just-my-code-debugging"></a>отладка "Только мой код"

Во время сеанса отладки **модули** окно показывает, какие модули, отладчик, рассматривая как Мой код (пользовательский код), кода вместе с их загрузка состояния символов. Дополнительные сведения см. в разделе [более подробно ознакомиться с как отладчик подключается к приложению](../debugger/debugger-tips-and-tricks.md#modules_window).

 ![Пользовательский код в окно "Модули"](../debugger/media/dbg_justmycode_module.png "пользовательский код в окно \"Модули\"")
  
В **стек вызовов** или **задачи** окно, только мой код сворачивает код, не написанный пользователем в кадр с заметками кода серым с меткой `[External Code]`.

 ![Внешний код кадр в окне стека вызовов](../debugger/media/dbg_justmycode_externalcode.png "кадра внешний код")
  
>[!TIP]
>Чтобы открыть **модули**, **стек вызовов**, **задачи**, и большинство других окон отладки, необходимо быть в сеансе отладки. Во время отладки, в разделе **Отладка** > **Windows**, выберите ОС windows, которую требуется открыть. 

<a name="BKMK_Override_call_stack_filtering"></a> Чтобы просмотреть код в свернутой **[внешний код]** кадра, щелкните правой кнопкой мыши в **стек вызовов** или **задачи** затем выберите **Показать внешний код**в контекстном меню. Замените строки развернутой внешнего кода **[внешний код**] кадра. 

 ![Показать внешний код в окне стека вызовов](../debugger/media/dbg_justmycode_showexternalcode.png "Показать внешний код")
  
> [!NOTE]
> **Показать внешний код** является текущий пользователь профилировщика, параметр, который применяется ко всем проектам на всех языках, открываемых пользователем.

Дважды щелкнув строку развернутой внешний код в **стек вызовов** окне выделяются зеленым цветом исходный код строку вызывающего кода. Для библиотек DLL или других модулей не найден или загружен символов или исходные не найден может открыться страница.

##  <a name="BKMK__NET_Framework_Just_My_Code"></a> "Только мой код" в .NET Framework 

В проектах .NET Framework, Just My Code используется символ (*.pdb*) файлов и программную оптимизацию для классификации пользователей и не написанный пользователем код. Отладчик .NET Framework, проведенной оптимизированные двоичные файлы, а не загружен *.pdb* файлы, чтобы они не написанный пользователем код.
  
Три атрибута компилятор также влияют на отладчик .NET, считает пользовательским кодом:  

- <xref:System.Diagnostics.DebuggerNonUserCodeAttribute> указывает отладчику, что код, к которому он применяется не пользовательский код.  
- <xref:System.Diagnostics.DebuggerHiddenAttribute> скрывает код от отладчика, даже если режим "Только мой код" включен.  
- <xref:System.Diagnostics.DebuggerStepThroughAttribute> отладчика для пошагового выполнения кода, в которой он применен, вместо того, чтобы пошагово выполнить код.  

Отладчик .NET Framework считает, что весь остальной код пользовательским кодом.  

Во время отладки .NET Framework:

- **Отладка** > **шаг с заходом** (или **F11**) на встроенный код обходит код на следующую строку пользовательского кода. 
- **Отладка** > **шаг с выходом** (или **Shift**+**F11**) на встроенный код выполняется на следующую строку пользовательского кода. 

Если пользовательский код отсутствует дополнительные, отладка продолжается, пока оно заканчивается, достигает еще одну точку останова или вызывает ошибку. 

<a name="BKMK_NET_Breakpoint_behavior"></a> Если отладчик приостанавливает выполнение кода, не написанный пользователем (например, можно использовать **Отладка** > **прервать все** и приостановки в непользовательском коде), **нет исходного кода** появится окно. Затем можно использовать **Отладка** > **шаг** команду, чтобы перейти к следующей строке пользовательского кода.

При возникновении необработанного исключения в коде, не написанный пользователем, отладчик останавливается в строке кода пользователя, где было создано исключение.  
  
Если исключения первого шанса включены для исключения, строку вызывающего кода пользователя выделяется зеленым цветом исходный код. **Стек вызовов** окно отображает кадр с заметками и подписью **[внешний код]**.  

##  <a name="BKMK_C___Just_My_Code"></a> "Только мой код" в C++  
  
В C++, включение Just My Code — так же, как [/JMC (Отладка только собственного кода)](/cpp/build/reference/jmc) параметр компилятора.

<a name="BKMK_CPP_User_and_non_user_code"></a> Только мой код отличается в C++, чем в .NET Framework и JavaScript, так как можно указать файлы не написанный пользователем отдельно для поведение пошагового выполнения и **стек вызовов** окна. 

Только мой код на C++ рассматривает только эти функции не написанный пользователем код:

- Для **стек вызовов** окна: 

  - Функции с открытой исходной информацией в файле символов.  
  - Функции, в которых файлы символов указывают, что исходный файл, соответствующий кадру стека, отсутствует.  
  - Функции, определенные в  *\*.natjmc* файлы в *%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers* папки.  
  
- Для пошагового выполнения поведение:
  
  - Функции, определенные в  *\*.natstepfilter* файлы в *%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers* папки.  
  
Можно создать *.natstepfilter* и *.natjmc* файлы для настройки поведения пошагового выполнения только мой код и **стек вызовов** окна. См. в разделе [поведение пошаговой настройки C++](#BKMK_CPP_Customize_stepping_behavior) и [поведения стека вызовов настроить C++](#BKMK_CPP_Customize_call_stack_behavior). 

<a name="BKMK_CPP_Stepping_behavior"></a> Во время отладки C++:

- **Отладка** > **шаг с заходом** (или **F11**) на встроенный код обходит код на следующую строку пользовательского кода. 
- **Отладка** > **шаг с выходом** (или **Shift**+**F11**) на встроенный код выполняется на следующую строку пользовательского кода. 

Если пользовательский код отсутствует дополнительные, отладка продолжается, пока оно заканчивается, достигает еще одну точку останова или вызывает ошибку. 

Если отладчик приостанавливает выполнение кода, не написанный пользователем (например, можно использовать **Отладка** > **прервать все** и приостановки за считаные непользовательский код), пошаговое выполнение продолжается в непользовательском коде.

Если отладчик обнаруживает исключение, он останавливается на исключение, будь то в коде пользователя или не написанный пользователем. **Не обработанное пользовательским кодом** параметры в **параметры исключений** диалоговое окно учитываются.  

###  <a name="BKMK_CPP_Customize_stepping_behavior"></a> Настройка поведения пошагового выполнения C++  

 В проектах C++, можно указать функции, которые будут проходиться внесения их как встроенный код в  *\*.natstepfilter* файлов.  
  
- Чтобы указать встроенный код для всех локальных пользователей Visual Studio, добавьте *.natstepfilter* файл *%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers* папки.  
- Чтобы указать непользовательский код для отдельного пользователя, добавьте файл *.natstepfilter* в папку *%USERPROFILE%\My Documents\Visual Studio 2017\Visualizers*.  
  
Объект *.natstepfilter* файл является XML-файл со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<StepFilter xmlns="http://schemas.microsoft.com/vstudio/debugger/natstepfilter/2010">  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Action>StepAction</Action>  
    </Function>  
    <Function>  
        <Name>FunctionSpec</Name>  
        <Module>ModuleSpec</Module>  
        <Action>StepAction</Action>  
    </Function>  
</StepFilter>  
  
```  
  
|Элемент|Описание|  
|-------------|-----------------|  
|`Function`|Обязательный. Указывает одну или несколько функций как функцию, не написанную пользователем.|  
|`Name`|Обязательный. Регулярное выражение в формате ECMA-262, содержащее полное имя функции для сопоставления. Например:<br /><br /> `<Name>MyNS::MyClass.*</Name>`<br /><br /> сообщает отладчику, что все методы в `MyNS::MyClass`, должны считаться кодом, не написанным пользователем. Сопоставление учитывает регистр.|  
|`Module`|Необязательный параметр. Регулярное выражение в формате ECMA-262, указывающее полный путь к модулю, содержащему функцию. Сопоставление не учитывает регистр.|  
|`Action`|Обязательный. Одно из следующих чувствительных к регистру значений:<br /><br /> `NoStepInto`  — указывает отладчику шаг с обходом функции.<br /> `StepInto`  — указывает отладчику выполнять шаги с заходом в функцию, отменяя все остальные `NoStepInto` для соответствующей функции.|  
  
###  <a name="BKMK_CPP_Customize_call_stack_behavior"></a> Настройка поведения стека вызовов C++  

Для проектов C++, можно указать модули, исходные файлы и функции **стек вызовов** непользовательский код интерпретируется в окне, указав их в  *\*.natjmc* файлов.  
  
-   Чтобы указать непользовательский код для всех пользователей компьютера с Visual Studio, добавьте файл *.natjmc* в папку *%VsInstallDirectory%\Common7\Packages\Debugger\Visualizers*.  
-   Чтобы указать непользовательский код для отдельного пользователя, добавьте файл *.natjmc* в папку *%USERPROFILE%\My Documents\Visual Studio 2017\Visualizers*.  

Объект *.natjmc* файл является XML-файл со следующим синтаксисом:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NonUserCode xmlns="http://schemas.microsoft.com/vstudio/debugger/jmc/2015">  
  
  <!-- Modules -->  
  <Module Name="ModuleSpec" />  
  <Module Name="ModuleSpec" Company="CompanyName" />  
  
  <!-- Files -->  
  <File Name="FileSpec"/>  
  
  <!-- Functions -->  
  <Function Name="FunctionSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" />  
  <Function Name="FunctionSpec" Module ="ModuleSpec" ExceptionImplementation="true" />  
  
</NonUserCode>  
  
```  
  
 **Атрибуты элементов модуля**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный. Полный путь к модулю или модулям. Можно использовать подстановочные знаки Windows `?` (ноль или один символ) и `*` (ноль или более символов). Например, примененная к объекту директива<br /><br /> `<Module Name="?:\3rdParty\UtilLibs\*" />`<br /><br /> указывает отладчику, что необходимо рассматривать все модули в *\3rdParty\UtilLibs* на любом диске как внешний код.|  
|`Company`|Необязательный параметр. Название компании, публикующей модуль, внедренный в исполняемый файл. Этот атрибут можно использовать для устранения неоднозначности модулей.|  
  
 **Атрибуты элементов файла**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный. Полный путь к файлу или файлам исходного кода, который необходимо считать внешним кодом. При задании пути можно использовать следующие подстановочные знаки Windows: `?` и `*`.|  
  
 **Атрибуты элементов функций**  
  
|Атрибут|Описание|  
|---------------|-----------------|  
|`Name`|Обязательный. Полное имя функции, которую необходимо рассматривать как внешний код.|  
|`Module`|Необязательный параметр. Имя модуля или полный путь к модулю, содержащему эту функцию. Этот атрибут можно использовать для устранения неоднозначности функций с одинаковыми именами.|  
|`ExceptionImplementation`|Если задано значение `true`, стек вызовов отображает функцию, которая создала исключение, а не данную функцию.|  
  
##  <a name="BKMK_JavaScript_Just_My_Code"></a> "Только мой код" в JavaScript  

<a name="BKMK_JS_User_and_non_user_code"></a> Режим "Только мой код" в JavaScript управляет пошаговым выполнением и отображением стека вызовов путем распределения кода по одной из следующих классификаций:  

|||  
|-|-|  
|**MyCode**|Код пользователя, которым вы распоряжаетесь и управляете.|  
|**LibraryCode**|Непользовательский код из библиотеки, которые будут использоваться регулярно и ваше приложение зависит от функционировать правильно (например WinJS или jQuery).|  
|**UnrelatedCode**|Непользовательский код в приложении, который не принадлежит и приложение не зависит от правильной. Например advertising SDK, отображающий объявления можно UnrelatedCode. В проектах UWP любой код, который загружается в веб-приложения на основе HTTP или HTTPS URI также считается UnrelatedCode.|  

Отладчик JavaScript классифицируют код как пользователь или не написанный пользователем в следующем порядке:  
  
1. Классификации по умолчанию.  
   -   Скрипта, выполняемого путем передачи строки предоставленной узлом `eval` функция **MyCode**.  
   -   Скрипта, выполняемого путем передачи строки `Function` конструктор является **LibraryCode**.  
   -   В ссылке платформы, например WinJS или Azure SDK, он **LibraryCode**.  
   -   Скрипта, выполняемого путем передачи строки `setTimeout`, `setImmediate`, или `setInterval` "функции" — **UnrelatedCode**.  
   
2. Классификации, указанный для всех проектов Visual Studio для JavaScript в *%VSInstallDirectory%\JavaScript\JustMyCode\mycode.default.wwa.json* файла.  
   
3. Классификации в *mycode.json* файла текущего проекта.  
  
Каждый шаг классификации переопределяет предыдущие шаги. 

Весь остальной код классифицируется как **MyCode**.  

Вы можете изменить классификации по умолчанию и классифицировать определенные файлы и URL-адреса как пользователь или не написанный пользователем код, добавив *.json* файл с именем *mycode.json* в корневую папку проекта JavaScript. См. в разделе [настроить JavaScript только мой код](#BKMK_JS_Customize_Just_My_Code). 

<a name="BKMK_JS_Stepping_behavior"></a> Во время отладки JavaScript: 

- Если функция не написанный пользователем код, **Отладка** > **шаг с заходом** (или **F11**) ведет себя так же, как **Отладка**  >  **Шаг с обходом** (или **F10**).  
- Если шаг начинается в непользовательском (**LibraryCode** или **UnrelatedCode**) код, пошаговое выполнение временно осуществляется, как если бы только мой код не включена. При выполнении шага обратно в пользовательский код, Just My Code возобновляется.  
- Когда пользователь кода шаг приводит к выходу из текущего контекста выполнения, отладчик останавливается на следующей строке кода выполненного пользователем. Например, если обратный вызов выполняется в коде **LibraryCode**, отладчик продолжает выполнение, пока не будет выполнена следующая строка кода пользователя.
- **Шаг с выходом** (или **Shift**+**F11**) останавливается на следующей строке пользовательского кода. 

Если пользовательский код отсутствует дополнительные, отладка продолжается, пока оно заканчивается, достигает еще одну точку останова или вызывает ошибку. 

Точки останова, заданные в коде, всегда срабатывают, но код классифицируется.  

- Если `debugger` ключевое слово в **LibraryCode**, отладчик всегда останавливается.  
- Если `debugger` ключевое слово в **UnrelatedCode**, отладчик не останавливается.  
  
<a name="BKMK_JS_Exception_behavior"></a> При возникновении необработанного исключения в **MyCode** или **LibraryCode** кода, отладчик всегда останавливается.  

При возникновении необработанного исключения в **UnrelatedCode**, и **MyCode** или **LibraryCode** находится в стеке вызовов, отладчик достигнет точки останова.  
  
Если исключения первого шанса включены для исключения и исключение происходит в **LibraryCode** или **UnrelatedCode**:  
  
-   Если исключение обрабатывается, отладчик не останавливается.  
-   Если исключение не обрабатывается, отладчик останавливается.  
  
###  <a name="BKMK_JS_Customize_Just_My_Code"></a> Настройка JavaScript только мой код  

Для упорядочивания пользователей и не написанный пользователем код для отдельного проекта JavaScript, можно добавить *.json* файл с именем *mycode.json* в корневую папку проекта.  
  
Спецификации в этом файле переопределить классификации по умолчанию и *mycode.default.wwa.json* файла. *Mycode.json* файл должен отображать все пары ключ-значение. **MyCode**, **библиотеки**, и **Unrelated** значения могут быть пустыми массивами.  
  
*MyCode.JSON* файлов используйте следующий синтаксис:  
  
```json  
{  
    "Eval" : "Classification",  
    "Function" : "Classification",  
    "ScriptBlock" : "Classification",  
    "MyCode" : [  
        "UrlOrFileSpec",  
        . . .  
        "UrlOrFileSpec"  
    ],  
    "Libraries" : [  
        "UrlOrFileSpec",  
        . .  
        "UrlOrFileSpec"  
    ],  
    "Unrelated" : [  
        "UrlOrFileSpec",  
        . . .  
        "UrlOrFileSpec"  
    ]  
}  
  
```  
  
 **"Eval", "Function" и "ScriptBlock"**  
  
 Пары "ключ-значение" **Eval**, **Function** и**ScriptBlock** определяют, как классифицируется динамически создаваемый код:  
  
|||  
|-|-|  
|**Eval**|Скрипт, который выполняется путем передачи строки предоставленной узлом функции `eval`. По умолчанию скрипт Eval классифицируется как **MyCode**.|  
|**Function**|Скрипт, который выполняется путем передачи строки конструктору `Function`. По умолчанию скрипт Function классифицируется как **LibraryCode**.|  
|**ScriptBlock**|Скрипт, который выполняется путем передачи строки функциям `setTimeout`, `setImmediate` или `setInterval`. По умолчанию скрипт ScriptBlock классифицируется как **UnrelatedCode**.|  
  
 Можно изменить это значение на одно из следующих ключевых слов:  
  
-   `MyCode` классифицирует скрипт как **MyCode**.  
-   `Library` классифицирует скрипт как **LibraryCode**.  
-   `Unrelated` классифицирует скрипт как **UnrelatedCode**.  
  
  **"MyCode", "Libraries" и "Unrelated"**  
  
 Пары "ключ-значение" **MyCode**, **Libraries** и **Unrelated** определяют URL-адреса или файлы, которые нужно включить в классификацию:  
  
|||  
|-|-|  
|**MyCode**|Массив URL-адресов или файлы, которые классифицируются как **MyCode**.|  
|**Libraries**|Массив URL-адресов или файлы, которые классифицируются как **LibraryCode**.|  
|**Unrelated**|Массив URL-адресов или файлы, которые классифицируются как **UnrelatedCode**.|  
  
 Строка URL-адрес или файл может иметь один или несколько `*` символов, соответствующих ноль или более символов. `*` совпадает со значением регулярное выражение `.*`.
