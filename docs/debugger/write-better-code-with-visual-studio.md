---
title: Методы и инструменты отладки
description: Возможность писать более качественный код с меньшим числом ошибок, используя Visual Studio для исправления исключений, устранения ошибок и улучшения кода
ms.custom:
- debug-experiment
- seodec18
ms.date: 02/14/2020
ms.topic: conceptual
helpviewer_keywords:
- debugger
author: mikejo5000
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: c69fe13821f595a137c07d545a4ccfb10fc89b34
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/08/2021
ms.locfileid: "99904947"
---
# <a name="debugging-techniques-and-tools-to-help-you-write-better-code"></a>Методы и средства отладки, помогающие писать более качественный код

Устранение ошибок в коде может быть трудоемкой и иногда неприятной задачей. Чтобы научиться эффективно выполнять отладку, требуется время, но эффективная интегрированная среда разработки, такая как Visual Studio, может сделать вашу работу гораздо проще. Интегрированная среда разработки позволяет быстрее исправлять ошибки и выполнять отладку кода, а также может помочь в написании боле качественного кода с меньшим количеством ошибок. Целью этой статьи является формирование комплексного представления о процессе исправления ошибок, благодаря чему вы узнаете, когда следует использовать анализатор кода, когда — отладчик, как исправить исключения и как писать код, руководствуясь его предназначением. Если вы уже знакомы с использованием отладчика, см. статью [Первое знакомство с отладчиком](../debugger/debugger-feature-tour.md).

В этой статье мы поговорим об использовании интегрированной среды разработки для повышения продуктивности сеансов программирования. Мы затронем несколько задач, таких как:

* Подготовка кода к отладке с помощью анализатора кода интегрированной среды разработки

* Исправление исключений (ошибки времени выполнения)

* Минимизация ошибок путем написания кода с учетом его предназначения (с помощью оператора assert)

* Аспекты использования отладчика

В качестве демонстрации к этим задачам мы рассмотрим несколько наиболее распространенных типов ошибок, которые возникают при попытке отладки приложений. Хотя пример кода написан на C#, указанные концепции в общем случае применимы к C++, Visual Basic, JavaScript и другим языкам, поддерживаемым Visual Studio (если не указано иное). На снимках экрана представлены примеры на C#.

## <a name="create-a-sample-app-with-some-bugs-and-errors-in-it"></a>Создание примера приложения с некоторыми ошибками

В следующем коде есть ошибки, которые можно исправить с помощью интегрированной среды разработки Visual Studio. Здесь представлено простое приложение, которое имитирует получение данных JSON из некоторой операции, десериализацию данных в объект и обновление простого списка с помощью новых данных.

Создание приложения:

1. Для этого вам потребуется установленная среда Visual Studio с рабочей нагрузкой **Кроссплатформенная разработка .NET Core** или **Разработка классических приложений .NET** (в зависимости от того, приложение какого типа вы создаете).

    Установите Visual Studio бесплатно со страницы [скачиваемых материалов Visual Studio](https://visualstudio.microsoft.com/downloads/), если еще не сделали этого.

    Если у вас уже установлена среда Visual Studio без нужных рабочих нагрузок, щелкните **Сервис** > **Получить средства и компоненты**. Запускается Visual Studio Installer. Выберите рабочую нагрузку **Кроссплатформенная разработка .NET Core** или **Разработка классических приложений .NET**, а затем нажмите кнопку **Изменить**.

1. Запустите Visual Studio.

    ::: moniker range=">=vs-2019"
    На начальном экране выберите **Создать проект**. Введите **консоль** в поле поиска и выберите **Консольное приложение (.NET Core)** или **Консольное приложение (.NET Framework)** . Нажмите кнопку **Далее**. Введите имя проекта, например **Console_Parse_JSON**, и нажмите кнопку **Создать**.
    ::: moniker-end
    ::: moniker range="vs-2017"
    В верхней строке меню последовательно выберите **Файл**  > **Создать**  > **Проект**. В левой области диалогового окна **Новый проект** в разделе **Visual C#** выберите **Консольное приложение**, а затем в средней области выберите **Консольное приложение (.NET Core)** или **Консольное приложение (.NET Framework)** . Введите имя, например **Console_Parse_JSON**, и нажмите кнопку **ОК**.
    ::: moniker-end

    Если шаблон проекта **Консольное приложение (.NET Core)** или **Консольное приложение (.NET Framework)** отсутствует, перейдите в меню **Сервис** > **Получить средства и компоненты**, после чего запустится Visual Studio Installer. Выберите рабочую нагрузку **Разработка кроссплатформенных приложений .NET Core** или **Разработка классических приложений .NET Core**, а затем выберите **Изменить**.

    Visual Studio создаст консольный проект и откроет его в обозревателе решений (правая область).

1. Замените код по умолчанию в файле *Program.cs* проекта на пример кода ниже.

```csharp
using System;
using System.Collections.Generic;
using System.Runtime.Serialization.Json;
using System.Runtime.Serialization;
using System.IO;

namespace Console_Parse_JSON
{
    class Program
    {
        static void Main(string[] args)
        {
            var localDB = LoadRecords();
            string data = GetJsonData();

            User[] users = ReadToObject(data);

            UpdateRecords(localDB, users);

            for (int i = 0; i < users.Length; i++)
            {
                List<User> result = localDB.FindAll(delegate (User u) {
                    return u.lastname == users[i].lastname;
                    });
                foreach (var item in result)
                {
                    Console.WriteLine($"Matching Record, got name={item.firstname}, lastname={item.lastname}, age={item.totalpoints}");
                }
            }

            Console.ReadKey();
        }

        // Deserialize a JSON stream to a User object.
        public static User[] ReadToObject(string json)
        {
            User deserializedUser = new User();
            User[] users = { };
            MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(json));
            DataContractJsonSerializer ser = new DataContractJsonSerializer(users.GetType());

            users = ser.ReadObject(ms) as User[];

            ms.Close();
            return users;
        }

        // Simulated operation that returns JSON data.
        public static string GetJsonData()
        {
            string str = "[{ \"points\":4o,\"firstname\":\"Fred\",\"lastname\":\"Smith\"},{\"lastName\":\"Jackson\"}]";
            return str;
        }

        public static List<User> LoadRecords()
        {
            var db = new List<User> { };
            User user1 = new User();
            user1.firstname = "Joe";
            user1.lastname = "Smith";
            user1.totalpoints = 41;

            db.Add(user1);

            User user2 = new User();
            user2.firstname = "Pete";
            user2.lastname = "Peterson";
            user2.totalpoints = 30;

            db.Add(user2);

            return db;
        }
        public static void UpdateRecords(List<User> db, User[] users)
        {
            bool existingUser = false;

            for (int i = 0; i < users.Length; i++)
            {
                foreach (var item in db)
                {
                    if (item.lastname == users[i].lastname && item.firstname == users[i].firstname)
                    {
                        existingUser = true;
                        item.totalpoints += users[i].points;

                    }
                }
                if (existingUser == false)
                {
                    User user = new User();
                    user.firstname = users[i].firstname;
                    user.lastname = users[i].lastname;
                    user.totalpoints = users[i].points;

                    db.Add(user);
                }
            }
        }
    }

    [DataContract]
    internal class User
    {
        [DataMember]
        internal string firstname;

        [DataMember]
        internal string lastname;

        [DataMember]
        // internal double points;
        internal string points;

        [DataMember]
        internal int totalpoints;
    }
}
```

## <a name="find-the-red-and-green-squiggles"></a>Ищите красные и зеленые волнистые линии!

Прежде чем пытаться запустить пример приложения и отладчик, проверьте код в редакторе кода на наличие красных и зеленых волнистых линий. Они представляют ошибки и предупреждения, определяемые анализатором кода интегрированной среды разработки. Красные волнистые линии обозначают ошибки времени компиляции, которые необходимо исправить, прежде чем можно будет запустить код. Зеленые волнистые линии обозначают предупреждения. Хотя часто приложение можно запустить без исправления предупреждений, они могут быть источником ошибок, а их устранение во многих случаях помогает сэкономить время и силы. Эти предупреждения и ошибки также можно просмотреть в окне **Список ошибок**, если вы предпочитаете представление списка.

В примере приложения вы увидите несколько красных волнистых линий, которые необходимо исправить, и одну зеленую, которую необходимо изучить. Ниже приведена первая ошибка.

![Ошибка, представленная красной волнистой линией](../debugger/media/write-better-code-red-squiggle.png)

Чтобы устранить эту ошибку, обратитесь к другой функции интегрированной среды разработки, представленной значком в виде лампочки.

## <a name="check-the-light-bulb"></a>Проверяйте лампочку!

Первая красная волнистая линия представляет ошибку времени компиляции. Наведите на нее указатель мыши, и появится сообщение ```The name `Encoding` does not exist in the current context```.

Обратите внимание, что в нижнем левом углу от этой ошибки отображается значок лампочки. Вместе со значком отвертки ![значок отвертки](../ide/media/screwdriver-icon.png) значок лампочки ![значок лампочки](../ide/media/light-bulb-icon.png) представляет быстрые действия, которые могут помочь при внутреннем исправлении или рефакторинге кода. Лампочка представляет проблемы, которые *необходимо* исправить. Отвертка указывает на проблемы, которые при желании можно исправить. Используйте первое предлагаемое исправление для устранения этой ошибки, щелкнув элемент **using System.Text** слева.

![Исправление кода с помощью лампочки](../debugger/media/write-better-code-missing-include.png)

Если щелкнуть этот элемент, Visual Studio добавит оператор `using System.Text` в начало файла *Program.cs*, а красная волнистая линия исчезнет. (Если вы не уверены, что именно делает предложенное исправление, выберите ссылку **Просмотреть изменения** справа перед его применением.)

Описанная выше ошибка является распространенной и обычно устраняется путем добавления в код нового оператора `using`. Существует несколько схожих распространенных ошибок, таких как ```The type or namespace `Name` cannot be found.```. Такие ошибки могут указывать на отсутствующую ссылку на сборку (щелкните проект правой кнопкой мыши, выберите **Добавить** > **Ссылка**), неправильно указанное имя или отсутствующую библиотеку, которую необходимо добавить (для C# щелкните проект правой кнопкой мыши и выберите **Управление пакетами NuGet**).

## <a name="fix-the-remaining-errors-and-warnings"></a>Исправление оставшихся ошибок и предупреждений

В этом коде есть еще несколько волнистых линий. Здесь присутствует типичная ошибка преобразования типа. При наведении указателя мыши на волнистую линию видно, что код пытается преобразовать тип string в int, что не поддерживается, если не добавлен явный код для такого преобразования.

![Ошибка преобразования типа](../debugger/media/write-better-code-conversion-error.png)

Так как анализатор кода не может угадать ваше намерение, в данном случае лампочки, которые могут помочь вам, отсутствуют. Чтобы устранить эту ошибку, необходимо знать предназначение кода. В этом примере легко заметить, что `points` должен быть числовым (целочисленным) значением, так как вы пытаетесь добавить `points` в `totalpoints`.

Чтобы устранить эту ошибку, измените член `points` класса `User` с такого:

```csharp
[DataMember]
internal string points;
```

на такой:

```csharp
[DataMember]
internal int points;
```

Красные волнистые линии в редакторе кода исчезают.

Затем наведите указатель мыши на зеленую волнистую линию в объявлении элемента данных `points`. Анализатор кода сообщает, что переменной никогда не присваивается значение.

![Предупреждающее сообщение для неназначенной переменной](../debugger/media/write-better-code-warning-message.png)

Как правило, это указывает на проблему, которую необходимо исправить. Однако в этом примере приложения вы фактически сохраняете данные в переменной `points` в процессе десериализации, а затем добавляете это значение в элемент данных `totalpoints`. В этом примере вы знаете предназначение кода и можете спокойно проигнорировать предупреждение. Однако если вы хотите устранить это предупреждение, можно заменить этот код:

```csharp
item.totalpoints = users[i].points;
```

следующим кодом:

```csharp
item.points = users[i].points;
item.totalpoints += users[i].points;
```

Зеленая волнистая линия исчезает.

## <a name="fix-an-exception"></a>Исправление исключения

Когда вы устранили все ошибки, обозначенные красными волнистыми линиями, и разрешили или по меньшей мере изучили все предупреждения, обозначенные зелеными волнистыми линиями, все готово к запуску отладчика и приложения.

Нажмите клавишу **F5** (**Отладка > Начать отладку**) или кнопку **Начать отладку** ![Начать отладку](../debugger/media/dbg-tour-start-debugging.png "Начало отладки") на панели инструментов отладки.

На этом этапе пример приложения выдает исключение `SerializationException` (ошибка времени выполнения). Это значит, что приложение не справляется с данными, которые пытается сериализовать. Так как приложение запущено в режиме отладки (подключен отладчик), помощник по исправлению ошибок отладчика переносит вас прямо к коду, выдавшему исключение, и выдает полезное сообщение об ошибке.

![Возникает исключение SerializationException](../debugger/media/write-better-code-serialization-exception.png)

Сообщение об ошибке указывает, что значение `4o` не может быть проанализировано как целое число. Итак, в этом примере вы знаете, что данные указаны неправильно: `4o` вместо `40`. Но что делать, если в реальной ситуации вы не контролируете данные (например, получаете их из веб-службы)? Как это исправить?

При возникновении исключения необходимо задать себе пару вопросов:

* Является ли это исключение простой ошибкой, которую можно исправить? Или

* Может ли это исключение возникнуть у пользователей?

В первом случае исправьте ошибку. (В примере приложения для этого нужно исправить неверные данные.) Во втором случае может потребоваться обработать исключение в коде, используя блок `try/catch` (мы рассмотрим другие возможные стратегии в следующем разделе). В примере приложения замените приведенный ниже код:

```csharp
users = ser.ReadObject(ms) as User[];
```

следующим кодом:

```csharp
try
{
    users = ser.ReadObject(ms) as User[];
}
catch (SerializationException)
{
    Console.WriteLine("Give user some info or instructions, if necessary");
    // Take appropriate action for your app
}
```

Блок `try/catch` подразумевает некоторое снижение производительности, поэтому их следует использовать только тогда, когда это действительно необходимо, то есть, когда (а) они могут возникнуть в окончательной версии приложения и (б) документация по методу указывает, что необходимо проверить наличие исключения (с предположением, что документация завершена). Во многих случаях можно соответствующим образом обработать исключение, чтобы пользователь никогда с ним не столкнулся.

Ниже приведено несколько важных советов по обработке исключений:

* Старайтесь не использовать пустой блок catch, например `catch (Exception) {}`, который не принимает соответствующее действие для предоставления или обработки ошибки. Пустой или неинформативный блок catch может скрывать исключения и усложнять, а не упрощать отладку кода.

* Используйте блок `try/catch` вокруг конкретной функции, которая вызывает исключение (`ReadObject` в примере приложения). Если использовать его вокруг большого фрагмента кода, вы в итоге скроете расположение ошибки. Например, не используйте блок `try/catch` вокруг вызова родительской функции `ReadToObject`, как показано здесь, или вы не сможете точно определить, где возникло исключение.

    ```csharp
    // Don't do this
    try
    {
        User[] users = ReadToObject(data);
    }
    catch (SerializationException)
    {
    }
    ```

* Для незнакомых функций, включаемых в приложение, особенно тех, которые взаимодействуют с внешними данными (например, с веб-запросом), изучите документацию, чтобы узнать, какие исключения может вызывать функция. Это может оказаться крайне важной информацией для правильной обработки ошибок и отладки приложения.

Для данного примера приложения исправьте `SerializationException` в методе `GetJsonData`, изменив `4o` на `40`.

## <a name="clarify-your-code-intent-by-using-assert"></a>Уточнение предназначения кода с помощью оператора assert

Нажмите кнопку **Перезапустить** ![Перезапустить приложение](../debugger/media/dbg-tour-restart.png "RestartApp") на панели инструментов отладки (**CTRL** + **SHIFT** + **F5**). Это приведет к перезапуску приложения за меньшее количество шагов. В окне консоли вы увидите приведенные ниже выходные данные.

![Значение NULL в выходных данных](../debugger/media/write-better-code-using-assert-null-output.png)

Можно заметить, что с выходными данными что-то не так. Значения **name** и **lastname** для третьей записи пусты.

Это подходящий момент, чтобы рассмотреть полезный и часто недооцененный подход к написанию кода, который заключается в использовании операторов `assert` в функциях. Добавив приведенный ниже код, вы включаете проверку во время выполнения, чтобы убедиться, что `firstname` и `lastname` отличаются от `null`. Замените приведенный ниже код в методе `UpdateRecords`:

```csharp
if (existingUser == false)
{
    User user = new User();
    user.firstname = users[i].firstname;
    user.lastname = users[i].lastname;
```

следующим кодом:

```csharp
// Also, add a using statement for System.Diagnostics at the start of the file.
Debug.Assert(users[i].firstname != null);
Debug.Assert(users[i].lastname != null);
if (existingUser == false)
{
    User user = new User();
    user.firstname = users[i].firstname;
    user.lastname = users[i].lastname;
```

Добавив такие операторы `assert` в функции в процессе разработки, можно указать предназначение кода. В предыдущем примере мы указываем следующее:

* Для имени требуется допустимая строка.
* Для фамилии требуется допустимая строка.

Указав таким образом намерение, вы применяете необходимые требования. Это простой и удобный способ, который можно использовать для изучения ошибок во время разработки. (Операторы `assert` также используются в качестве главного элемента в модульных тестах.)

Нажмите кнопку **Перезапустить** ![Перезапустить приложение](../debugger/media/dbg-tour-restart.png "RestartApp") на панели инструментов отладки (**CTRL** + **SHIFT** + **F5**).

> [!NOTE]
> Код `assert` активен только в отладочной сборке.

При перезапуске отладчик приостанавливает выполнение на операторе `assert`, так как выражение `users[i].firstname != null` вычисляется как `false` вместо `true`.

![Оператор assert разрешается в значение false](../debugger/media/write-better-code-using-assert.png)

Ошибка `assert` указывает на проблему, которую необходимо изучить. `assert` может охватывать множество сценариев, в которых исключение отображается не всегда. В этом примере пользователь не увидит исключение, а `null` значение добавляется в список записей в качестве `firstname`. Это может вызвать проблемы на более позднем этапе (например, в выходных данных консоли) и затруднить отладку.

> [!NOTE]
> В сценариях, где вы вызываете метод для значения `null`, возникает `NullReferenceException`. Обычно следует избегать использования блока `try/catch` для общего исключения, то есть исключения, не привязанного к определенной функции библиотеки. Любой объект может вызывать `NullReferenceException`. Если вы не уверены, изучите документацию по функции библиотеки.

Во время процесса отладки рекомендуется использовать определенный оператор `assert`, пока не станет понятно, что его нужно заменить реальным исправлением кода. Допустим, вы решили, что пользователь может столкнуться с исключением в сборке выпуска приложения. В этом случае необходимо выполнить рефакторинг кода, чтобы убедиться, что приложение не выдает неустранимое исключение или не приводит к возникновению какой-либо другой ошибки. Итак, чтобы исправить этот код, замените приведенный ниже код:

```csharp
if (existingUser == false)
{
    User user = new User();
```

следующим кодом:

```csharp
if (existingUser == false && users[i].firstname != null && users[i].lastname != null)
{
    User user = new User();
```

С помощью этого кода можно выполнить требования к коду и убедиться, что в данные не добавляется запись со значением `firstname` или `lastname`, равным `null`.

В этом примере мы добавили в цикл два оператора `assert`. Как правило, при использовании `assert`рекомендуется добавлять операторы `assert` в точке входа (начале) функции или метода. Сейчас вы просматриваете метод `UpdateRecords` в примере приложения. В этом методе вы можете столкнуться с проблемами, если какой-либо из его аргументов равен `null`, поэтому проверьте их оба с помощью оператора `assert` в точке входа функции.

```csharp
public static void UpdateRecords(List<User> db, User[] users)
{
    Debug.Assert(db != null);
    Debug.Assert(users != null);
```

Для предыдущих операторов ваше намерение заключается в том, чтобы загрузить существующие данные (`db`) и извлечь новые данные (`users`) перед обновлением.

Оператор `assert` можно использовать с любым видом выражения, которое разрешается в `true` или `false`. Например, можно добавить оператор `assert` следующего вида.

```csharp
Debug.Assert(users[0].points > 0);
```

Приведенный выше код полезен, если необходимо указать следующее намерение: для обновления записи пользователя требуется новое значение точки больше нуля (0).

## <a name="inspect-your-code-in-the-debugger"></a>Проверка кода в отладчике

Итак, теперь, когда вы устранили все критические проблемы с примером приложения, можно двигаться дальше.

Мы рассмотрели помощник по исправлению ошибок отладчика, но отладчик является гораздо более функциональным инструментом, который позволяет совершать и другие действия, такие как пошаговое выполнение кода и изучение его переменных. Эти эффективные возможности полезны во многих сценариях, особенно в следующих случаях:

* Вы пытаетесь изолировать ошибку времени выполнения в коде, но не можете сделать это с помощью описанных выше методов и средств.

* Вы хотите проверить код, то есть следить за его выполнением, чтобы убедиться, что он работает надлежащим образом и совершает необходимые действия.

    Следить за выполнением кода очень полезно. Так вы можете получить дополнительные сведения о коде и выявить ошибки до того, как проявляются их очевидные симптомы.

Дополнительные сведения об использовании функций отладчика см. в статье [Отладка для начинающих](../debugger/debugging-absolute-beginners.md).

## <a name="fix-performance-issues"></a>Исправление проблем производительности

Ошибки другого типа включают неэффективный код, из-за которого приложение выполняется медленнее или использует слишком много памяти. Как правило, оптимизация производительности осуществляется на более позднем этапе разработки приложения. Однако столкнуться с проблемами производительности можно уже на ранних этапах (например, часть приложения может работать медленно), в результате чего вам может потребоваться протестировать приложение с помощью средств профилирования. Дополнительные сведения о средствах профилирования, таких как средство загрузки ЦП и анализатор памяти, см. в разделе [Знакомство со средствами профилирования](../profiling/profiling-feature-tour.md).

## <a name="next-steps"></a>Следующие шаги

В этой статье вы узнали, как предотвращать и устранять многие распространенные ошибки в коде и когда использовать отладчик. Далее вы можете подробнее узнать об использовании отладчика Visual Studio для исправления ошибок.

> [!div class="nextstepaction"]
> [Отладка для начинающих](../debugger/debugging-absolute-beginners.md)
