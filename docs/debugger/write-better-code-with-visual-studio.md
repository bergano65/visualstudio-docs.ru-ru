---
title: Методы и инструменты отладки
description: Запись качественного кода с меньшим количеством ошибок с использованием Visual Studio для устранения исключений, исправления ошибок и улучшения кода
ms.custom:
- debug-experiment
- seodec18
ms.date: 01/24/2019
ms.topic: conceptual
helpviewer_keywords:
- debugger
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 6bfbcf9a63a01d391cbbc65067793d75d42899c1
ms.sourcegitcommit: d4bea2867a4f0c3b044fd334a54407c0fe87f9e8
ms.translationtype: MTE95
ms.contentlocale: ru-RU
ms.lasthandoff: 04/01/2019
ms.locfileid: "58790333"
---
# <a name="debugging-techniques-and-tools-to-help-you-write-better-code"></a>Методов отладки и средства, которые помогут вам создавать лучший код

Исправления ошибок и ошибок в коде может занимать много времени — и иногда раздражающим--задачи. Требуется время, чтобы узнать, как для эффективной отладки, но это мощная интегрированная среда разработки, как Visual Studio можно сделать вашу работу, гораздо проще. Интегрированная среда разработки может помочь устранить ошибки и отлаживать код быстрее, а не просто, но он может также помочь в написании качественного кода с меньшим количеством ошибок. Нашей целью этой статьи — дать вам целостное представление о процессе «исправление ошибок», поэтому вы будете знать, когда следует использовать анализатор кода, когда следует использовать отладчик, возникновение исключения и как программировать для цели. Если вы уже знаете, необходимо использовать отладчик, см. в разделе [сначала посмотрим, отладчик](../debugger/debugger-feature-tour.md).

В этой статье мы говорим о использование интегрированной среды разработки, чтобы повысить эффективность написания кода сеансов. Мы коснусь несколько задач, таких как:

* Подготовка кода для отладки за счет использования анализатора кода интегрированной среды разработки

* Возникновение исключения (ошибки времени выполнения)

* Как свести к минимуму ошибки путем написания кода для цели, (используя assert)

* Когда следует использовать отладчик

Чтобы продемонстрировать эти задачи, мы покажем некоторые из наиболее распространенных типов ошибок и ошибок, придется столкнуться при попытке отладки приложения. Несмотря на то, что образец кода находится C#, основные данные обычно относится к C++, Visual Basic, JavaScript и другие языки, поддерживаемые средой Visual Studio (за исключением оговоренных случаев). На снимках экрана представлены примеры на C#.

## <a name="create-a-sample-app-with-some-bugs-and-errors-in-it"></a>Создавать пример приложения с некоторыми ошибки и ошибки

В следующем коде у некоторые ошибки, которые можно исправить с помощью Visual Studio IDE. Здесь приложение представляет собой простое приложение, которое имитирует получение данных JSON с некоторой операции десериализации данных к объекту и обновление простой список с новыми данными.

Создание приложения:

1. Откройте Visual Studio и выберите **файл** > **New** > **проекта**. В разделе **Visual C#** , выберите **Windows Desktop** или **.NET Core**, а затем в средней области выберите **консольное приложение**.

    > [!NOTE]
    > Если шаблон проекта **Консольное приложение** отсутствует, щелкните ссылку **Открыть Visual Studio Installer** в левой области диалогового окна **Создание проекта**. Запускается Visual Studio Installer. Выберите рабочую нагрузку **Разработка классических приложений .NET** или **Кроссплатформенная разработка .NET Core**, а затем щелкните **Изменить**.

2. В **имя** введите **Console_Parse_JSON** и нажмите кнопку **ОК**. Visual Studio создаст проект.

3. Замените код по умолчанию в проекте *Program.cs* файл с примером кода ниже.

```csharp
using System;
using System.Collections.Generic;
using System.Runtime.Serialization.Json;
using System.Runtime.Serialization;
using System.IO;

namespace Console_Parse_JSON
{
    class Program
    {
        static void Main(string[] args)
        {
            var localDB = LoadRecords();
            string data = GetJsonData();

            User[] users = ReadToObject(data);

            UpdateRecords(localDB, users);

            for (int i = 0; i < users.Length; i++)
            {
                List<User> result = localDB.FindAll(delegate (User u) {
                    return u.lastname == users[i].lastname;
                    });
                foreach (var item in result)
                {
                    Console.WriteLine($"Matching Record, got name={item.firstname}, lastname={item.lastname}, age={item.totalpoints}");
                }
            }

            Console.ReadKey();
        }

        // Deserialize a JSON stream to a User object.
        public static User[] ReadToObject(string json)
        {
            User deserializedUser = new User();
            User[] users = { };
            MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(json));
            DataContractJsonSerializer ser = new DataContractJsonSerializer(users.GetType());

            users = ser.ReadObject(ms) as User[];

            ms.Close();
            return users;
        }

        // Simulated operation that returns JSON data.
        public static string GetJsonData()
        {
            string str = "[{ \"points\":4o,\"firstname\":\"Fred\",\"lastname\":\"Smith\"},{\"lastName\":\"Jackson\"}]";
            return str;
        }

        public static List<User> LoadRecords()
        {
            var db = new List<User> { };
            User user1 = new User();
            user1.firstname = "Joe";
            user1.lastname = "Smith";
            user1.totalpoints = 41;

            db.Add(user1);

            User user2 = new User();
            user2.firstname = "Pete";
            user2.lastname = "Peterson";
            user2.totalpoints = 30;

            db.Add(user2);

            return db;
        }
        public static void UpdateRecords(List<User> db, User[] users)
        {
            bool existingUser = false;

            for (int i = 0; i < users.Length; i++)
            {
                foreach (var item in db)
                {
                    if (item.lastname == users[i].lastname && item.firstname == users[i].firstname)
                    {
                        existingUser = true;
                        item.totalpoints += users[i].points;

                    }
                }
                if (existingUser == false)
                {
                    User user = new User();
                    user.firstname = users[i].firstname;
                    user.lastname = users[i].lastname;
                    user.totalpoints = users[i].points;

                    db.Add(user);
                }
            }
        }
    }

    [DataContract]
    internal class User
    {
        [DataMember]
        internal string firstname;

        [DataMember]
        internal string lastname;

        [DataMember]
        // internal double points;
        internal string points;

        [DataMember]
        internal int totalpoints;
    }
}
```

## <a name="find-the-red-and-green-squiggles"></a>Найти волнистые линии красного и зеленого!

Прежде чем запустить пример приложения и запустить отладчик, проверьте код в редакторе кода для красной и зеленой волнистой линией. Они представляют собой ошибки и предупреждения, которые идентифицируются по анализатор кода интегрированной среды разработки. Красные волнистые линии, ошибки времени компиляции, которого необходимо исправить, прежде чем можно запустить код. Зеленой волнистой линией являются предупреждениями. Несмотря на то, что часто, можно запустить приложение без исправления предупреждения, они могут стать источником ошибок и вы часто избежать лишних хлопот и расходования времени, изучив их. Эти ошибки и предупреждения будут отображены в **список ошибок** окна, если вы предпочитаете представления списка.

В примере приложения вы увидите несколько красные волнистые линии, которые необходимо исправить и один зеленый тот, который позволяет просмотреть. Вот первой ошибки.

![Ошибка отображения в виде красной волнистой линией](../debugger/media/write-better-code-red-squiggle.png)

Чтобы устранить эту ошибку, рассмотрим еще одна функция интегрированной среды разработки, представленный значок лампочки.

## <a name="check-the-light-bulb"></a>Проверьте лампочки!

Первый красной волнистой линией представляет ошибку времени компиляции. Наведите на нее, и вы увидите сообщение ```The name `Encoding` does not exist in the current context```.

Обратите внимание на то, что эта ошибка отображается значок лампочки в левый нижний угол. Вместе со значком отвертку ![отвертку значок](../ide/media/screwdriver-icon.png), значок лампочки ![значок лампочки](../ide/media/light-bulb-icon.png) представляет быстрых действий, которые помогут вам исправления или рефакторинга кода встроенный. Представляет лампочки факторы, которые *следует* исправить. Отвертку — для проблем, которые можно исправить. Используйте первое предложенное исправление, чтобы устранить эту ошибку, нажав кнопку **с помощью System.Text** слева.

![Использовать лампочки для исправления кода](../debugger/media/write-better-code-missing-include.png)

Если щелкнуть этот элемент, Visual Studio добавляет `using System.Text` инструкция в верхней части *Program.cs* файл, а красная волнистая линия исчезнет. (Если вы не знаете, что сделает предложенное исправление, выберите **Предварительный просмотр изменений** ссылку справа перед установкой исправления.)

Предыдущую ошибку это общая, обычно устранить, добавив новый `using` в код оператор. Существует несколько распространенных, как и ошибок в этот узел, например ```The type or namespace `Name` cannot be found.``` ошибки такого рода может означать отсутствует ссылка на сборку (щелкните правой кнопкой мыши проект, выберите **добавить** > **ссылку**), имя написано с ошибками или библиотеку отсутствует, необходимо добавить (для C#, щелкните правой кнопкой мыши проект и выберите пункт **управление пакетами NuGet**).

## <a name="fix-the-remaining-errors-and-warnings"></a>Исправьте оставшиеся ошибки и предупреждения

Существует несколько дополнительных волнистые линии для просмотра в этом коде. Здесь вы увидите распространенная ошибка преобразования типа. При наведении указателя мыши наведен на волнистую линию, вы видите, что код пытается преобразовать строку в значение типа int, который не поддерживается, пока вы не добавите явного кода, чтобы выполнить преобразование.

![Ошибка преобразования типа](../debugger/media/write-better-code-conversion-error.png)

Поскольку анализатор кода не определила намерения пользователя, существуют не лампочки, вам помогут это время. Чтобы устранить эту ошибку, необходимо знать назначение кода. В данном случае это не слишком сложно понять, `points` должен быть значением числовой (целое число), так как вы пытаетесь добавить `points` для `totalpoints`.

Чтобы устранить эту ошибку, измените `points` членом `User` от этого класса:

```csharp
[DataMember]
internal string points;
```

на эту:

```csharp
[DataMember]
internal int points;
```

Убрать красной волнистой линией в редакторе кода.

Затем наведите указатель мыши зеленой волнистой линией, если в объявлении `points` элемент данных. Анализатор кода о том, что переменной никогда не присвоено значение.

![Предупреждение для переменной](../debugger/media/write-better-code-warning-message.png)

Как правило это представляет проблему, которая должна быть исправлена. Тем не менее, в примере приложения на самом деле данные сохраняются в `points` переменных во время процесса десериализации, а затем полученное значение к добавляется `totalpoints` элемент данных. В этом примере вы знать назначение кода и можно игнорировать это предупреждение. Тем не менее если вы хотите устранить предупреждение, можно заменить следующий код:

```csharp
item.totalpoints = users[i].points;
```

следующим кодом:

```csharp
item.points = users[i].points;
item.totalpoints += users[i].points;
```

Зеленая волнистая линия исчезнет.

## <a name="fix-an-exception"></a>Исправить исключение

Исправлена красные волнистые линии и разрешить — или хотя бы изучить--все зеленой волнистой линией, вы готовы запустить отладчик и запустить приложение.

Нажмите клавишу **F5** (**Отладка > Начать отладку**) или кнопку **Начать отладку** ![Начать отладку](../debugger/media/dbg-tour-start-debugging.png "Начать отладку ") на панели инструментов отладки.

На этом этапе пример приложения создает `SerializationException` исключение (ошибка времени выполнения). То есть приложение этом данных, он пытается получить сериализации. Так как вы запустили приложение в режиме отладки (отладчик присоединен), отладчик по исправлению ошибок можно перейти прямо код, вызвавший исключение и предоставляет сообщения о возникающих ошибках.

![Возникает исключение SerializationException](../debugger/media/write-better-code-serialization-exception.png)

Сообщение об ошибке указывает, что вы, значение `4o` нельзя проанализировать как целое число. Таким образом, в этом примере вы знаете данных недопустим: `4o` должно быть `40`. Тем не менее если вы не в контроль над данными в реальном сценарии (скажем, вы получаете из веб-службы), что делать, об этом? Как это исправить?

Когда будет достигнута исключение, необходимо задать (вопросы и получить) несколько вопросов:

* Является ли это исключение только ошибки, которые можно устранить? Или

* -Это исключение, то, что пользователи могут возникнуть?

Если это первый вариант исправления ошибки. (В примере приложения, это значит, что исправить неверные данные.) Если это последний, может потребоваться обработать исключение в коде с помощью `try/catch` блока (взглянуть на другие возможные стратегии в следующем разделе). В примере приложения замените следующий код:

```csharp
users = ser.ReadObject(ms) as User[];
```

следующим кодом:

```csharp
try
{
    users = ser.ReadObject(ms) as User[];
}
catch (SerializationException)
{
    Console.WriteLine("Give user some info or instructions, if necessary");
    // Take appropriate action for your app
}
```

Объект `try/catch` блок содержит некоторые влиять на производительность, поэтому вы только хотите использовать их, когда они действительно нужны, то есть где (a), они могут возникнуть в окончательной версии приложения и там, где (b) документации для метода указывает, что необходимо проверить исключение, (при условии, что документация полный!). Во многих случаях может обработать исключение соответствующим образом и пользователю не нужно знать об этом.

Вот несколько важных советов для обработки исключений:

* Старайтесь не использовать пустой блок catch, например `catch (Exception) {}`, который не принимает соответствующие действия для предоставления или обработать ошибку. Блок catch пуст или не информативные может скрыть исключения и делает код более сложным для отладки вместо проще.

* Используйте `try/catch` блок вокруг определенной функции, который создает исключение (`ReadObject`, в примере приложения). Если вы используете вокруг больший кусок кода, вы в итоге скрытие расположение ошибки. Например, не используйте `try/catch` блок вокруг вызова родительской функцией `ReadToObject`, показанный здесь, или вы не знаете точно возникновения исключения.

    ```csharp
    // Don't do this
    try
    {
        User[] users = ReadToObject(data);
    }
    catch (SerializationException)
    {
    }
    ```

* Для ознакомления функций, включенных в приложении, специально их взаимодействия с внешними данными (например, веб-запроса) обратитесь к документации, чтобы увидеть, какие исключения функции, скорее всего, породит. Это может быть критически важные сведения для соответствующей обработки ошибок, а также для отладки приложения.

Пример приложения, устранить `SerializationException` в `GetJsonData` метод, изменив `4o` для `40`.

## <a name="clarify-your-code-intent-by-using-assert"></a>Уточнения кода с помощью assert

Нажмите кнопку **Перезапустить** ![Перезапустить приложение](../debugger/media/dbg-tour-restart.png "Перезапустить приложение") на панели инструментов отладки (**CTRL** + **SHIFT** + **F5**). Это перезапускает приложение за несколько шагов. Можно увидеть следующий результат в окне консоли.

![Значение NULL в выходных данных](../debugger/media/write-better-code-using-assert-null-output.png)

Вы увидите что-нибудь в этих выходных данных, не совсем правильно. **имя** и **lastname** для третьей записи являются пустыми!

Это хороший момент поговорить о полезных кодирования, часто недостаточно, который заключается в использовании `assert` инструкции в функции. Добавив следующий код, включить проверку времени выполнения, чтобы убедиться в том, что `firstname` и `lastname` не `null`. Замените код в `UpdateRecords` метод:

```csharp
if (existingUser == false)
{
    User user = new User();
    user.firstname = users[i].firstname;
    user.lastname = users[i].lastname;
```

следующим кодом:

```csharp
// Also, add a using statement for System.Diagnostics at the start of the file.
Debug.Assert(users[i].firstname != null);
Debug.Assert(users[i].lastname != null);
if (existingUser == false)
{
    User user = new User();
    user.firstname = users[i].firstname;
    user.lastname = users[i].lastname;
```

Добавив `assert` подобные утверждения к функции во время разработки, вы можете помочь намерение кода. В приведенном выше примере мы указываем следующее:

* Допустимое строковое выражение является обязательным для имени
* Допустимое строковое выражение является обязательным для имени последнего

Указав намерение таким образом, можно принудительно применить вашим требованиям. Это простой и удобный метод, который можно использовать для поверхности ошибок во время разработки. (`assert` инструкции также используются как основной элемент в модульных тестах.)

Нажмите кнопку **Перезапустить** ![Перезапустить приложение](../debugger/media/dbg-tour-restart.png "Перезапустить приложение") на панели инструментов отладки (**CTRL** + **SHIFT** + **F5**).

> [!NOTE]
> `assert` Код будет активен только в отладочной сборке.

При перезапуске, отладчик приостанавливает на `assert` инструкции, так как выражение `users[i].firstname != null` принимает значение `false` вместо `true`.

![Утверждать автоматически преобразуется в значение false](../debugger/media/write-better-code-using-assert.png)

`assert` Ошибка сообщает, что имеется проблема, вам нужно проанализировать. `assert` можно охватывают множество сценариев, где вы не видите обязательно исключение. В этом примере пользователь не увидит исключение и `null` значение добавляется как `firstname` в ваш список записей. Это может вызвать проблемы позже (например, см. в выходных данных консоли) и может быть сложнее для отладки.

> [!NOTE]
> В сценариях, где можно вызвать метод `null` значение, `NullReferenceException` результаты. Обычно необходимо избегать использования `try/catch` блокировать общее исключение, то есть исключение, которое не привязан к функции указанную библиотеку. Любой объект может вызвать исключение `NullReferenceException`. Если вы не уверены, обратитесь к документации, функции библиотеки.

В процессе отладки, желательно сохранить определенный `assert` инструкции, пока вы знаете, что вам нужно заменить средство фактический код. Предположим, что вы решите, что пользователю могут возникнуть исключение в окончательной сборке приложения. В этом случае необходимо выполнить рефакторинг кода, чтобы убедиться в том, что приложение не неустранимые исключения или привести к другой ошибки. Таким образом Чтобы исправить этот код, замените следующий код:

```csharp
if (existingUser == false)
{
    User user = new User();
```

следующим кодом:

```csharp
if (existingUser == false && users[i].firstname != null && users[i].lastname != null)
{
    User user = new User();
```

С помощью следующего кода, соответствуют требованиям код и убедитесь, что запись с `firstname` или `lastname` значение `null` не добавляется к данным.

В этом примере мы добавили два `assert` операторы внутри цикла. Как правило при использовании `assert`, лучше всего добавить `assert` инструкций точке входа (начало), функции или метода. В настоящее время вы просматриваете `UpdateRecords` метод в примере приложения. В этом методе вы знаете, вы находитесь в возникли проблемы, если любой из аргументов метода `null`, поэтому необходимо проверять их с `assert` инструкцию точке входа функции.

```csharp
public static void UpdateRecords(List<User> db, User[] users)
{
    Debug.Assert(db != null);
    Debug.Assert(users != null);
```

Для приведенных выше инструкциях ваша цель — загружать существующие данные (`db`) и получить новые данные (`users`) перед обновлением ничего.

Можно использовать `assert` с какой-либо выражение, результатом которого `true` или `false`. Таким образом, например, можно добавить `assert` -оператор наподобие следующего.

```csharp
Debug.Assert(users[0].points > 0);
```

Приведенный выше код полезно, если вы хотите указать следующие цели: новое значение точки больше нуля (0) является обязательным для обновления записи пользователя.

## <a name="inspect-your-code-in-the-debugger"></a>Проверка кода в отладчике

Итак теперь, когда вы исправили все критические, что не так с примером приложения, можно переместить на другие важные вещи!

Мы показали вам отладчика по исправлению, но отладчик будет гораздо более мощный инструмент, который также позволяет вам выполнять другие задачи, такие как пошаговое выполнение кода и проверять его переменных. Эти возможности полезны во многих ситуациях, особенно следующие:

* Вы пытаетесь изолировать ошибки среды выполнения в коде, но не можете это сделать с помощью методов и инструментов, рассмотренных ранее.

* Требуется проверка кода, то есть, просмотрите его во время его выполнения, чтобы убедиться в том, он работает в должным образом и это, что вам нужно.

    Полезно посмотреть код во время его выполнения. Дополнительные сведения о коде таким образом и часто можно выявить ошибки, прежде чем они манифеста очевидные признаки.

Чтобы узнать, как использовать основные функции отладчика, см. в разделе [отладки для начинающих](../debugger/debugging-absolute-beginners.md).

## <a name="fix-performance-issues"></a>Исправление проблем производительности

Ошибки другого типа включают неэффективный код, приложение работает медленно или использовать слишком много памяти. Как правило оптимизация производительности — это можно сделать позже в процессе разработки приложения. Тем не менее, могут возникнуть проблемы с производительностью раньше (например, вы см. что некоторая часть приложение работает медленно), и может потребоваться протестировать приложение с помощью средств профилирования на раннем этапе. Дополнительные сведения о профилировании средства, такие как средство использования ЦП и анализатором памяти, см. в разделе [сначала посмотрим, средства профилирования](../profiling/profiling-feature-tour.md).

## <a name="next-steps"></a>Следующие шаги

В этой статье вы узнали, как избежать и устранить многие распространенные ошибки в коде и когда следует использовать отладчик. Далее Дополнительные сведения об использовании отладчика Visual Studio для исправления ошибок.

> [!div class="nextstepaction"]
> [Отладка для начинающих](../debugger/debugging-absolute-beginners.md)
