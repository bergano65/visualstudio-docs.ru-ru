---
title: 'CA2117: APTCA-типы должны расширять только базовые APTCA-типы'
ms.date: 11/04/2016
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- CA2117
- AptcaTypesShouldOnlyExtendAptcaBaseTypes
helpviewer_keywords:
- AptcaTypesShouldOnlyExtendAptcaBaseTypes
- CA2117
ms.assetid: c505b586-2f1e-47cb-98ee-a5afcbeda70f
author: gewarren
ms.author: gewarren
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 8dac5acc0b7c7fff02862853bfd996362f80d1cc
ms.sourcegitcommit: 568bb0b944d16cfe1af624879fa3d3594d020187
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2018
ms.locfileid: "45547504"
---
# <a name="ca2117-aptca-types-should-only-extend-aptca-base-types"></a>CA2117: APTCA-типы должны расширять только базовые APTCA-типы

|||
|-|-|
|TypeName|AptcaTypesShouldOnlyExtendAptcaBaseTypes|
|CheckId|CA2117|
|Категория|Microsoft.Security|
|Критическое изменение|Критическое|

## <a name="cause"></a>Причина

Открытый или защищенный тип в сборке с <xref:System.Security.AllowPartiallyTrustedCallersAttribute?displayProperty=fullName> атрибут наследует от типа, объявленного в сборку, которая не имеет атрибута.

## <a name="rule-description"></a>Описание правила

По умолчанию, открытые или защищенные типы в сборках со строгими именами неявно защищены [InheritanceDemand](xref:System.Security.Permissions.SecurityAction#System_Security_Permissions_SecurityAction_InheritanceDemand) полного доверия. Сборки со строгими именами, имеющие <xref:System.Security.AllowPartiallyTrustedCallersAttribute> атрибут (APTCA) нет эту защиту. Атрибут отменяет требование наследования. Предоставлять типы, объявленные в сборке без требования наследования являются наследуемыми типами, не имеющие полного доверия.

Если в полностью доверенной сборке присутствует атрибут APTCA и тип в сборке наследует от типа, который не позволяет частично доверенным вызывающим объектам, возможен уязвимости безопасности. Если два типа `T1` и `T2` удовлетворять следующим условиям, злоумышленники могут использовать тип `T1` обходить требование наследования неявное полного доверия, который защищает `T2`:

- `T1` открытый тип, объявленный в полностью доверенной сборке, помеченной атрибутом APTCA.

- `T1` наследует от типа `T2` за пределами его сборки.

- `T2`сборка не имеет атрибута APTCA и, таким образом, не следует наследуемым типы в сборках с частичным доверием.

Частично доверенный тип `X` может наследовать от `T1`, который предоставляет доступ к унаследованные члены, объявленные в `T2`. Так как `T2` не имеет атрибута APTCA, его непосредственного производного типа (`T1`) должны удовлетворять требованию наследования с полным доверием; `T1` имеет полное доверие и пройти проверку. Угроза безопасности возникает, так как `X` не участвует в проверке требования наследования, которая защищает `T2` из ненадежного подклассов. По этой причине типы с атрибутом APTCA не должны расширять типы, у которых нет атрибута.

Еще одна проблема безопасности и возможно более распространена, это производный тип (`T1`) до появления ошибки подвергает защищенных членов из типа, который требует полного доверия (`T2`). При возникновении этой экспозиции, ненадежных вызывающих объектов получить доступ к данным, который должен быть доступен только для типов с полным доверием.

## <a name="how-to-fix-violations"></a>Устранение нарушений

Если тип, о которых сообщает нарушение в сборке, которая не требует атрибут APTCA, удалите его.

Если требуется атрибут APTCA, добавьте к наследованию для полного доверия к типу. Требование наследования обеспечит защиту от наследования типов без доверия.

Это возможно устранить нарушение, добавив атрибут APTCA сборок из базовых типов, о которых сообщает нарушения. Этого не сделать подобные тщательного изучения безопасности весь код в сборках и весь код, который зависит от сборки.

## <a name="when-to-suppress-warnings"></a>Отключение предупреждений

Чтобы безопасно подавить предупреждение из этого правила, необходимо убедиться, что защищенные члены, предоставляемые типом прямо или косвенно запретить ненадежным вызывающим объектам доступ к конфиденциальной информации, операции или ресурсы, которые могут использоваться в злонамеренных целях.

## <a name="example"></a>Пример

В следующем примере две сборки и тестовое приложение для демонстрации уязвимости системы безопасности, обнаруживаемый этим правилом. Первая сборка не имеет атрибута APTCA и не должно быть наследуемым частично доверенные типы (представленный `T2` в описании выше).

[!code-csharp[FxCop.Security.NoAptcaInherit#1](../code-quality/codesnippet/CSharp/ca2117-aptca-types-should-only-extend-aptca-base-types_1.cs)]

Вторая сборка, представленный `T1` в предыдущем описании, является полностью доверенной и позволяет частично доверенным вызывающим объектам.

[!code-csharp[FxCop.Security.YesAptcaInherit#1](../code-quality/codesnippet/CSharp/ca2117-aptca-types-should-only-extend-aptca-base-types_2.cs)]

Тип теста, представленный `X` в предыдущем описании, находится в сборке с частичным доверием.

[!code-csharp[FxCop.Security.TestAptcaInherit#1](../code-quality/codesnippet/CSharp/ca2117-aptca-types-should-only-extend-aptca-base-types_3.cs)]

В этом примере выводятся следующие данные:

```txt
Meet at the shady glen 2/22/2003 12:00:00 AM!
From Test: sunny meadow
Meet at the sunny meadow 2/22/2003 12:00:00 AM!
```

## <a name="related-rules"></a>Связанные правила

[CA2116: методы APTCA должны вызывать только методы APTCA](../code-quality/ca2116-aptca-methods-should-only-call-aptca-methods.md)

## <a name="see-also"></a>См. также

- [Правила написания безопасного кода](/dotnet/standard/security/secure-coding-guidelines)
- [Использование библиотек из частично доверенного кода](/dotnet/framework/misc/using-libraries-from-partially-trusted-code)
