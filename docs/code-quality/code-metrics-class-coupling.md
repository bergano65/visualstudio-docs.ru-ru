---
title: Метрики кода — связь классов
ms.date: 1/8/2021
description: Сведения о метрике взаимосвязей классов для метрик кода в Visual Studio.
ms.topic: conceptual
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: db1308843cb3c4fe8fb0a4aa32300e545e5e3a7c
ms.sourcegitcommit: b1f7e7d7a0550d5c6f46adff3bddd44bc1d6ee1c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/11/2021
ms.locfileid: "98069561"
---
# <a name="code-metrics---class-coupling"></a>Метрики кода — связь классов

Связь классов также проходит по имени, связанному между объектами (статистические), как изначально определено в [CK94](#ck94). В сущности, связанность классов — это мера того, сколько классов использует один класс. Большое число является недопустимым, а низкое число обычно хорошо подходит для этой метрики. Связь класса показана как точный прогноз сбоев программного обеспечения, и последние исследования показали, что максимальное значение 9 является наиболее эффективным [S2010](#s2010).

Согласно документации Майкрософт, присоединение классов "измеряет связь с уникальными классами через параметры, локальные переменные, возвращаемые типы, вызовы методов, общие экземпляры или шаблоны шаблонов, базовые классы, реализации интерфейса, поля, определенные для внешних типов и декорирования атрибутов. Хорошая разработка программного обеспечения определяет, что типы и методы должны иметь высокую связность и низкую связь. Высокая связь указывает на проект, который трудно использовать и поддерживать из-за множества взаимозависимостей от других типов. "

Понятия связывания и связности четко связаны. Чтобы не усложнять это обсуждение, мы не будем глубоко использовать связность, отличную от [KKLS2000](#kkls2000):

"Связность модулей появилась в Йоурдон и Константине как" тесно привязанные или связанные с ними внутренние элементы модуля — один другой " [YC79](#yc79). Модуль имеет сильную связность, если он представляет ровно одну задачу [...], и все ее элементы вносят вклад в эту единственную задачу. Они описывают связность как атрибут проектирования, а не кода, и атрибут, который можно использовать для прогнозирования повторного использования, удобства сопровождения и удобства изменения ".

## <a name="class-coupling-example"></a>Пример взаимосвязей классов

Рассмотрим взаимосвязь классов в действии. Сначала создайте новое консольное приложение и создайте в нем новый класс Person с некоторыми свойствами, а затем сразу Вычислите метрики кода:

![Пример взаимосвязей классов 1](media/class-coupling-example-1.png)

Обратите внимание, что класс связан с 0, так как этот класс не использует другие классы. Теперь создайте другой класс с именем Персонстуфф и метод, который создает экземпляр Person и задает значения свойств. Повторно Вычислите метрики кода:

![Пример взаимосвязей классов 2](media/class-coupling-example-2.png)

Видите, как поступает значение, связанное с классом? Кроме того, обратите внимание, что независимо от того, сколько свойств задается, значение, связанное с классом, просто переходит на 1, а не на другое значение. Взаимосвязь классов измеряет каждый класс только один раз для этой метрики независимо от того, насколько он используется. Кроме того, можно увидеть, что `DoSomething()` имеет значение 1, но конструктор, `PersonStuff()` имеет 0 в качестве значения? В настоящее время в конструкторе нет кода, использующего другой класс.

Что делать, если разместить код в конструкторе, который использовал другой класс? Вот что вы получаете:

![Пример связывания классов 3](media/class-coupling-example-3.png)

Теперь конструктор явно имеет код, использующий другой класс, и метрика взаимосвязей классов показывает этот факт. Опять же, можно увидеть, что общая связь классов для `PersonStuff()` равна 1, а `DoSomething()` также 1, чтобы показать, что используется только один внешний класс вне зависимости от того, какой объем внутреннего кода используется.

Затем создайте еще один новый класс. Присвойте этому классу имя и создайте в нем некоторые свойства:

![Пример связывания классов — Добавление нового класса](media/class-coupling-example-add-new-class.png)

Теперь используйте класс в нашем `DoSomething()` методе в `PersonStuff` классе и снова Вычислите метрики кода:

![Пример связывания классов 4](media/class-coupling-example-4.png)

Как видите, класс, взаимосвязанный с классом Персонстуфф, переходит до 2 и, при детализации класса, можно увидеть, что `DoSomething()` метод имеет наибольшую взаимозависимость, но конструктор по-прежнему использует только 1 класс.  Используя эти метрики, можно увидеть общее максимальное число для данного класса и подробно изучить подробные сведения по каждому элементу.

## <a name="the-magic-number"></a>Магическое число

Как и в случае сложности сложностью организации циклов, нет ограничений, подходящему для всех организаций. Однако [S2010](#s2010) указывает, что оптимальным является ограничение в 9:

"Поэтому мы будем рассматривать пороговые значения [...] как самое эффективное. Эти пороговые значения (для одного элемента) — статистические = 9 [...]. (выделение добавлено)

## <a name="code-analysis"></a>Анализ кода

Анализ кода включает категорию правил сопровождения. Дополнительные сведения см. в разделе [правила удобства поддержки](/dotnet/fundamentals/code-analysis/quality-rules/maintainability-warnings). При использовании анализа кода прежних версий расширенный набор правил по проектированию содержит область обслуживания:

![Расширенные правила разработки, связанные с классами](media/class-coupling-extended-design-guideline-rules.png)

Внутри области обслуживания находится правило для взаимосвязей классов:

![Правило взаимосвязей классов](media/class-coupling-maintainability-area-rules.png)

Это правило выдает предупреждение при чрезмерном взаимосвязанности классов. Дополнительные сведения см. в разделе [CA1506. Избегайте чрезмерного связывания классов](/dotnet/fundamentals/code-analysis/quality-rules/ca1506).

Описание этого правила см. в записи блога о архивированном анализе кода: [метрики кода в качестве политики возврата](/archive/blogs/codeanalysis/code-metrics-as-check-in-policy) и предупреждение о пороговом описании *выше 80 для класса и более 30 для метода*.  Эти значения кажутся ненормальными, но по крайней мере обеспечивают максимальный предел. Если вы выйдете это предупреждение, то что-то почти определенно не так.

## <a name="citations"></a>Цитат

### <a name="ck94"></a>CK94

Чидамбер, S. R. & Кемерер, C. F. (1994). Набор метрик для объектно-ориентированного проектирования (IEEE Transactions on Software Engineering, vol. 20, No. 6). Получено 14 мая 2011 с веб-сайта университета Pittsburgh: [http://www.pitt.edu/~ckemerer/CK%20research%20papers/MetricForOOD_ChidamberKemerer94.pdf](http://www.pitt.edu/~ckemerer/CK%20research%20papers/MetricForOOD_ChidamberKemerer94.pdf)

### <a name="kkls2000"></a>KKLS2000

Кабаили, H., Келлер, R., Лустман, F. и Сен-Денис, G. (2000). Несвязное посещение классов: опытное исследование на отраслевых системах (материалы с учетом количественных подходов в Object-Oriented проектирования программного обеспечения). Получено 20 мая 2011 с веб-сайта Университé де Монтрéал [http://www.iro.umontreal.ca/~sahraouh/qaoose/papers/Kabaili.pdf](http://www.iro.umontreal.ca/~sahraouh/qaoose/papers/Kabaili.pdf)

### <a name="sk2003"></a>SK2003

Субраманям, R. & Кришнан (, M. S. (2003). Опытный анализ метрик CK для Object-Oriented сложность проектирования: влияние на дефекты программного обеспечения (IEEE Transactions on Software Engineering, vol. 29, No. 4). Полученные 14 мая 2011 г. с университетом веб-сайта Массачусетс Дартмаус [http://moosehead.cis.umassd.edu/cis580/readings/OO_Design_Complexity_Metrics.pdf](http://moosehead.cis.umassd.edu/cis580/readings/OO_Design_Complexity_Metrics.pdf)

### <a name="s2010"></a>S2010

Шатнави, R. (2010). Количественное исследование приемлемых уровней риска Object-Oriented метрик в системах Open-Source (IEEE Transactions on Software Engineering, vol. 36, No. 2).

### <a name="yc79"></a>YC79

Эдвард Йоурдон и Ларри L. Константине. Структурированный дизайн. Prentice зал, Енглевуд Клиффс, Н.Ж., 1979.