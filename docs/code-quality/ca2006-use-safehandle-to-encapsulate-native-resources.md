---
title: CA2006. Используйте SafeHandle для инкапсуляции собственных ресурсов
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA2006
- UseSafeHandleToEncapsulateNativeResources
helpviewer_keywords:
- UseSafeHandleToEncapsulateNativeResources
- CA2006
ms.assetid: a71950bd-bcc1-463d-b1f2-5233bc451456
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- cplusplus
ms.openlocfilehash: 6d29eb9475d48e634766df65836162d6a79fed77
ms.sourcegitcommit: 1024f336dcd8e8a4c50b9a9ad8ec85b6e70073a8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/09/2019
ms.locfileid: "57699633"
---
# <a name="ca2006-use-safehandle-to-encapsulate-native-resources"></a>CA2006. Используйте SafeHandle для инкапсуляции собственных ресурсов

|||
|-|-|
|TypeName|UseSafeHandleToEncapsulateNativeResources|
|CheckId|CA2006|
|Категория|Microsoft.Reliability|
|Критическое изменение|Не критическое|

## <a name="cause"></a>Причина

Управляемый код использует <xref:System.IntPtr> обратиться к собственным ресурсам.

## <a name="rule-description"></a>Описание правила

Использование `IntPtr` в управляемом коде может свидетельствовать о потенциальных проблемах безопасности и надежности. Все случаи использования `IntPtr` необходимо изучить, чтобы определить ли использование <xref:System.Runtime.InteropServices.SafeHandle> , или аналогичную технологию, на его месте. Проблемы возникают в том случае, если `IntPtr` представляет некоторые машинный ресурс, например память, дескриптор файла или сокета, что управляемый код считается владельцем. Если управляемый код, которому принадлежит ресурс, он должен также освободить машинные ресурсы, связанные с ним, так как Невыполнение этого требования приведет утечки ресурсов.

В таких случаях проблемы безопасности или надежности также будет существовать, если многопоточный доступ может быть `IntPtr` и способ освобождения ресурса, представленного `IntPtr` предоставляется. Эти проблемы связаны перезапуск с `IntPtr` значение освобождения ресурса во время одновременного использования ресурса выполняется в другом потоке. Это может привести к конкуренции, где один поток можно считывать или записывать данные, связанные с неправильный ресурс. Например, если дескриптор операционной системы, как хранение в типе `IntPtr` и позволяет пользователям следует вызвать оба **закрыть** и любой другой метод, использующий этот дескриптор одновременно и без какого-либо рода синхронизации, код содержит вторичное использование дескриптора проблема.

Это проблема повторного использования дескриптора может привести к повреждению данных, а иногда и уязвимость системы безопасности. `SafeHandle` и его одноуровневый класс <xref:System.Runtime.InteropServices.CriticalHandle> предоставляют механизм для инкапсуляции собственный дескриптор для ресурса, так что можно избежать такой проблемы с потоками. Кроме того, можно использовать `SafeHandle` и того же уровня класса `CriticalHandle` для других проблем многопоточности, например, тщательно управление временем существования управляемых объектов, которые содержат копию собственный дескриптор через вызовы собственных методов. В этом случае его можно удалить вызовы `GC.KeepAlive`. Избежать потери производительности, которые возникают при использовании `SafeHandle` и в меньшей степени `CriticalHandle`, часто можно сократить до тщательного проектирования.

## <a name="how-to-fix-violations"></a>Устранение нарушений

Преобразовать `IntPtr` использования `SafeHandle` для безопасного управления неуправляемыми ресурсами. См. в разделе <xref:System.Runtime.InteropServices.SafeHandle> справочной статье примеры.

## <a name="when-to-suppress-warnings"></a>Отключение предупреждений

Нельзя отключить это предупреждение.

## <a name="see-also"></a>См. также

- <xref:System.IDisposable>