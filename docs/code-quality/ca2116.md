---
title: CA2116. APTCA-методы должны вызывать только APTCA-методы
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- AptcaMethodsShouldOnlyCallAptcaMethods
- CA2116
helpviewer_keywords:
- AptcaMethodsShouldOnlyCallAptcaMethods
- CA2116
ms.assetid: 8b91637e-891f-4dde-857b-bf8012270ec4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 1c557fb7967b6de7c4708a37c6187f5145e3e19e
ms.sourcegitcommit: 5caad925ca0b5d136416144a279e984836d8f28c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/07/2020
ms.locfileid: "89508864"
---
# <a name="ca2116-aptca-methods-should-only-call-aptca-methods"></a>CA2116. APTCA-методы должны вызывать только APTCA-методы

|Элемент|Значение|
|-|-|
|CheckId|CA2116|
|Категория|Microsoft.Security|
|Критическое изменение|Критическое|

## <a name="cause"></a>Причина
Метод в сборке с <xref:System.Security.AllowPartiallyTrustedCallersAttribute?displayProperty=fullName> атрибутом вызывает метод в сборке, не имеющей атрибута.

> [!NOTE]
> Это правило было признано устаревшим. Дополнительные сведения см. в разделе [устаревшие правила](fxcop-unported-deprecated-rules.md).

## <a name="rule-description"></a>Описание правила

По умолчанию открытые или защищенные методы в сборках со строгими именами неявно защищаются с помощью [ссылки на запросы](/dotnet/framework/misc/link-demands) полного доверия. только полностью доверенные вызывающие объекты могут обращаться к сборке со строгим именем. Сборки со строгими именами, помеченные <xref:System.Security.AllowPartiallyTrustedCallersAttribute> атрибутом (APTCA), не имеют такой защиты. Атрибут отключает запрос компоновки, делая сборку доступным для вызывающих объектов, которые не имеют полного доверия, например кода, выполняемого из интрасети или Интернета.

Если атрибут APTCA имеется в полностью доверенной сборке, а сборка выполняет код в другой сборке, которая не допускает частично доверенных вызывающих объектов, возможно, используется уязвимость безопасности. Если два метода `M1` и `M2` отвечают приведенным ниже условиям, то вредоносные вызывающие объекты могут использовать метод `M1` для обхода неявного запроса ссылки с полным доверием, защищающего `M2` :

- `M1` — Это открытый метод, объявленный в полностью доверенной сборке, имеющей атрибут APTCA.

- `M1` вызывает метод `M2` вне `M1` сборки.

- `M2`не имеет атрибута APTCA и, следовательно, не должен выполняться или от имени вызывающих объектов с частичным доверием.

Вызывающий объект с частичным доверием `X` может вызвать метод `M1` , вызывающий `M1` вызов метода `M2` . Поскольку не `M2` имеет атрибута APTCA, его непосредственный вызывающий объект ( `M1` ) должен удовлетворять требованию ссылки для полного доверия; `M1` имеет полное доверие и, следовательно, удовлетворяет этой проверке. Угроза безопасности заключается в том, что не `X` участвует в выполнении запроса компоновки, который защищает `M2` от ненадежных вызывающих объектов. Поэтому методы с атрибутом APTCA не должны вызывать методы, не имеющие атрибута.

## <a name="how-to-fix-violations"></a>Устранение нарушений
Если требуется атрибут АПКТА, используйте требование для защиты метода, который вызывает сборку с полным доверием. Точные требуемые разрешения зависят от функциональных возможностей, предоставляемых вашим методом. Если возможно, защитите метод с помощью запроса полного доверия, чтобы обеспечить недоступность базовой функциональности вызывающим объектам с частичным доверием. Если это невозможно, выберите набор разрешений, которые эффективно защищают предоставляемую функциональность.

## <a name="when-to-suppress-warnings"></a>Когда следует подавлять предупреждения
Чтобы безопасно отключить предупреждение из этого правила, необходимо убедиться, что функциональные возможности, предоставляемые методом, напрямую или косвенно разрешают вызывающим объектам доступ к конфиденциальным сведениям, операциям или ресурсам, которые могут быть использованы необратимым образом.

## <a name="example-1"></a>Пример 1
В следующем примере используются две сборки и тестовое приложение для демонстрации уязвимости системы безопасности, обнаруженной этим правилом. Первая сборка не имеет атрибута APTCA и не должна быть доступна для частично доверенных вызывающих объектов (представленных `M2` в предыдущем обсуждении).

[!code-csharp[FxCop.Security.NoAptca#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_1.cs)]

## <a name="example-2"></a>Пример 2
Вторая сборка является полностью доверенной и позволяет частично доверенным вызывающим объектам (представленным `M1` в предыдущем обсуждении).

[!code-csharp[FxCop.Security.YesAptca#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_2.cs)]

## <a name="example-3"></a>Пример 3
Тестовое приложение (представленное `X` в предыдущем обсуждении) является частично доверенным.

[!code-csharp[FxCop.Security.TestAptcaMethods#1](../code-quality/codesnippet/CSharp/ca2116-aptca-methods-should-only-call-aptca-methods_3.cs)]

В этом примере выводятся следующие данные:

```txt
Demand for full trust:Request failed.
ClassRequiringFullTrust.DoWork was called.
```

## <a name="related-rules"></a>Связанные правила

- [CA2117. APTCA-типы должны расширять только базовые APTCA-типы](../code-quality/ca2117.md)

## <a name="see-also"></a>См. также

- [Правила написания безопасного кода](/dotnet/standard/security/secure-coding-guidelines)
- [Использование библиотек из не вполне надежного кода](/dotnet/framework/misc/using-libraries-from-partially-trusted-code)
- [Требования связывания](/dotnet/framework/misc/link-demands)
- [Данные и моделирование](/dotnet/framework/data/index)
