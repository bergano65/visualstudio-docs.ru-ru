---
title: Основные сведения о языке SAL
ms.date: 11/04/2016
ms.prod: visual-studio-dev15
ms.topic: conceptual
ms.assetid: a94d6907-55f2-4874-9571-51d52d6edcfd
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: 56d416ce154f071804beb9b47d2623f2acee15af
ms.sourcegitcommit: 37fb7075b0a65d2add3b137a5230767aa3266c74
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/02/2019
ms.locfileid: "53889924"
---
# <a name="understanding-sal"></a>Основные сведения о языке SAL

Языка заметок исходного кода (SAL) для Microsoft предоставляет набор заметок, которые можно использовать для описания того, как функция использует свои параметры, какие предположения о них она делает и гарантии предоставляет при завершении. Примечания определены в файле заголовка `<sal.h>`. Для изменения анализа функций анализа кода Visual Studio для C++ использует примечания SAL. Дополнительные сведения о SAL 2.0 для разработки драйверов Windows, см. в разделе [заметок SAL 2.0 для Windows драйверы](http://go.microsoft.com/fwlink/?LinkId=250979).

В собственном коде C и C++ обеспечивают только ограниченной для разработчиков постоянно выразить намерение и неизменность. С помощью заметки SAL, можно описать функций более подробно, что разработчикам, использующим их можно лучше понять их использование.

## <a name="what-is-sal-and-why-should-you-use-it"></a>Что такое SAL и почему ее следует использовать?

Проще говоря, SAL — это недорогое позвольте компилятору проверки кода.

### <a name="sal-makes-code-more-valuable"></a>SAL делает код более ценным

SAL может помочь сделать проект код более понятным, как для пользователей, так и для средств анализа кода. Рассмотрим следующий пример, показывающий функция времени выполнения C `memcpy`:

```cpp

void * memcpy(
   void *dest,
   const void *src,
   size_t count
);
```

Узнать, что делает эту функцию? Когда функция реализации, или вызывается, чтобы обеспечить правильность программы должны поддерживаться некоторые свойства. Лишь взглянув на объявление, подобное показанному в примере, вы не знаете, что это такое. Без заметки SAL пришлось бы полагаться на документацию или комментарии к коду. Вот какие в документации MSDN для `memcpy` говорит:

> «Копирует количество байтов src в указанное место. Если источника и назначения перекрываются, поведение memcpy не определено. Используйте memmove для обработки перекрывающихся областей.
> **Примечание о безопасности.** Убедитесь в том, что буфер назначения равен или превосходит по размеру исходный буфер. Дополнительные сведения см. в разделе как избежать переполнения буфера.»

Документация содержит несколько битов сведений, которые предполагают, что код должен поддерживать определенные свойства, чтобы обеспечить правильность программы:

- `memcpy` Копирует `count` байтов из исходного буфера в буфер назначения.

- Буфер назначения должен быть по крайней мере в исходный буфер.

Однако компилятору не удается прочитать в документации или неофициальные комментарии. Он не знает, что имеется отношение между 2 буферами и `count`, и его также невозможно подобрать эффективно об отношении. SAL может большей наглядностью о свойствах и реализации функции, как показано ниже:

```cpp

void * memcpy(
   _Out_writes_bytes_all_(count) void *dest,
   _In_reads_bytes_(count) const void *src,
   size_t count
);
```

Обратите внимание на то, что эти заметки напоминают сведения в документации MSDN, но они являются более краткими, и они следуют семантической модели. Когда вы читаете этот код, может быстро подобрать свойств этой функции и как избежать проблем безопасности переполнение буфера. Более того семантических шаблонов, предоставляемых SAL может повысить эффективность средств анализа кода автоматических в раннее обнаружение потенциальных ошибок. Представьте, что кто-то записывает ошибками реализация `wmemcpy`:

```cpp

wchar_t * wmemcpy(
   _Out_writes_all_(count) wchar_t *dest,
   _In_reads_(count) const wchar_t *src,
   size_t count)
{
   size_t i;
   for (i = 0; i <= count; i++) { // BUG: off-by-one error
      dest[i] = src[i];
   }
   return dest;
}
```

Эта реализация содержит распространенной ошибкой из за другой. К счастью, автор кода включает размер буфера SAL-аннотации — это средство анализа кода может обработать ошибку путем анализа только этой функции.

### <a name="sal-basics"></a>Основные сведения о SAL
 SAL определяет четыре основные типа параметров, классифицированные по шаблону использования.

|Категория|Аннотация параметра|Описание:|
|--------------|--------------------------|-----------------|
|**Входные данные для вызова функции**|`_In_`|Данные вызываемой функции передается и обрабатывается как доступный только для чтения.|
|**Входные данные для вызвал функцию и вывода вызывающего объекта**|`_Inout_`|Полезные данные, передается в функцию, а потенциально изменяется.|
|**Выходные данные для вызывающего объекта**|`_Out_`|Вызывающий объект предоставляет только пространство для вызываемой функции для записи. Вызываемая функция записывает данные в этой области.|
|**Указатель на вызывающий объект выходные данные**|`_Outptr_`|Как и **выходные данные вызывающему**. Значение, которое возвращается вызываемая функция является указателем.|

 Эти четыре основные заметки явными могут стать более различными способами. По умолчанию с заметками указатель предполагается, что параметры обязательным — они должны иметь значение NULL для успешного выполнения функции. Наиболее часто используемые разновидность основные заметки указывает, что необязательный параметр-указатель, если он имеет значение NULL, функция по-прежнему добиться успеха в его работу.

 В этой таблице показано, как различать обязательные и необязательные параметры:

||Параметры являются обязательными|Параметры являются необязательными|
|-|-----------------------------|-----------------------------|
|**Входные данные для вызова функции**|`_In_`|`_In_opt_`|
|**Входные данные для вызвал функцию и вывода вызывающего объекта**|`_Inout_`|`_Inout_opt_`|
|**Выходные данные для вызывающего объекта**|`_Out_`|`_Out_opt_`|
|**Указатель на вызывающий объект выходные данные**|`_Outptr_`|`_Outptr_opt_`|

 Эти заметки для выявления возможных значений неинициализированный и недопустимый указатель null использует формальные и точным способом. Передача NULL для обязательного параметра может привести к сбою или может вызвать с кодом ошибки «сбой», должны быть возвращены. В любом случае функция не может успешно выполнять свою работу.

## <a name="sal-examples"></a>Примеры SAL
 В этом разделе показаны примеры кода для основных заметки SAL.

### <a name="using-the-visual-studio-code-analysis-tool-to-find-defects"></a>С помощью средства анализа кода в Visual Studio для поиска дефектов
 В примерах средство анализа кода Visual Studio используется вместе с аннотаций SAL для поиска дефектов кода. Вот как это сделать.

#### <a name="to-use-visual-studio-code-analysis-tools-and-sal"></a>Использование средств анализа кода Visual Studio и SAL

1.  В Visual Studio откройте проект C++, который содержит примечания SAL.

2.  В строке меню выберите **построения**, **выполнить анализ кода в решении**.

     Рассмотрите возможность \_в\_ пример в этом разделе. Это предупреждение отображается, если для выполнения анализа кода для:

    > **Недопустимое значение параметра C6387** «выберите команду» может быть "0": это не соответствует спецификации функции «InCallee».

### <a name="example-the-in-annotation"></a>Пример \_В\_ заметки

`_In_` Заметка указывает, что:

-   Параметр должен быть допустимым и не будет изменен.

-   Функция считает только из одного элемента буфера.

-   Вызывающий должен предоставить буфер и инициализировать его.

-   `_In_` Указывает «только для чтения». Распространенной ошибкой является применение `_In_` к параметру, который должен иметь `_Inout_` заметки вместо этого.

-   `_In_` допускается, но игнорируется анализатора в скалярных величин не являющихся указателями.

```cpp
void InCallee(_In_ int *pInt)
{
   int i = *pInt;
}

void GoodInCaller()
{
   int *pInt = new int;
   *pInt = 5;

   InCallee(pInt);
   delete pInt;
}

void BadInCaller()
{
   int *pInt = NULL;
   InCallee(pInt); // pInt should not be NULL
}
```

При использовании анализа кода Visual Studio в этом примере выполняется проверка, что вызывающие объекты передать указатель ненулевой инициализированный буфер для `pInt`. В этом случае `pInt` указатель не может иметь значение NULL.

### <a name="example-the-inopt-annotation"></a>Пример \_В\_opt\_ заметки

`_In_opt_` совпадает со значением `_In_`, за исключением того, что входной параметр может быть NULL, и, таким образом, функцию следует проверить это.

```cpp

void GoodInOptCallee(_In_opt_ int *pInt)
{
   if(pInt != NULL) {
      int i = *pInt;
   }
}

void BadInOptCallee(_In_opt_ int *pInt)
{
   int i = *pInt; // Dereferencing NULL pointer 'pInt'
}

void InOptCaller()
{
   int *pInt = NULL;
   GoodInOptCallee(pInt);
   BadInOptCallee(pInt);
}
```

Анализа кода Visual Studio проверяет, что функция проверяет наличие NULL перед обращением к буфера.

### <a name="example-the-out-annotation"></a>Пример \_Out\_ заметки

`_Out_` поддерживает распространенный сценарий, в котором указатель отличное от NULL, который указывает на элемент буфер передается в, а функция инициализирует элемент. У вызывающего объекта отсутствует инициализации буфера перед вызовом; вызываемая функция обещает инициализируйте его, прежде чем вернуть.

```cpp
void GoodOutCallee(_Out_ int *pInt)
{
   *pInt = 5;
}

void BadOutCallee(_Out_ int *pInt)
{
   // Did not initialize pInt buffer before returning!
}

void OutCaller()
{
   int *pInt = new int;
   GoodOutCallee(pInt);
   BadOutCallee(pInt);
   delete pInt;
}
```

Средство анализа кода Visual Studio проверяет, что вызывающий объект передает НЕНУЛЕВОЙ указатель на буфер для `pInt` и что до возвращения функцией инициализируется буфер.

### <a name="example-the-outopt-annotation"></a>Пример \_Out\_opt\_ заметки

`_Out_opt_` совпадает со значением `_Out_`, за исключением того, что параметр может иметь значение NULL, и, таким образом, функцию следует проверить это.

```cpp
void GoodOutOptCallee(_Out_opt_ int *pInt)
{
   if (pInt != NULL) {
      *pInt = 5;
   }
}

void BadOutOptCallee(_Out_opt_ int *pInt)
{
   *pInt = 5; // Dereferencing NULL pointer 'pInt'
}

void OutOptCaller()
{
   int *pInt = NULL;
   GoodOutOptCallee(pInt);
   BadOutOptCallee(pInt);
}
```

Анализа кода Visual Studio проверяет, что эта функция проверяет наличие NULL перед `pInt` разыменовано и если `pInt` не равно NULL, что буфер инициализируется с помощью функции перед возвратом.

### <a name="example-the-inout-annotation"></a>Пример \_Inout\_ заметки

`_Inout_` используется для добавления заметок к параметр-указатель, который может быть изменен с помощью функции. Указатель должен указывать на допустимый инициализированные данные перед вызовом, и даже, если он изменяется, по-прежнему должен иметь допустимое значение при возвращении. Заметка указывает, что функция может свободно чтение и запись в буфер одного элемента. Вызывающий должен предоставить буфер и инициализировать его.

> [!NOTE]
> Как и `_Out_`, `_Inout_` необходимо применить к изменяемое значение.

```cpp
void InOutCallee(_Inout_ int *pInt)
{
   int i = *pInt;
   *pInt = 6;
}

void InOutCaller()
{
   int *pInt = new int;
   *pInt = 5;
   InOutCallee(pInt);
   delete pInt;
}

void BadInOutCaller()
{
   int *pInt = NULL;
   InOutCallee(pInt); // 'pInt' should not be NULL
}
```

Анализа кода Visual Studio проверяет, что вызывающие объекты передать указатель отличное от NULL, инициализированный буфер для `pInt`и, прежде чем возвращении `pInt` по-прежнему отлично от NULL и инициализируется буфер.

### <a name="example-the-inoutopt-annotation"></a>Пример \_Inout\_opt\_ заметки

`_Inout_opt_` совпадает со значением `_Inout_`, за исключением того, что входной параметр может быть NULL, и, таким образом, функцию следует проверить это.

```cpp
void GoodInOutOptCallee(_Inout_opt_ int *pInt)
{
   if(pInt != NULL) {
      int i = *pInt;
      *pInt = 6;
   }
}

void BadInOutOptCallee(_Inout_opt_ int *pInt)
{
   int i = *pInt; // Dereferencing NULL pointer 'pInt'
   *pInt = 6;
}

void InOutOptCaller()
{
   int *pInt = NULL;
   GoodInOutOptCallee(pInt);
   BadInOutOptCallee(pInt);
}
```

Анализа кода Visual Studio проверяет, что эта функция проверяет наличие NULL перед обращением к буфера и в том случае, если `pInt` не равно NULL, что буфер инициализируется с помощью функции перед возвратом.

### <a name="example-the-outptr-annotation"></a>Пример \_Outptr\_ заметки

`_Outptr_` используется для добавления заметок к параметру, который предназначен для возврата указателя.  Сам параметр не должен иметь значение NULL и вызываемая функция возвращает указатель отличное от NULL, в нем, и этот указатель указывает на инициализированные данные.

```cpp
void GoodOutPtrCallee(_Outptr_ int **pInt)
{
   int *pInt2 = new int;
   *pInt2 = 5;

   *pInt = pInt2;
}

void BadOutPtrCallee(_Outptr_ int **pInt)
{
   int *pInt2 = new int;
   // Did not initialize pInt buffer before returning!
   *pInt = pInt2;
}

void OutPtrCaller()
{
   int *pInt = NULL;
   GoodOutPtrCallee(&pInt);
   BadOutPtrCallee(&pInt);
}
```

Анализа кода Visual Studio проверяет, что вызывающий объект передает указатель отличное от NULL `*pInt`, и что до возвращения функцией инициализируется буфер.

### <a name="example-the-outptropt-annotation"></a>Пример \_Outptr\_opt\_ заметки

`_Outptr_opt_` совпадает со значением `_Outptr_`, за исключением того, что параметр является необязательным, вызывающий объект может передавать указатель NULL для параметра.

```cpp
void GoodOutPtrOptCallee(_Outptr_opt_ int **pInt)
{
   int *pInt2 = new int;
   *pInt2 = 6;

   if(pInt != NULL) {
      *pInt = pInt2;
   }
}

void BadOutPtrOptCallee(_Outptr_opt_ int **pInt)
{
   int *pInt2 = new int;
   *pInt2 = 6;
   *pInt = pInt2; // Dereferencing NULL pointer 'pInt'
}

void OutPtrOptCaller()
{
   int **ppInt = NULL;
   GoodOutPtrOptCallee(ppInt);
   BadOutPtrOptCallee(ppInt);
}
```

Анализа кода Visual Studio проверяет, что эта функция проверяет наличие NULL перед `*pInt` разыменовано, и что до возвращения функцией инициализируется буфер.

### <a name="example-the-success-annotation-in-combination-with-out"></a>Пример \_Успех\_ заметки в сочетании с \_Out\_

Заметки могут применяться для большинства объектов.  В частности можно добавить заметку всей функции.  Одной из наиболее очевидных характеристик функции является, что ее выполнение или сбой. Но как ассоциации между буфера и его размером, не может представлять C/C++, функция успех или неудачу. С помощью `_Success_` заметки, можно сказать, для функции цель.  Параметр `_Success_` заметки — это просто, если он имеет значение true указывает успешное функция выражение. Выражение может быть все, что средство синтаксического анализа заметки можно обрабатывать. Последствия заметки после возвращения функции применяются только в случае, если функция выполняется успешно. В этом примере показано, как `_Success_` взаимодействует с `_Out_` делать правильно. Можно использовать ключевое слово `return` для представления возвращаемое значение.

```cpp
_Success_(return != false) // Can also be stated as _Success_(return)
bool GetValue(_Out_ int *pInt, bool flag)
{
   if(flag) {
      *pInt = 5;
      return true;
   } else {
      return false;
   }
}
```

`_Out_` Заметки вызывает анализа кода Visual Studio для проверки, что вызывающий объект передает НЕНУЛЕВОЙ указатель на буфер для `pInt`, и что до возвращения функцией инициализируется буфер.

## <a name="sal-best-practice"></a>Рекомендуется SAL

### <a name="adding-annotations-to-existing-code"></a>Добавление заметок для существующего кода

SAL — это мощная технология, которая может помочь повысить безопасность и надежность кода. Когда вы узнаете SAL, можно применить новый навык для повседневной работы. В новом коде можно использовать на базе SAL спецификации, во всех; в старом коде можно постепенно добавлять заметки и тем самым повысить преимущества, каждый раз при обновлении.

Microsoft, которые уже отмечены общих заголовках. Таким образом мы рекомендуем, что в проектах сначала аннотировании конечный узел функций и функций, которые вызывают API-интерфейсов Win32 для получения оптимальных результатов.

### <a name="when-do-i-annotate"></a>Когда заметки?

Ниже приведены некоторые рекомендации.

- Добавление заметок все параметры-указатели.

- Таким образом, чтобы анализ кода можно обеспечить безопасность буфера и указатель на добавление заметок диапазон значений заметок.

- Заметки к правилам блокировки и побочных эффектов. Дополнительные сведения см. в разделе [Аннотация поведения блокировки](../code-quality/annotating-locking-behavior.md).

- Заметки к свойствам драйвера и других свойств конкретного домена.

Или можно добавить заметку все параметры, чтобы сделать ваши намерения clear на протяжении всего и упростить процесс проверить, что было сделано заметок.

## <a name="related-resources"></a>Связанные ресурсы

[Блог команды анализа кода](http://go.microsoft.com/fwlink/p/?LinkId=251197)

## <a name="see-also"></a>См. также

- [Использование аннотаций SAL для уменьшения количества дефектов в коде C/C++](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md)
- [Создание примечаний к параметрам и возвращаемым значениям функций](../code-quality/annotating-function-parameters-and-return-values.md)
- [Аннотация поведения функций](../code-quality/annotating-function-behavior.md)
- [Аннотация структур и классов](../code-quality/annotating-structs-and-classes.md)
- [Аннотация поведения блокировки](../code-quality/annotating-locking-behavior.md)
- [Указание времени и места применения примечания](../code-quality/specifying-when-and-where-an-annotation-applies.md)
- [Рекомендации и примеры](../code-quality/best-practices-and-examples-sal.md)