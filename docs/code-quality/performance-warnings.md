---
title: "Предупреждения о производительности | Документы Microsoft"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-code-analysis
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: vs.codeanalysis.performancerules
helpviewer_keywords:
- warnings, performance
- performance warnings
- performance, warnings
- managed code analysis warnings, performance warnings
ms.assetid: e014ac3a-02e6-46d9-942c-3491dd63782f
caps.latest.revision: "22"
author: gewarren
ms.author: gewarren
manager: ghogen
ms.workload: multiple
ms.openlocfilehash: baf04adf4589f0809db6a2de2bedcc0efd0f6fcb
ms.sourcegitcommit: 32f1a690fc445f9586d53698fc82c7debd784eeb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="performance-warnings"></a>предупреждения производительности
Предупреждения производительности поддерживают высокой производительности библиотек и приложений.  
  
## <a name="in-this-section"></a>В этом разделе  
  
|Правило|Описание:|  
|----------|-----------------|  
|[CA1800: не выполняйте лишних приведений](../code-quality/ca1800-do-not-cast-unnecessarily.md)|Повторяющиеся приведения снижают производительность, особенно если приведения выполняются в компактных операторах итераций.|  
|[CA1801: проверьте неиспользуемые параметры](../code-quality/ca1801-review-unused-parameters.md)|Сигнатура метода включает параметр, не использующийся в основной части метода.|  
|[CA1802. Используйте литералы там, где возможно](../code-quality/ca1802-use-literals-where-appropriate.md)|Поле объявляется статичным и доступным только для чтения (Shared и ReadOnly в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) и инициализируется со значением, вычисляемым во время компиляции. Поскольку значение, присвоенное конечному полю, вычисляется во время компиляции, замените объявление полем const (Const в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) таким образом, значение вычисляется во время компиляции, а не во время выполнения.|  
|[CA1804: удалите неиспользуемые локальные переменные](../code-quality/ca1804-remove-unused-locals.md)|Неиспользуемые локальные переменные и ненужные присвоения увеличивают размер сборки и снижают производительность.|  
|[CA1806: не игнорируйте результаты метода](../code-quality/ca1806-do-not-ignore-method-results.md)|Новый объект создается, но никогда не используется, вызывается метод, который создает и возвращает новую строку и такая новая строка никогда не используется или метод объекта модели компонентов (COM) или P/Invoke возвращает HRESULT или код ошибки, который никогда не используется.|  
|[CA1809: избегайте чрезмерного использования локальных переменных](../code-quality/ca1809-avoid-excessive-locals.md)|Обычно для оптимизации производительности рекомендуется хранить значение не в памяти, а в регистре процессора. Это называется регистрацией значения.  Чтобы увеличить вероятность того, что все локальные переменные являются незарегистрированные, Ограничьте число локальных переменных в 64.|  
|[CA1810: инициализируйте статические поля ссылочного типа встроенными средствами](../code-quality/ca1810-initialize-reference-type-static-fields-inline.md)|Если в типе объявляется явный статический конструктор, компилятор JIT добавляет проверку в каждый статический метод и конструктор экземпляров этого типа, чтобы убедиться, что статический конструктор уже вызывался ранее. Проверки статических конструкторов могут привести к снижению производительности.|  
|[CA1811: не используйте невызываемый закрытый код](../code-quality/ca1811-avoid-uncalled-private-code.md)|Закрытый или внутренний член (на уровне сборки) не имеет вызывающим объектам в сборке, не используется средой CLR и не вызывается делегат.|  
|[CA1812: не создавайте внутренние классы без экземпляров](../code-quality/ca1812-avoid-uninstantiated-internal-classes.md)|Экземпляр типа уровня сборки не создается кодом в сборке.|  
|[CA1813: избегайте распечатанных атрибутов](../code-quality/ca1813-avoid-unsealed-attributes.md)|В библиотеке классов [!INCLUDE[dnprdnshort](../code-quality/includes/dnprdnshort_md.md)] предоставляются методы для извлечения пользовательских атрибутов. По умолчанию эти методы осуществляют поиск иерархии наследования атрибутов. Если запечатать атрибут, поиск в иерархии наследования выполняться не будет, в результате чего может повыситься производительность.|  
|[CA1814: используйте ступенчатые массивы вместо многомерных](../code-quality/ca1814-prefer-jagged-arrays-over-multidimensional.md)|Массив массивов — это массив, элементы которого сами являются массивами. Массивы, которые составляют элементы могут иметь различные размеры, что может привести к экономить пространство для некоторых наборов данных.|  
|[CA1815: следует переопределять равенства и равенства операторов в типах значений](../code-quality/ca1815-override-equals-and-operator-equals-on-value-types.md)|В унаследованной реализации Equals для типов значений используется библиотека отражения и сравнивается содержимое всех полей. Отражение является процессом, требующим с точки зрения вычислений больших затрат, и сравнение каждого поля на равенство может быть лишним. Если предполагается, что пользователи будут сравнивать, сортировать экземпляры или использовать их в качестве ключей хэш-таблиц, тип значения должен реализовывать Equals.|  
|[CA1816: вызов GC.SuppressFinalize должен осуществляться правильно](../code-quality/ca1816-call-gc-suppressfinalize-correctly.md)|Метод, являющийся реализацией Dispose не осуществляет вызов сборки Мусора. SuppressFinalize, либо метод, не являющийся реализацией Dispose, вызывает GC. SuppressFinalize или метод вызывает GC. SuppressFinalize и передает что-либо другое это (Me в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]).|  
|[CA1819: свойства не должны возвращать массивы](../code-quality/ca1819-properties-should-not-return-arrays.md)|Массивы, возвращаемые свойствами, не защищен от записи, даже если свойство доступно только для чтения. Чтобы защитить массив от изменений, свойство должно возвращать копию массива. Как правило, пользователи не понимают требований к производительности при вызове такого свойства.|  
|[CA1820: проверьте наличие пустых строк путем проверки длины строки](../code-quality/ca1820-test-for-empty-strings-using-string-length.md)|Сравнивать строки с использованием свойства String.Length или метода String.IsNullOrEmpty значительно быстрее, чем с помощью Equals.|  
|[CA1821: удаляйте пустые методы завершения](../code-quality/ca1821-remove-empty-finalizers.md)|Если возможно, старайтесь не использовать финализаторы, поскольку из-за отслеживания жизненного срока объектов снижается производительность программы. Пустой метод завершения создает дополнительную нагрузку на систему без никаких преимуществ.|  
|[CA1822: помечайте члены как статические](../code-quality/ca1822-mark-members-as-static.md)|Члены, не обращающиеся к данным экземпляра и не вызывающие методы экземпляра, можно пометить как статические (Shared в [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]). Если пометить методы как статические, компилятор предоставит этим членам невиртуальные места вызова. Это обеспечивает значительное повышение производительности при работе с кодом, для которого важна высокая производительность системы.|  
|[CA1823: избегайте наличия неиспользованных закрытых полей](../code-quality/ca1823-avoid-unused-private-fields.md)|Обнаружены закрытые поля, доступ к которым, судя по всему, не предоставляется в сборке.|  
|[CA1824: следует помечать сборки атрибутом NeutralResourcesLanguageAttribute](../code-quality/ca1824-mark-assemblies-with-neutralresourceslanguageattribute.md)|Атрибут NeutralResourcesLanguage сообщает ResourceManager о языке, используемом для отображения независящих от языка и региональных параметров ресурсов для сборки. При этом повышается эффективность поиска первого загружаемого ресурса и может сократиться рабочее множество.|