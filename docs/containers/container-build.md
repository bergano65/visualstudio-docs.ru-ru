---
title: Обзор процессов сборки и отладки с помощью инструментов Visual Studio для работы с контейнерами
author: ghogen
description: Обзор процессов сборки и отладки с помощью инструментов для работы с контейнерами
ms.author: ghogen
ms.date: 11/20/2019
ms.technology: vs-azure
ms.topic: conceptual
ms.openlocfilehash: d91dd01879ac3bb62b981109463f6762046382ef
ms.sourcegitcommit: cc841df335d1d22d281871fe41e74238d2fc52a6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/18/2020
ms.locfileid: "77027258"
---
# <a name="how-visual-studio-builds-containerized-apps"></a>Как Visual Studio создает контейнерные приложения

Независимо от того, выполняете ли вы сборку из интегрированной среды разработки Visual Studio или настраиваете сборку из командной строки, необходимо знать, как в Visual Studio используется файл Dockerfile для сборки проектов.  В целях повышения производительности в Visual Studio для контейнерных приложений применяется особый процесс. Особенно важно понимать, как Visual Studio выполняет сборку проектов, когда процесс сборки настраивается путем изменения Dockerfile.

Когда в Visual Studio выполняется сборка проекта, который не использует контейнеры Docker, на локальном компьютере вызывается MSBuild и создаются выходные файлы в папке (обычно `bin`), вложенной в локальную папку решения. Однако для контейнерного проекта в процессе сборки учитываются инструкции из файла Dockerfile. Сборка с помощью Dockerfile в Visual Studio делится на несколько этапов. При этом применяется функция *многоэтапной сборки* Docker.

## <a name="multistage-build"></a>Многоэтапная сборка

Функция многоэтапной сборки повышает эффективность сборки контейнеров и позволяет уменьшить их размер, так как они содержат только тот код, который требуется приложению во время выполнения. Многоэтапная сборка применяется для проектов .NET Core, но не для проектов .NET Framework.

При многоэтапной сборке образы контейнеров создаются в несколько шагов, на каждом из которых формируются промежуточные образы. Возьмем для примера типичный файл Dockerfile, создаваемый Visual Studio. Первый этап — `base`.

```
FROM mcr.microsoft.com/dotnet/core/aspnet:2.2-stretch-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443
```

Сначала в Dockerfile берется образ Debian из реестра контейнеров Майкрософт (mcr.microsoft.com) и создается промежуточный образ `base`, для которого открываются порты 80 и 443 и задается рабочий каталог `/app`.

Следующий этап — `build`. Выглядит он так:

```
FROM mcr.microsoft.com/dotnet/core/sdk:2.2-stretch AS build
WORKDIR /src
COPY ["WebApplication43/WebApplication43.csproj", "WebApplication43/"]
RUN dotnet restore "WebApplication43/WebApplication43.csproj"
COPY . .
WORKDIR "/src/WebApplication43"
RUN dotnet build "WebApplication43.csproj" -c Release -o /app
```

Как вы видите, на этапе `build` вместо продолжения работы с образом base берется другой исходный образ из реестра (`sdk`, а не `aspnet`).  Образ `sdk` содержит все средства сборки и поэтому гораздо больше, чем образ aspnet, который содержит только компоненты времени выполнения. Причина использования отдельного образа становится очевидной, если посмотреть на остальную часть файла Dockerfile:

```
FROM build AS publish
RUN dotnet publish "WebApplication43.csproj" -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "WebApplication43.dll"]
```

Последний этап снова начинается с образа `base` и включает в себя команду `COPY --from=publish`, которая копирует опубликованные выходные данные в итоговый образ. Это позволяет значительно уменьшить итоговый образ, так как в него не нужно включать все средства сборки, которые имелись в образе `sdk`.

## <a name="building-from-the-command-line"></a>Сборка из командной строки

Если нужно выполнить сборку вне Visual Studio, можно использовать `docker build` или `MSBuild` для построения из командной строки.

### <a name="docker-build"></a>docker build

Для сборки контейнерного решения из командной строки обычно можно использовать команду `docker build <context>` для каждого проекта в решении. Укажите аргумент *build context*. *build context* для Dockerfile — это папка на локальном компьютере, которая служит рабочей папкой для создания образа. Например, из нее копируются файлы в контейнер.  Для проектов .NET Core используйте папку, содержащую файл решения (SLN).  При использовании относительного пути этот аргумент обычно имеет значение ".." для Dockerfile в папке проекта и файла решения в родительской папке.  Для проектов .NET Framework контекст сборки — это папка проекта, а не решения.

```cmd
docker build -f Dockerfile ..
```

### <a name="msbuild"></a>MSBuild

Файлы Dockerfile, создаваемые Visual Studio для проектов .NET Framework (а также для проектов .NET Core, создаваемых с помощью версий Visual Studio до Visual Studio 2017 с обновлением 4), не являются многоэтапными.  Инструкции в этих файлах Dockerfile не компилируют код.  Вместо этого, когда среда Visual Studio выполняет сборку с помощью Dockerfile для .NET Framework, она сначала компилирует проект с помощью MSBuild.  Если компиляция завершилась успешно, Visual Studio выполняет сборку Dockerfile. При этом выходные данные сборки из MSBuild просто копируются в полученный образ Docker.  Так как инструкции по компиляции кода не включаются в Dockerfile, выполнять сборку файлов Dockerfile для .NET Framework с помощью команды `docker build` из командной строки невозможно. Для сборки таких проектов следует использовать MSBuild.

Чтобы выполнить сборку образа для одного проекта контейнера Docker, можно использовать MSBuild с параметром команды `/t:ContainerBuild`. Пример:

```cmd
MSBuild MyProject.csproj /t:ContainerBuild /p:Configuration=Release
```

Выходные данные будут аналогичны тем, которые содержатся в окне **Выходные данные** при сборке решения из интегрированной среды разработки Visual Studio. Всегда используйте `/p:Configuration=Release`, так как при применении оптимизации многоэтапной сборки в Visual Studio результаты сборки в конфигурации **отладки** могут отличаться от ожидаемых. См. раздел [Отладка](#debugging).

Для проекта Docker Compose используйте команду для сборки образов:

```cmd
msbuild /p:SolutionPath=<solution-name>.sln /p:Configuration=Release docker-compose.dcproj
```

## <a name="project-warmup"></a>Прогрев проекта

Под *прогревом проекта* понимается последовательность действий, которая выполняется при выборе профиля Docker для проекта (то есть при загрузке проекта или добавлении поддержки Docker) с целью оптимизировать его производительность при последующих запусках (**F5** или **CTRL**+**F5**). Для настройки этого процесса можно выбрать **Инструменты** > **Параметры** > **Инструменты для контейнера**. Ниже описываются задачи, которые выполняются в фоновом режиме:

- Проверка установки и запуска Docker Desktop.
- Проверка того, что для Docker Desktop и проекта задана одна и та же операционная система.
- Извлечение образа на первом этапе файла Dockerfile (этап `base` в большинстве файлов Dockerfile).  
- Создание файла Dockerfile и запуск контейнера.

Прогрев будет выполняться только в **быстром** режиме, поэтому в работающем контейнере папка приложения будет подключена к тому. Это означает, что любые изменения в приложении не сделают контейнер недействительным. Таким образом, значительно повышается эффективность отладки и сокращается время ожидания для длительных задач, таких как извлечение крупных образов.

## <a name="volume-mapping"></a>Сопоставление томов

Чтобы реализовать отладку в контейнерах, Visual Studio использует сопоставление томов для сопоставления отладчика и папок NuGet с хост-компьютера. Сопоставление томов описано в [документации по Docker](https://docs.docker.com/storage/volumes/). Ниже перечислены тома, которые подключаются в контейнере:

|||
|-|-|
| **Удаленный отладчик** | Содержит компоненты, необходимые для запуска отладчика в контейнере, в соответствии с типом проекта. Более подробное описание приводится |в разделе [Отладка](#debugging).
| **Папка приложения** | Содержит папку проекта, в которой располагается файл Dockerfile.|
| **Исходная папка** | Содержит контекст сборки, который передается в команды Docker.|
| **Папки пакетов NuGet** | Содержат пакеты NuGet и резервные папки, которые считываются из файла *obj\{project}.csproj.nuget.g.props* в проекте. |

В веб-приложениях ASP.NET Core могут использоваться две дополнительные папки для SSL-сертификата и секретных ключей пользователей, которые более подробно описываются в следующем разделе.

## <a name="ssl-enabled-aspnet-core-apps"></a>Приложения ASP.NET Core с поддержкой SSL

Инструменты для контейнеров в Visual Studio поддерживают отладку в приложениях ASP.NET Core с поддержкой SSL с использованием сертификата разработки так же, как и при работе без контейнеров. Для этого Visual Studio выполняет несколько дополнительных действий для экспорта сертификата и предоставления контейнеру доступа к нему. Ниже приведена процедура, выполняемая средой Visual Studio при отладке в контейнере.

1. С помощью средства `dev-certs` проверяется наличие доверенного сертификата разработки на хост-компьютере.
2. Сертификат экспортируется в папку %APPDATA%\ASP.NET\Https с использованием надежного пароля, который находится в хранилище секретных ключей пользователей для этого приложения.
3. Том подключает следующие каталоги:

   - *%APPDATA%\Microsoft\UserSecrets*
   - *%APPDATA%\ASP.NET\Https*

ASP.NET Core ищет сертификат, соответствующий имени сборки, в папке *Https*, для чего она и сопоставляется с контейнером по этому пути. Путь к сертификату и пароль также можно определить с помощью переменных среды (`ASPNETCORE_Kestrel__Certificates__Default__Path` и `ASPNETCORE_Kestrel__Certificates__Default__Password`) или в JSON-файле секретных ключей пользователей, например следующим образом:

```json
{
  "Kestrel": {
    "Certificates": {
      "Default": {
        "Path": "c:\\app\\mycert.pfx",
        "Password": "strongpassword"
      }
    }
  }
}
```

Если конфигурация поддерживает как контейнерные, так и неконтейнерные сборки, следует использовать переменные среды, так как пути зависят от среды контейнеров.

Дополнительные сведения о поддержке SSL в приложениях ASP.NET Core в контейнерах см. в разделе [Размещение образов ASP.NET Core с Docker через HTTPS](/aspnet/core/security/docker-https).

## <a name="debugging"></a>Отладка

Если сборка выполняется в **режиме отладки**, Visual Studio осуществляет ряд оптимизаций, которые повышают производительность сборки для контейнерных проектов. При этом процесс сборки контейнерных приложений не просто следует инструкциям в файле Dockerfile. Сборка в контейнере выполняется гораздо медленнее, чем на локальном компьютере.  Поэтому при сборке в конфигурации **отладки** Visual Studio на самом деле выполняет сборку проектов на локальном компьютере, а затем предоставляет доступ к папке с выходными данными контейнеру путем подключения к тому. Сборка с такой оптимизацией называется сборкой в *быстром* режиме.

В **быстром** режиме Visual Studio вызывает `docker build` с аргументом, который предписывает Docker выполнить сборку только образа `base`.  Остальные этапы процесса выполняет сама среда Visual Studio с учетом содержимого Dockerfile. Поэтому, когда вы изменяете файл Dockerfile, например для настройки среды контейнера или установки дополнительных зависимостей, изменения должны вноситься на первом этапе.  Шаги, добавленные в этапы `build`, `publish` и `final` в Dockerfile, выполняться не будут.

Данная оптимизация производительности применяется только при сборке в конфигурации **отладки**. В конфигурации **выпуска** сборка выполняется в контейнере, как указано в Dockerfile.

Чтобы отключить оптимизацию производительности и выполнить сборку, как указано в Dockerfile, присвойте свойству **ContainerDevelopmentMode** значение **Regular** в файле проекта следующим образом:

```xml
<PropertyGroup>
   <ContainerDevelopmentMode>Regular</ContainerDevelopmentMode>
</PropertyGroup>
```

Чтобы снова включить оптимизацию производительности, удалите это свойство из файла проекта.

 При запуске отладки (**F5**) используется ранее запущенный контейнер, если это возможно. Если вы не хотите повторно использовать имеющийся контейнер, можно выбрать в Visual Studio команду **Перестроить** или **Очистить**, чтобы использовался новый контейнер.

Процесс запуска отладчика зависит от типа проекта и операционной системы контейнера:

|||
|-|-|
| **Приложения .NET Core (контейнеры Linux)**| Visual Studio скачивает `vsdbg` и сопоставляет его с контейнером. Затем он вызывается в программе с соответствующими аргументами (`dotnet webapp.dll`), после чего к процессу привязывается отладчик. |
| **Приложения .NET Core (контейнеры Windows)**| Visual Studio использует `onecoremsvsmon` и сопоставляет его с контейнером. После этого он запускается в качестве точки входа, а затем Visual Studio устанавливает подключение к нему и привязывает его к вашей программе. Этот процесс аналогичен типовой настройке удаленной отладки на другом компьютере или виртуальной машине.|
| **Приложения .NET Framework** | Visual Studio использует `msvsmon` и сопоставляет его с контейнером. После этого он запускается в составе точки входа, где Visual Studio может установить подключение к нему и привязать его к вашей программе.|

Дополнительные сведения о `vsdbg.exe` см. в разделе [Внешняя отладка приложений .NET Core в Linux и OSX из Visual Studio](https://github.com/Microsoft/MIEngine/wiki/Offroad-Debugging-of-.NET-Core-on-Linux---OSX-from-Visual-Studio).

## <a name="container-entry-point"></a>Точка входа контейнера

Visual Studio использует подходящую точку входа контейнера в зависимости от типа проекта и операционной системы контейнера. Ниже описываются возможные комбинации:

|||
|-|-|
| **Контейнеры Linux** | В качестве точки входа используется `tail -f /dev/null`, представляющая собой бесконечный цикл ожидания, в рамках которого обеспечивается выполнение контейнера. При запуске приложения с помощью отладчика за запуск приложения отвечает именно отладчик (`dotnet webapp.dll`). При запуске без отладки инструментарий выполняет `docker exec -i {containerId} dotnet webapp.dll` для запуска приложения.|
| **Контейнеры Windows**| Используется точка входа вида `C:\remote_debugger\x64\msvsmon.exe /noauth /anyuser /silent /nostatus`, которая запускает отладчик, прослушивающий подключения. При этом применяется аналогичный подход: отладчик запускает приложение, а при запуске без отладки используется команда `docker exec`. Для веб-приложений .NET Framework точка входа несколько отличается: к команде добавляется `ServiceMonitor`.|

Точку входа контейнера можно изменить только в проектах docker-compose. В проектах с одним контейнером сделать это нельзя.

## <a name="next-steps"></a>Дальнейшие действия

Узнайте, как произвести дальнейшую настройку сборок путем задания дополнительных свойств MSBuild в файлах проекта. См. статью [Свойства MSBuild для проектов контейнеров](container-msbuild-properties.md).

## <a name="see-also"></a>См. также раздел

[MSBuild](../msbuild/msbuild.md)
[Dockerfile в Windows](/virtualization/windowscontainers/manage-docker/manage-windows-dockerfile)
[Контейнеры Linux в Windows](/virtualization/windowscontainers/deploy-containers/linux-containers)
