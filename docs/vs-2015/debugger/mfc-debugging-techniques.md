---
title: Методы отладки MFC | Документация Майкрософт
ms.custom: ''
ms.date: 2018-06-30
ms.prod: visual-studio-dev14
ms.reviewer: ''
ms.suite: ''
ms.technology:
- vs-ide-debug
ms.tgt_pltfrm: ''
ms.topic: article
f1_keywords:
- AfxEnableMemoryTracking
- CMemoryState
- delayFreeMemDF
- checkAlwaysMemDF
- vs.debug.mfc
- vs.debug.objects.dump
- vs.debug.memory.dump
- allocMemDF
- afxMemDF
dev_langs:
- FSharp
- VB
- CSharp
- C++
- C++
helpviewer_keywords:
- debugging [MFC]
ms.assetid: b154fc31-5e90-4734-8cbd-58dd9fe1f750
caps.latest.revision: 23
author: mikejo5000
ms.author: mikejo
manager: ghogen
ms.openlocfilehash: d4828b7b5ee5d0812c8a9b1afa2ff2def783c3d9
ms.sourcegitcommit: 55f7ce2d5d2e458e35c45787f1935b237ee5c9f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2018
ms.locfileid: "47570378"
---
# <a name="mfc-debugging-techniques"></a>Методы отладки MFC
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Последнюю версию этого раздела можно найти в [методы отладки MFC](https://docs.microsoft.com/visualstudio/debugger/mfc-debugging-techniques).  
  
Эти методы могут пригодиться при отладке программы MFC.  
  
##  <a name="BKMK_In_this_topic"></a> Содержание раздела  
 [Функция AfxDebugBreak](#BKMK_AfxDebugBreak)  
  
 [Макрос TRACE](#BKMK_The_TRACE_macro)  
  
 [Обнаружение утечек памяти в MFC](#BKMK_Memory_leak_detection_in_MFC)  
  
-   [Отслеживание операций выделения памяти](#BKMK_Tracking_memory_allocations)  
  
-   [Включение диагностики памяти](#BKMK_Enabling_memory_diagnostics)  
  
-   [Получение снимков памяти](#BKMK_Taking_memory_snapshots)  
  
-   [Просмотр статистики памяти](#BKMK_Viewing_memory_statistics)  
  
-   [Получение дампов объектов](#BKMK_Taking_object_dumps)  
  
    -   [Интерпретация дампов памяти](#BKMK_Interpreting_memory_dumps)  
  
    -   [Настройка дампов объектов](#BKMK_Customizing_object_dumps)  
  
     [Сокращение размера отладочной сборки MFC](#BKMK_Reducing_the_size_of_an_MFC_Debug_build)  
  
    -   [Сборка приложения MFC с отладочной информацией для избранных модулей](#BKMK_Building_an_MFC_app_with_debug_information_for_selected_modules)  
  
##  <a name="BKMK_AfxDebugBreak"></a> Функция AfxDebugBreak  
 MFC предоставляет особую [AfxDebugBreak](http://msdn.microsoft.com/library/c4cd79b9-9327-4db5-a9d6-c4004a92aa30) функции для жесткого задания точек останова в исходном коде:  
  
```  
AfxDebugBreak( );  
  
```  
  
 На платформах Intel `AfxDebugBreak` создает следующий код, останавливающий выполнение исходного кода, а не кода ядра:  
  
```  
_asm int 3  
```  
  
 На других платформах `AfxDebugBreak` просто вызывает `DebugBreak`.  
  
 Не забывайте удалять `AfxDebugBreak` при создании окончательного построения или используйте `#ifdef _DEBUG` до и после этих операторов.  
  
 [Содержание раздела](#BKMK_In_this_topic)  
  
##  <a name="BKMK_The_TRACE_macro"></a> Макрос TRACE  
 Для отображения сообщения программы в отладчике [окно вывода](../ide/reference/output-window.md), можно использовать [ATLTRACE](http://msdn.microsoft.com/library/c796baa5-e2b9-4814-a27d-d800590b102e) макрос или MFC [ТРАССИРОВКИ](http://msdn.microsoft.com/library/7b6f42d8-b55a-4bba-ab04-c46251778e6f) макрос. Подобно [утверждениям](../debugger/c-cpp-assertions.md), макросы трассировки активны только в отладочной версии программы, а в окончательной версии они исчезают после компиляции.  
  
 Следующие примеры показывают несколько способов применения макроса **TRACE** . Подобно `printf`макрос **TRACE** может обрабатывать несколько аргументов.  
  
```  
int x = 1;  
int y = 16;  
float z = 32.0;  
TRACE( "This is a TRACE statement\n" );  
  
TRACE( "The value of x is %d\n", x );  
  
TRACE( "x = %d and y = %d\n", x, y );  
  
TRACE( "x = %d and y = %x and z = %f\n", x, y, z );  
```  
  
 Макро TRACE правильно обрабатывает, char * и wchar_t\* параметров. Следующие примеры демонстрируют использование макро TRACE вместе с различными типами строковых параметров.  
  
```  
TRACE( "This is a test of the TRACE macro that uses an ANSI string: %s %d\n", "The number is:", 2);  
  
TRACE( L"This is a test of the TRACE macro that uses a UNICODE string: %s %d\n", L"The number is:", 2);  
  
TRACE( _T("This is a test of the TRACE macro that uses a TCHAR string: %s %d\n"), _T("The number is:"), 2);  
  
```  
  
 Дополнительные сведения о **ТРАССИРОВКИ** макрос, см. в разделе [диагностические службы](http://msdn.microsoft.com/library/8d78454f-9fae-49c2-88c9-d3fabd5393e8).  
  
 [Содержание раздела](#BKMK_In_this_topic)  
  
##  <a name="BKMK_Memory_leak_detection_in_MFC"></a> Обнаружение утечек памяти в MFC  
 MFC предоставляет классы и функции, позволяющие обнаруживать выделенную, но не освобожденную память.  
  
###  <a name="BKMK_Tracking_memory_allocations"></a> Отслеживание операций выделения памяти  
 В MFC, можно использовать макрос [DEBUG_NEW](http://msdn.microsoft.com/library/9b379344-4093-4bec-a3eb-e0d8a63ada9d) вместо **новый** утечек оператор, чтобы упростить поиск памяти. В отладочной версии программы `DEBUG_NEW` отслеживает имя файла и номер строки для каждого объекта, которому выделяется память. При компиляции окончательной версии программы `DEBUG_NEW` становится простой операцией **new** без данных об имени файла и номере строки. Таким образом, окончательная версия программы выполняется с необходимой скоростью.  
  
 Чтобы не переписывать программу, используя `DEBUG_NEW` вместо **new**, можно в исходных файлах определить данный макрос:  
  
```  
#define new DEBUG_NEW  
```  
  
 Если создается [дамп объекта](#BKMK_Taking_object_dumps), каждый объект, память для которого выделяется с помощью `DEBUG_NEW` , показывает файл и номер строки, где было выполнено выделение, позволяя точнее выявить источник утечки памяти.  
  
 В отладочной версии структуры MFC макрос `DEBUG_NEW` используется автоматически, но в коде, разумеется, нет. Если же требуется воспользоваться преимуществами `DEBUG_NEW`, то нужно явно указать `DEBUG_NEW` или **#define new** , как показано выше.  
  
 [Содержание раздела](#BKMK_In_this_topic)  
  
###  <a name="BKMK_Enabling_memory_diagnostics"></a> Включение диагностики памяти  
 Прежде чем воспользоваться возможностями диагностики памяти, нужно включить диагностическую трассировку.  
  
 **Включение или выключение диагностики памяти**  
  
-   Вызовите глобальную функцию [AfxEnableMemoryTracking](http://msdn.microsoft.com/library/0a40e0c4-855d-46e2-9577-a8f2346f47db) для включения или отключения памяти с диагностикой. Поскольку диагностика памяти обычно включена по умолчанию в отладочной библиотеке, эта функция будет применяться для ее временного отключения — это позволит увеличить скорость выполнения программы и уменьшит вывод диагностических сообщений.  
  
 **Выбор функции диагностики памяти с помощью afxMemDF**  
  
-   Если требуется более точный контроль над функциями диагностики памяти, можно выборочно включать отдельные функции включения и отключения, задав значение глобальной переменной MFC [afxMemDF](http://msdn.microsoft.com/library/cf117501-5446-4fce-81b3-f7194bc95086). Эта переменная может принимать следующие значения, заданные перечисляемым типом **afxMemDF**:  
  
    |Значение|Описание|  
    |-----------|-----------------|  
    |**allocMemDF**|Включает выделение памяти с диагностикой (по умолчанию).|  
    |**delayFreeMemDF**|Задерживает освобождение памяти до выхода из программы при вызове `delete` или `free` . Это позволяет обеспечить выделение максимального объема памяти.|  
    |**checkAlwaysMemDF**|Вызовите [AfxCheckMemory](http://msdn.microsoft.com/library/4644da71-7d14-41dc-adc0-ee9558fd7a28) каждый раз при выделении или освобождении памяти.|  
  
     Эти значения можно комбинировать с помощью логической операции ИЛИ, как показано ниже:  
  
    ```cpp  
    afxMemDF = allocMemDF | delayFreeMemDF | checkAlwaysMemDF;  
    ```  
  
 [Содержание раздела](#BKMK_In_this_topic)  
  
###  <a name="BKMK_Taking_memory_snapshots"></a> Получение снимков памяти  
  
1.  Создание [CMemoryState](http://msdn.microsoft.com/en-us/8fade6e9-c6fb-4b2a-8565-184a912d26d2) и вызовите [CMemoryState::Checkpoint](http://msdn.microsoft.com/library/b2d80fea-3d21-457e-816d-b035909bf21a) функция-член. В результате будет создан первый снимок памяти.  
  
2.  После того как программа выполнит операцию по выделению или освобождению памяти, создайте другой объект `CMemoryState` и вызовите функцию `Checkpoint` уже для него. Так получится второй снимок памяти.  
  
3.  Создайте третий `CMemoryState` и вызовите его [CMemoryState::Difference](http://msdn.microsoft.com/library/aba69e2f-71dd-4255-99b5-3da2e56a0c9c) функция-член, используя в качестве аргументов два предыдущих `CMemoryState` объектов. Если между двумя состояниями памяти есть различия, функция `Difference` вернет отличное от нуля значение. Это значение будет свидетельствовать о наличии неосвобожденных блоков памяти.  
  
     Пример кода выглядит следующим образом:  
  
    ```  
    // Declare the variables needed  
    #ifdef _DEBUG  
        CMemoryState oldMemState, newMemState, diffMemState;  
        oldMemState.Checkpoint();  
    #endif  
  
        // Do your memory allocations and deallocations.  
        CString s("This is a frame variable");  
        // The next object is a heap object.  
       CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );  
  
    #ifdef _DEBUG  
        newMemState.Checkpoint();  
        if( diffMemState.Difference( oldMemState, newMemState ) )  
        {  
            TRACE( "Memory leaked!\n" );  
        }  
    #endif  
    ```  
  
     Обратите внимание, что операторы проверки памяти заключаются в `#ifdef` [_DEBUG](http://msdn.microsoft.com/library/a9901568-4846-4731-a404-399d947e2e7a)/ **#endif** блокирует таким образом, чтобы они компилируются только в отладочных версиях программы.  
  
     Теперь, когда известно о наличии утечки, можно использовать другую функцию-член, [CMemoryState::DumpStatistics](http://msdn.microsoft.com/library/90d5f281-b92f-4725-a996-23ab94cf4b5d) , поможет вам найти его.  
  
 [Содержание раздела](#BKMK_In_this_topic)  
  
###  <a name="BKMK_Viewing_memory_statistics"></a> Просмотр статистики памяти  
 [CMemoryState::Difference](http://msdn.microsoft.com/library/aba69e2f-71dd-4255-99b5-3da2e56a0c9c) функция просматривает два объекта-состояния памяти и определяет, какие объекты не были освобождены из кучи между начальным и конечным состоянием. После снимки памяти и выполнено их сравнение с помощью `CMemoryState::Difference`, можно вызвать [CMemoryState::DumpStatistics](http://msdn.microsoft.com/library/90d5f281-b92f-4725-a996-23ab94cf4b5d) для получения сведений об объектах, которые не были освобождены.  
  
 Рассмотрим следующий пример.  
  
```  
if( diffMemState.Difference( oldMemState, newMemState ) )  
{  
   TRACE( "Memory leaked!\n" );  
   diffMemState.DumpStatistics();  
}  
```  
  
 Образец дампа из примера выглядит следующим образом:  
  
```  
0 bytes in 0 Free Blocks  
22 bytes in 1 Object Blocks  
45 bytes in 4 Non-Object Blocks  
Largest number used: 67 bytes  
Total allocations: 67 bytes  
```  
  
 Свободные блоки — это блоки, освобождение которых задерживается, если `afxMemDF` была установлена в `delayFreeMemDF`.  
  
 Обычные блоки объектов, показанные во второй строке, остаются выделенными в куче.  
  
 Блоки без объектов включают в себя массивы и структуры, созданные с помощью `new`. В этом случае четыре блока без объектов были созданы в куче, но не освобождены.  
  
 `Largest number used` показывает наибольшее количество памяти, используемой программой в любое время.  
  
 `Total allocations` показывает общее количество памяти, используемой программой.  
  
 [Содержание раздела](#BKMK_In_this_topic)  
  
###  <a name="BKMK_Taking_object_dumps"></a> Получение дампов объектов  
 В программе MFC можно использовать [CMemoryState::DumpAllObjectsSince](http://msdn.microsoft.com/library/a7f89034-bca4-4786-88d5-1571a5425ab2) для помещения в дамп описания всех объектов в куче, которые не были освобождены. `DumpAllObjectsSince` Помещает в дамп все объекты, размещенные с момента последнего [CMemoryState::Checkpoint](http://msdn.microsoft.com/library/b2d80fea-3d21-457e-816d-b035909bf21a). Если вызова `Checkpoint` не было, `DumpAllObjectsSince` отображает все объекты и не-объекты, находящиеся в памяти на данный момент.  
  
> [!NOTE]
>  Прежде чем можно будет использовать функцию создания дампа объектов MFC, необходимо [включить диагностическую трассировку](../debugger/mfc-debugging-techniques.md#BKMK_Enabling_Memory_Diagnostics).  
  
> [!NOTE]
>  MFC автоматически отображает все потерянные объекты при выходе из программы, поэтому в точке выхода не нужно создавать для этого дополнительный код.  
  
 Следующий код — тест на утечку памяти путем сравнения двух состояний памяти и отображения всех объектов, если таковая обнаружилась.  
  
```  
if( diffMemState.Difference( oldMemState, newMemState ) )  
{  
   TRACE( "Memory leaked!\n" );  
   diffMemState.DumpAllObjectsSince();  
}  
```  
  
 Содержимое дампа выглядит следующим образом:  
  
```  
Dumping objects ->  
  
{5} strcore.cpp(80) : non-object block at $00A7521A, 9 bytes long  
{4} strcore.cpp(80) : non-object block at $00A751F8, 5 bytes long  
{3} strcore.cpp(80) : non-object block at $00A751D6, 6 bytes long  
{2} a CPerson at $51A4  
  
Last Name: Smith  
First Name: Alan  
Phone #: 581-0215  
  
{1} strcore.cpp(80) : non-object block at $00A7516E, 25 bytes long  
```  
  
 Числа в фигурных скобках в начале большинства строк указывают порядок размещения объектов в памяти. Объект, размещенный в последнюю очередь, имеет наибольший номер и появляется вверху дампа.  
  
 Чтобы извлечь из дампа объекта максимальное количество сведений, можно переопределить функцию-член `Dump` любого объекта, производного от `CObject`, чтобы настроить дамп объекта оптимальным образом.  
  
 Можно установить точку останова на определенном выделении памяти, задав глобальной переменной `_afxBreakAlloc` значение, показанное в фигурных скобках. При перезапуске программы отладчик остановит выполнение именно там, где происходит это выделение памяти. Теперь можно посмотреть стек вызовов и проанализировать, как программа дошла до этого места.  
  
 Библиотеки времени выполнения C тоже есть подобная функция, [_CrtSetBreakAlloc](http://msdn.microsoft.com/library/33bfc6af-a9ea-405b-a29f-1c2d4d9880a1), можно использовать для выделения времени выполнения C.  
  
 [Содержание раздела](#BKMK_In_this_topic)  
  
####  <a name="BKMK_Interpreting_memory_dumps"></a> Интерпретация дампов памяти  
 Рассмотрим этот дамп объекта более подробно:  
  
```  
{5} strcore.cpp(80) : non-object block at $00A7521A, 9 bytes long  
{4} strcore.cpp(80) : non-object block at $00A751F8, 5 bytes long  
{3} strcore.cpp(80) : non-object block at $00A751D6, 6 bytes long  
{2} a CPerson at $51A4  
  
Last Name: Smith  
First Name: Alan  
Phone #: 581-0215  
  
{1} strcore.cpp(80) : non-object block at $00A7516E, 25 bytes long  
```  
  
 Программа, которая создала этот дамп, выделяла память явным образом только дважды — один раз в стеке, а другой раз в куче:  
  
```  
// Do your memory allocations and deallocations.  
CString s("This is a frame variable");  
// The next object is a heap object.  
CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );  
```  
  
 `CPerson` получает три аргумента — указатели на тип `char`, используемые для инициализации переменных-членов `CString` . В дампе памяти объект `CPerson` размещается вместе с тремя не-объектными блоками (3, 4 и 5). Они содержат знаки для переменных-членов `CString` и не будут удалены в случае вызова деструктора объекта `CPerson` .  
  
 Блок номер 2 — собственно объект `CPerson` . `$51A4` представляет собой адрес блока, следует содержимое объекта, выводимое `CPerson`::`Dump` при вызове с помощью [DumpAllObjectsSince](http://msdn.microsoft.com/library/a7f89034-bca4-4786-88d5-1571a5425ab2).  
  
 Нетрудно догадаться, что блок номер 1 связан с переменной фрейма `CString` , это видно из порядкового номера и размера, соответствующего количеству знаков в переменной фрейма `CString` . Переменные, размещенные во фрейме, автоматически освобождаются, когда фрейм выходит за пределы области действия.  
  
 **Переменные фрейма**  
  
 В основном можно не волноваться по поводу объектов кучи, связанных с переменными фрейма, потому что они автоматически освобождаются, когда эти переменные выходят за пределы области действия. Чтобы избежать беспорядка в диагностическом дампе, следует располагать вызовы `Checkpoint` так, чтобы они находились вне области действия переменных фрейма. Например, поместите фигурные скобки так, чтобы они окружали код предыдущего выделения памяти:  
  
```  
oldMemState.Checkpoint();  
{  
    // Do your memory allocations and deallocations ...  
    CString s("This is a frame variable");  
    // The next object is a heap object.  
    CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );  
}  
newMemState.Checkpoint();  
```  
  
 С квадратными скобками в этих местах дамп памяти для этого примера выглядит следующим образом:  
  
```  
Dumping objects ->  
  
{5} strcore.cpp(80) : non-object block at $00A7521A, 9 bytes long  
{4} strcore.cpp(80) : non-object block at $00A751F8, 5 bytes long  
{3} strcore.cpp(80) : non-object block at $00A751D6, 6 bytes long  
{2} a CPerson at $51A4  
  
Last Name: Smith  
First Name: Alan  
Phone #: 581-0215  
```  
  
 **Не-объектные выделения**  
  
 Следует отметить, что выделения бывают "объектными" (например, `CPerson`) и "не-объектными". Не-объектные выделения — это выделения для объектов, которые не являются производными от `CObject` , а также выделения простых типов языка С, таких как `char`, `int`или **long**. Если класс, производный от **CObject**, выделяет дополнительное пространство, например внутренний буфер, такие объекты отобразят и объектное, и не-объектное выделение.  
  
 **Предотвращение утечек памяти**  
  
 Заметьте: в приведенном выше коде блок памяти, связанный с переменной фрейма `CString` , был освобожден автоматически и не отобразился как утечка. Автоматическое освобождение, обусловленное правилами ограничения области видимости, предотвращает большинство утечек памяти, связанных с переменными фрейма.  
  
 Однако для объектов, распределенных в куче, во избежание утечки памяти нужно явно удалять объект. Чтобы очистить последнюю утечку памяти в предыдущем примере, удалите объект `CPerson` , размещенный в куче:  
  
```  
{  
    // Do your memory allocations and deallocations.  
    CString s("This is a frame variable");  
    // The next object is a heap object.  
    CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );  
    delete p;  
}  
```  
  
 [Содержание раздела](#BKMK_In_this_topic)  
  
####  <a name="BKMK_Customizing_object_dumps"></a> Настройка дампов объектов  
 При наследовании от класса [CObject](http://msdn.microsoft.com/library/95e9acd3-d9eb-4ac0-b52b-ca4a501a7a3a), можно переопределить `Dump` функция-член для предоставления дополнительных сведений при использовании [DumpAllObjectsSince](http://msdn.microsoft.com/library/a7f89034-bca4-4786-88d5-1571a5425ab2) для вывода объектов [Окно вывода](../ide/reference/output-window.md).  
  
 `Dump` Функция записывает переменные текстовое описание членов объекта в контекст дампа ([CDumpContext](http://msdn.microsoft.com/library/98c52b2d-14b5-48ed-b423-479a4d1c60fa)). Контекст дампа подобен потоку ввода-вывода. Для отправки данных в**<<**&lt;&lt; `CDumpContext`.  
  
 При переопределении функции `Dump` следует вначале вызвать версию `Dump` базового класса для вывода содержимого объектов базового класса. Затем вывести текстовое описание и значение для каждой переменной-члена производного класса.  
  
 Объявление функции `Dump` выглядит следующим образом:  
  
```  
class CPerson : public CObject  
{  
public:  
#ifdef _DEBUG  
    virtual void Dump( CDumpContext& dc ) const;  
#endif  
  
    CString m_firstName;  
    CString m_lastName;  
    // And so on...  
};  
```  
  
 Поскольку формирование дампа объекта имеет смысл только при отладке программы, объявление функции `Dump` заключается в блок **#ifdef _DEBUG / #endif** .  
  
 В следующем примере функция `Dump` сначала вызывает функцию `Dump` для базового класса. Затем пишет короткое описание каждой переменной-члена и вместе со значением этой переменной направляет его в диагностический поток.  
  
```  
#ifdef _DEBUG  
void CPerson::Dump( CDumpContext& dc ) const  
{  
    // Call the base class function first.  
    CObject::Dump( dc );  
  
    // Now do the stuff for our specific class.  
    dc << "last name: " << m_lastName << "\n"  
        << "first name: " << m_firstName << "\n";  
}  
#endif  
```  
  
 Для указания, куда будут направлены выходные данные дампа, следует применить аргумент `CDumpContext` . Отладочная версия MFC использует предопределенный объект `CDumpContext` с именем `afxDump` , который направляет выходные данные в отладчик.  
  
```  
CPerson* pMyPerson = new CPerson;  
// Set some fields of the CPerson object.  
//...  
// Now dump the contents.  
#ifdef _DEBUG  
pMyPerson->Dump( afxDump );  
#endif  
```  
  
 [Содержание раздела](#BKMK_In_this_topic)  
  
##  <a name="BKMK_Reducing_the_size_of_an_MFC_Debug_build"></a> Сокращение размера отладочной сборки MFC  
 Отладочная информация для большого MFC-приложения может занимать значительное дисковое пространство. Для уменьшения размера можно использовать одну из описанных ниже процедур.  
  
1.  Перестройте библиотеки MFC с помощью [/Z7, / Zi, /ZI (формат отладочной информации)](http://msdn.microsoft.com/library/ce9fa7e1-0c9b-47e3-98ea-26d1a16257c8) параметр, а не **/Z7**. С помощью этих параметров строится один файл программной базы данных (PDB), содержащий отладочную информацию для всей библиотеки, тем самым сохраняется место на диске.  
  
2.  Перестройте библиотеки MFC без отладочной информации (не [/Z7, / Zi, /ZI (формат отладочной информации)](http://msdn.microsoft.com/library/ce9fa7e1-0c9b-47e3-98ea-26d1a16257c8) параметр). В этом случае из-за отсутствия отладочной информации использовать большинство возможностей отладчика внутри кода библиотеки MFC не удастся, но, так как библиотеки MFC уже отлажены, это не будет проблемой.  
  
3.  Соберите собственное приложение с отладочной информацией только для избранных модулей, используя описанную ниже процедуру.  
  
 [Содержание раздела](#BKMK_In_this_topic)  
  
###  <a name="BKMK_Building_an_MFC_app_with_debug_information_for_selected_modules"></a> Сборка приложения MFC с отладочной информацией для избранных модулей  
 Построение избранных модулей с отладочными библиотеками MFC позволяет использовать пошаговое выполнение и другие отладочные функции в этих модулях. Эта процедура использует и отладочный, и окончательный режимы сборочного файла проекта Visual C++, таким образом создавая необходимость изменений, описанных ниже (и также вынуждая "перестроить все", когда потребуется построение окончательной версии).  
  
1.  Выберите проект в Обозревателе решений.  
  
2.  В меню **Вид** выберите **Страницы свойств**.  
  
3.  Сначала создайте новую конфигурацию проекта.  
  
    1.  В  **\<проект > страницы свойств** диалоговом окне щелкните **Configuration Manager** кнопки.  
  
    2.  В диалоговом окне [Диспетчер конфигураций](http://msdn.microsoft.com/en-us/fa182dca-282e-4ae5-bf37-e155344ca18b)найдите нужный проект в таблице. В **конфигурации** столбец, выберите  **\<создать... >**.  
  
    3.  В диалоговом окне [Создание конфигурации проекта](http://msdn.microsoft.com/en-us/cca616dc-05a6-4fe3-bdc1-40c72a66f2be)введите имя новой конфигурации, например, "Неполная отладка" в поле **Имя конфигурации проекта** .  
  
    4.  В списке **Копировать параметры из** выберите **Выпуск**.  
  
    5.  Щелкните **OK** , чтобы закрыть диалоговое окно **Создание конфигурации проекта**.  
  
    6.  Закройте диалоговое окно **Диспетчер конфигураций** .  
  
4.  Теперь нужно настроить параметры для всего проекта.  
  
    1.  В диалоговом окне **Страницы свойств** в папке **Свойства конфигурации** выберите категорию **Общие** .  
  
    2.  В таблице параметров проекта разверните **Параметры проекта по умолчанию** (если нужно).  
  
    3.  В **Параметрах проекта по умолчанию**найдите **Использовать MFC**. В правом столбце таблицы появится текущее значение параметра. Измените его на **Использовать MFC в статической библиотеке**.  
  
    4.  В левой области диалогового окна **Страницы свойств** откройте папку **C/C++** и выберите **Препроцессор**. В таблице свойств найдите **Определения препроцессора** и замените NDEBUG на _DEBUG.  
  
    5.  В левой области диалогового окна **Страницы свойств** откройте папку **Компоновщик** и выберите категорию **Ввод** . В таблице свойств найдите **Дополнительные зависимости**. Для свойства **Дополнительные зависимости** введите NAFXCWD.LIB и LIBCMT.  
  
    6.  Нажмите **OK** , чтобы сохранить новые параметры построения, и закройте диалоговое окно **Страницы свойств** .  
  
5.  Из меню **Построение** выберите подпункт **Перестроить**. Это действие удалит всю отладочную информацию из модулей, но не затронет библиотеку MFC.  
  
6.  Теперь нужно добавить отладочную информацию в избранные модули приложения. Помните, что можно задавать точки останова и выполнять другие отладочные действия только в тех модулях, которые скомпилированы с отладочной информацией. Для каждого файла проекта, в который нужно включить отладочную информацию, проделайте следующие действия:  
  
    1.  В обозревателе решений откройте папку **Исходные файлы** , расположенную в проекте.  
  
    2.  Выберите файл, для которого нужно настроить отладочную информацию.  
  
    3.  В меню **Вид** выберите **Страницы свойств**.  
  
    4.  В диалоговом окне **Страницы свойств** в папке **Параметры конфигурации** откройте папку **C/C++** и выберите категорию **Общие** .  
  
    5.  В таблице свойств найдите **Формат отладочной информации.**  
  
    6.  Щелкните **Формат отладочной информации** и выберите нужный параметр (обычно **/ZI**.  
  
    7.  Если приложение создано с использованием мастера создания приложений или имеет предкомпилированные заголовки, следует эти заголовки выключить или перекомпилировать их перед компиляцией остальных модулей. Иначе будет получено предупреждение C4650 и сообщение об ошибке C2855. Предкомпилированные заголовки можно отключить, изменив **создать/использовать предкомпилированные заголовки** в  **\<проект > свойства** диалоговое окно (**свойства конфигурации**  папке **C/C++** во вложенную папку, **предкомпилированные заголовки** категории).  
  
7.  В меню **Построение** выберите **Построить** для перестройки устаревших файлов проекта.  
  
 Как альтернативу описанному здесь способу для настройки отдельных параметров каждого файла можно использовать внешний сборочный файл проекта. В этом случае, чтобы подключить отладочные библиотеки MFC, необходимо определить [_DEBUG](http://msdn.microsoft.com/library/a9901568-4846-4731-a404-399d947e2e7a) флаг для каждого модуля. Если необходимо использовать конечную версию библиотеки MFC, нужно определить NDEBUG. Дополнительные сведения о создании внешних сборочных файлов проекта см. в разделе [справочнике NMAKE](http://msdn.microsoft.com/library/0421104d-8b7b-4bf3-86c1-928d9b7c1a8c).  
  
 [Содержание раздела](#BKMK_In_this_topic)  
  
## <a name="see-also"></a>См. также  
 [Отладка Visual C++](../debugger/debugging-native-code.md)



