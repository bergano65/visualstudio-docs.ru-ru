---
title: Настройка создания и перемещения элементов | Документация Майкрософт
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-modeling
ms.topic: conceptual
f1_keywords:
- vs.dsltools.dsldesigner.elementmergedirective
helpviewer_keywords:
- Domain-Specific Language, element merge directives
ms.assetid: cbd28f15-dfd7-46bd-ab79-5430e3ed83c8
caps.latest.revision: 38
author: gewarren
ms.author: gewarren
manager: jillfra
ms.openlocfilehash: a62aacf8ad702aca19531876c57aaf45b10ce639
ms.sourcegitcommit: 8b538eea125241e9d6d8b7297b72a66faa9a4a47
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/23/2019
ms.locfileid: "58989282"
---
# <a name="customizing-element-creation-and-movement"></a>Настройка создания и перемещения элементов
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Вы можете разрешить элемент перетаскивать с панели инструментов или в Вставка на другой, или операции перемещения. С помощью связей, которые вы укажите, может иметь перемещенные элементы, связанные с целевыми элементами.  
  
 Директивы слияния элементов (EMD) указывает, что происходит, когда один элемент модели является *объединенных* в другой элемент модели. Это происходит, когда:  
  
- Пользователь перетаскивает из панели элементов на схему или фигуру.  
  
- Пользователь создает элемент с помощью меню "Добавить" в обозревателе или фигуры секции.  
  
- Пользователь перемещает элемент из одной дорожки в другую.  
  
- Пользователь вставляет данные элемента.  
  
- Код программы вызывает директива слияния элементов.  
  
  Несмотря на то, что операции по созданию может показаться отличается от операции копирования, они фактически работают таким же образом. При добавлении элемента, например из области элементов прототип она реплицируется. Прототип объединяется в модели в так же, как элементы, скопированные из другой части модели.  
  
  Ответственность за EMD важно решить, каким образом объектом или группой объектов должен быть объединен в определенном месте в модели. В частности он решает, какие связи должен создаваться для связывания группы в модели. Также можно настроить его, чтобы задать свойства и создание дополнительных объектов.  
  
  ![DSL&#45;EMD&#95;Merge](../modeling/media/dsl-emd-merge.png "DSL-EMD_Merge")  
  Роль директиву слияния элементов  
  
  EMD создается автоматически при определении отношение внедрения. Это значение по умолчанию EMD экземпляра связи при добавлении новых экземпляров дочернего к родительскому элементу. Можно изменить эти EMDs по умолчанию, например путем добавления пользовательского кода.  
  
  Можно также добавить собственные EMDs в определении DSL, чтобы разрешить пользователям перетаскивать или вставьте различных комбинаций объединенных и принимает классы.  
  
## <a name="defining-an-element-merge-directive"></a>Определение директивы слияния элементов  
 Можно добавить директивы слияния элементов для доменных классов, доменных связей, фигуры, соединители и схемы. Можно добавить или найти их в обозревателе DSL под принимающего класса домена. Принимающего класса является класс домена элемента, который уже находится в модели, а также в которой будут объединены нового или скопированного элемента.  
  
 ![DSL&#45;EMD&#95;сведения](../modeling/media/dsl-emd-details.png "DSL EMD_Details")  
  
 **Индексирования класс** — это класс домена элементов, которые могут быть объединены в члены, принимающего класса. Экземпляры подклассы класса индексирования также будет объединяться с этой EMD, если не задать **применяется к подклассам** значение false.  
  
 Существует два вида директива слияния.  
  
- Объект **процесс слияния** директива определяет связи, по которым необходимо связать новый элемент в дерево.  
  
- Объект **вперед слияния** директива перенаправляет нового элемента к другому элементу принимающей, обычно родительский элемент.  
  
  Можно добавить пользовательский код для слияния директивы:  
  
- Задайте **использует настраиваемое принятие** добавить собственный код, чтобы определить, следует ли объединить конкретного экземпляра индексирования элемента в целевой элемент. Когда пользователь перетаскивает из области элементов, указатель «недопустимый» показывает, если ваш код запрещает слияния.  
  
   Например можно разрешить слияния только в том случае, если принимающее элемент находится в определенном состоянии.  
  
- Задайте **использует пользовательское слияние** Добавление предоставить собственный код, чтобы определить изменения, внесенные в модель, когда выполняется слияние.  
  
   Например можно задать свойства в объединенный элемент, используя данные из нового местоположения в модели.  
  
> [!NOTE]
>  При написании пользовательского объединять код, он затрагивает только слияния, которые выполняются с использованием этого EMD. Если имеются другие EMDs, которые объединяют данные объекты одного типа, или если имеется другой пользовательский код, создающий эти объекты без использования EMD, затем они не затрагиваются в коде пользовательское слияние.  
>   
>  Если требуется, чтобы убедиться в том, что новый элемент или создать связь всегда обрабатывается в пользовательском коде, подумайте об определении `AddRule` на отношение внедрения и `DeleteRule` на класс домена этого элемента. Дополнительные сведения см. в разделе [распространение изменений в модели правил](../modeling/rules-propagate-changes-within-the-model.md).  
  
## <a name="example-defining-an-emd-without-custom-code"></a>Пример Определение EMD без пользовательского кода  
 Следующий пример позволяет пользователям создавать элемент и соединитель в то же время путем перетаскивания с панели элементов в существующую фигуру. В примере добавляется EMD в определении DSL. До этого изменения пользователи смогут перетаскивать средства на схему, но не на существующие фигуры.  
  
 Пользователи также можно вставить элементы в другие элементы.  
  
#### <a name="to-let-users-create-an-element-and-a-connector-at-the-same-time"></a>Чтобы пользователи могли создавать элемент и соединитель, в то же время  
  
1. Создайте новый доменный язык, с помощью **минимальный язык** шаблона решения.  
  
    При выполнении этого кода DSL, она предоставляет возможность создавать фигуры и соединители между фигурами. Нельзя перетащить новый **ExampleElement** фигуры с панели элементов в существующую фигуру.  
  
2. Чтобы позволить пользователям объединить элементы на `ExampleElement` фигур, создание новых EMD в `ExampleElement` доменного класса:  
  
   1.  В **обозреватель DSL**, разверните **доменных классов**. Щелкните правой кнопкой мыши `ExampleElement` и нажмите кнопку **добавить новый директива слияния**.  
  
   2.  Убедитесь, что **подробные сведения о DSL** окно открыто, таким образом, вы увидите сведения о новых EMD. (Меню: **Просмотреть**, **другие Windows**, **подробные сведения о DSL**.)  
  
3. Задайте **класс индексирования** в окне "сведения о DSL" для определения, какой класс элементов, которые могут быть объединены в `ExampleElement` объектов.  
  
    В этом примере выберите `ExampleElements`, так что пользователь может перетащить новые элементы на существующие элементы.  
  
    Обратите внимание на то, что класс индексирования становится именем EMD в обозревателе DSL.  
  
4. В разделе **обработать объединение путем создания ссылки**, добавьте два пути:  
  
   1. Один путь связывает новый элемент родительской модели. Выражение пути, необходимо ввести переходит от существующего элемента вверх через отношение внедрения к родительской модели. Наконец он указывает роль в новой ссылке, к которому будет назначен новый элемент. Путь выглядит следующим образом:  
  
       `ExampleModelHasElements.ExampleModel/!ExampleModel/.Elements`  
  
   2. Другой путь связывает новый элемент на существующий элемент. Выражение пути Задает ссылочное отношение и роль, к которому будет назначен новый элемент. Этот путь выглядит следующим образом:  
  
       `ExampleElementReferencesTargets.Sources`  
  
      Средство навигации пути можно использовать для создания каждого пути:  
  
   3. В разделе **обработать объединение путем создания ссылок по путям**, нажмите кнопку  **\<добавить путь >**.  
  
   4. Щелкните стрелку раскрывающегося списка справа от элемента списка. Откроется представление в виде дерева.  
  
   5. Разверните узлы в дереве для получения пути, который вы хотите указать.  
  
5. Проверьте DSL:  
  
   1.  Нажмите клавишу F5, чтобы перестроить и запустить решение.  
  
        Перестроение займет больше времени поскольку созданный код будет обновляться на основе текстовых шаблонов в соответствии с новым определением DSL.  
  
   2.  При экспериментальном экземпляре [!INCLUDE[vsprvs](../includes/vsprvs-md.md)] имеет к работе, откройте файл модели DSL. Создайте некоторые элементы пример.  
  
   3.  Перетащите из **пример элемента** средство на существующую фигуру.  
  
        Появится новая фигура, и она привязывается к существующую фигуру с соединителем.  
  
   4.  Скопируйте существующую фигуру. Выберите другую фигуру и вставьте.  
  
        Создается копия первой фигуры.  Он имеет новое имя и связывается эту фигуру с соединителем.  
  
   Из этой процедуры необходимо помнить следующее:  
  
-   Создавая директивы слияния элементов, вы можете разрешить любого класса элемент, чтобы принять любое другое. EMD создается в принимающей доменный класс и класс обслуживаемый домен, указанный в **класса индекса** поля.  
  
-   Определив пути, можно указать, какие ссылки следует использовать для подключения нового элемента в существующую модель.  
  
     Ссылки, указать должен включать одного отношения внедрения.  
  
-   EMD влияет на создание, и из элементов, а также операции вставки.  
  
     При написании пользовательского кода, которая создает новые элементы, можно явным образом вызвать EMD с помощью `ElementOperations.Merge` метод. Это гарантирует, что ваш код связывает новые элементы в модели в так же, как другие операции. Дополнительные сведения см. в разделе [Настройка поведения копирования](../modeling/customizing-copy-behavior.md).  
  
## <a name="example-adding-custom-accept-code-to-an-emd"></a>Пример Добавление кода настраиваемое принятие EMD  
 Путем добавления пользовательского кода для EMD, можно определить более сложное поведение слияния. В этом простом примере пользователю добавлять больше, чем фиксированное число элементов в схеме. В примере изменяется значение по умолчанию EMD, сопровождающий отношение внедрения.  
  
#### <a name="to-write-custom-accept-code-to-restrict-what-the-user-can-add"></a>Написание кода, настраиваемое принятие, чтобы ограничить пользователя, которые можно добавить  
  
1.  Создать DSL с помощью **минимальный язык** шаблона решения. Откройте схему определения DSL.  
  
2.  В обозревателе DSL разверните **доменных классов**, `ExampleModel`, **директивы слияния элементов**. Выберите директивы слияния элементов, которая называется `ExampleElement`.  
  
     Этот EMD контролирует, как пользователь может создавать новые `ExampleElement` объекты в модели, например, путем перетаскивания с панели инструментов.  
  
3.  В **подробные сведения о DSL** выберите **использует настраиваемое принятие**.  
  
4.  Выполните повторную сборку решения. Это займет больше времени, так как созданный код будет обновляться из модели.  
  
     Ошибка сборки будет сообщаемые, как: «Company.ElementMergeSample.ExampleElement не содержит определение для CanMergeExampleElement...»  
  
     Вы должны реализовать метод `CanMergeExampleElement`.  
  
5.  Создайте новый файл кода в **Dsl** проекта. Замените его содержимое следующим кодом и изменить пространство имен для пространства имен проекта.  
  
    ```csharp  
    using Microsoft.VisualStudio.Modeling;  
  
    namespace Company.ElementMergeSample // EDIT.  
    {  
      partial class ExampleModel  
      {  
        /// <summary>  
        /// Called whenever an ExampleElement is to be merged into this ExampleModel.  
        /// This happens when the user pastes an ExampleElement  
        /// or drags from the toolbox.  
        /// Determines whether the merge is allowed.  
        /// </summary>  
        /// <param name="rootElement">The root element in the merging EGP.</param>  
        /// <param name="elementGroupPrototype">The EGP that the user wants to merge.</param>  
        /// <returns>True if the merge is allowed</returns>  
        private bool CanMergeExampleElement(ProtoElementBase rootElement, ElementGroupPrototype elementGroupPrototype)  
        {  
          // Allow no more than 4 elements to be added:  
          return this.Elements.Count < 4;  
        }  
      }  
    }  
  
    ```  
  
     В этом простом примере ограничивает число элементов, которые могут быть объединены в родительской модели. Для более интересных условий метод можно проверить, какие-либо свойства, а также ссылки, принимающего объекта. Он также может проверять свойства слияния элементов, которые передаются в <xref:Microsoft.VisualStudio.Modeling.ElementGroupPrototype>. Дополнительные сведения о `ElementGroupPrototypes`, см. в разделе [Настройка поведения копирования](../modeling/customizing-copy-behavior.md). Дополнительные сведения о том, как написать код, который считывает модели см. в разделе [перехода и обновления модели в программном коде](../modeling/navigating-and-updating-a-model-in-program-code.md).  
  
6.  Проверьте DSL:  
  
    1.  Нажмите клавишу F5, чтобы перестроить решение. При экспериментальном экземпляре [!INCLUDE[vsprvs](../includes/vsprvs-md.md)] откроется, откройте экземпляр DSL.  
  
    2.  Создайте новые элементы несколькими способами:  
  
        1.  Перетащите из **пример элемента** средство на схему.  
  
        2.  В **обозревателя моделей пример**, щелкните правой кнопкой мыши корневой узел и нажмите кнопку **добавить новый элемент пример**.  
  
        3.  Скопируйте и вставьте элемент на схеме.  
  
    3.  Убедитесь, что нельзя использовать любой из этих способов добавления более четырех элементов модели. Это потому, что их директива слияния.  
  
## <a name="example-adding-custom-merge-code-to-an-emd"></a>Пример Добавление EMD слияния пользовательского кода  
 В коде пользовательское слияние можно определить, что происходит, когда пользователь перетаскивает средство или вставляет данные в элемент. Чтобы определить пользовательское слияние двумя способами:  
  
1. Задайте **слияния использует настраиваемый** и укажите требуемый код. Код заменяет код созданный слияния. Используйте этот параметр, если вы хотите полностью переопределить назначение слияния.  
  
2. Переопределить `MergeRelate` метод и при необходимости `MergeDisconnect` метод. Чтобы сделать это, необходимо задать **создает двойную производную** свойство доменного класса. Код может вызвать созданный объединять код в базовом классе. Используйте этот параметр, если вы хотите выполнять дополнительные операции, после выполнения слияния.  
  
   Эти подходы влияют только на слияния, которые выполняются с использованием этого EMD. Если вы хотите повлиять на всеми способами, в которых могут создаваться объединенный элемент, альтернативным вариантом является определение `AddRule` на отношение внедрения и `DeleteRule` на объединенные доменного класса. Дополнительные сведения см. в разделе [распространение изменений в модели правил](../modeling/rules-propagate-changes-within-the-model.md).  
  
#### <a name="to-override-mergerelate"></a>Чтобы переопределить MergeRelate  
  
1.  В определении DSL убедитесь, что вы определили EMD, к которому требуется добавить код. Если требуется, можно добавить пути и определить настраиваемое принятие кода, как описано в предыдущих разделах.  
  
2.  На схеме DslDefinition выберите принимающего класса слияния. Обычно это класс в конце источника отношение внедрения.  
  
     Например, в DSL, созданном из решения минимальный язык, выберите `ExampleModel`.  
  
3.  В **свойства** окне **создает двойную производную** для **true**.  
  
4.  Выполните повторную сборку решения.  
  
5.  Проверить содержимое **Dsl\Generated Files\DomainClasses.cs**. Поиск методов с именами `MergeRelate` и просматривать их содержимое. Это поможет вам создавать собственные версии.  
  
6.  В новый файл кода, написать разделяемый класс для принимающего класса и переопределить `MergeRelate` метод. Не забудьте вызвать базовый метод. Пример:  
  
    ```csharp  
    partial class ExampleModel  
    {  
      /// <summary>  
      /// Called when the user drags or pastes an ExampleElement onto the diagram.  
      /// Sets the time of day as the name.  
      /// </summary>  
      /// <param name="sourceElement">Element to be added</param>  
      /// <param name="elementGroup">Elements to be merged</param>  
      protected override void MergeRelate(ModelElement sourceElement, ElementGroup elementGroup)  
      {  
        // Connect the element according to the EMD:  
        base.MergeRelate(sourceElement, elementGroup);  
  
        // Custom actions:   
        ExampleElement mergingElement = sourceElement as ExampleElement;  
        if (mergingElement != null)  
        {  
          mergingElement.Name = DateTime.Now.ToLongTimeString();  
        }  
      }  
    }  
  
    ```  
  
#### <a name="to-write-custom-merge-code"></a>Написание кода пользовательского слияния  
  
1. В **Dsl\Generated Code\DomainClasses.cs**, проверять методов с именами `MergeRelate`. Эти методы создают ссылки между новым элементом и существующей модели.  
  
    Кроме того, проверьте методов с именами `MergeDisconnect`. Эти методы удалить связь элемента из модели, при его которого необходимо удалить.  
  
2. В **обозреватель DSL**выберите или создайте директивы слияния элементов, которую нужно настроить. В **подробные сведения о DSL** окне **слияния использует настраиваемый**.  
  
    При установке этого параметра **процесс слияния** и **вперед слияния** параметры учитываются. Вместо него используется код.  
  
3. Выполните повторную сборку решения. Займет больше времени, чем обычно, поскольку созданных файлах кода будет обновляться из модели.  
  
    Будут отображаться сообщения об ошибках. Дважды щелкните сообщения об ошибках, см. инструкции в созданном коде. Эти инструкции попросить вас предоставить два метода `MergeRelate` *YourDomainClass* и `MergeDisconnect` *YourDomainClass*  
  
4. Создайте методы в определение разделяемого класса в отдельном файле кода. На примерах, которые вы ранее проверен должна предлагать необходимые.  
  
   Пользовательское слияние кода не повлияет на код, который создает объекты и отношения напрямую и не влияет на другие EMDs. Чтобы убедиться, что независимо от того, как создается элемент реализуются дополнительные изменения, рассмотрите возможность записи `AddRule` и `DeleteRule` вместо этого. Дополнительные сведения см. в разделе [распространение изменений в модели правил](../modeling/rules-propagate-changes-within-the-model.md).  
  
## <a name="redirecting-a-merge-operation"></a>Перенаправление операции слияния  
 Директива слияния прямой перенаправляет целевого объекта операции слияния. Как правило новый целевой объект является внедрение родительским начального целевого объекта.  
  
 Например в DSL, который был создан с помощью шаблона диаграммы компонента, порты внедряются в компоненты. Порты, отображаются как небольшие фигуры на краю фигуры компонента. Пользователь создает порты перетаскиванием инструмента порта в форму компонента. Но в некоторых случаях пользователь по ошибке перетаскивает средство порта на существующий портов, а не компонент, и операция завершится ошибкой. Это простой ошибки, при наличии нескольких имеющихся портов. Чтобы помочь пользователю во избежание этого неудобство, вы можете разрешить порты перетащить на существующий порт, но действия, перенаправление в родительский компонент. Операция будет работать так, будто целевого элемента компонента.  
  
 Можно создать директива слияния вперед в решении модели компонентов. Если скомпилировать и запустить исходного решения, вы увидите, что пользователи смогут перетаскивать любое количество **входного порта** или **выходной порт** элементы из **элементов** для **Компонент** элемент. Тем не менее они не смогут перетаскивать порта к существующему порту. Указатель недоступен уведомлением о том, что этот переход не включен. Тем не менее, можно создать директива слияния вперед, чтобы порт, который был непреднамеренно удален на существующем **входного порта** перенаправляется **компонент** элемент.  
  
#### <a name="to-create-a-forward-merge-directive"></a>Чтобы создать директива слияния вперед  
  
1.  Создание [!INCLUDE[dsl](../includes/dsl-md.md)] решения с помощью шаблона модели компонентов.  
  
2.  Отображение **обозреватель DSL** , откройте DslDefinition.dsl.  
  
3.  В **обозреватель DSL**, разверните **доменных классов**.  
  
4.  **ComponentPort** абстрактного класса домена является базовым классом обоих **InPort** и **OutPort**. Щелкните правой кнопкой мыши **ComponentPort** и нажмите кнопку **добавить новый директива слияния**.  
  
     Новый **директивы слияния элементов** узел отображается в узле **директивы слияния элементов** узла.  
  
5.  Выберите **директивы слияния элементов** узел и откройте **подробные сведения о DSL** окна.  
  
6.  В списке класс индексирования выберите **ComponentPort**.  
  
7.  Выберите **переадресовать объединение в другой доменный класс**.  
  
8.  В списке выбора пути, разверните **ComponentPort**, разверните **ComponentHasPorts**, а затем выберите **компонент**.  
  
     Новый путь должен выглядеть примерно так:  
  
     **ComponentHasPorts.Component/!Component**  
  
9. Сохраните решение, а затем преобразует шаблоны, щелкнув самую верхнюю кнопку **обозревателе решений** панели инструментов.  
  
10. Постройте и запустите это решение. Новый экземпляр класса [!INCLUDE[vsprvs](../includes/vsprvs-md.md)] отображается.  
  
11. В **обозревателе решений**, откройте Sample.mydsl. Схемы и **ComponentLanguage элементов** отображаются.  
  
12. Перетащите **входного порта** из **элементов** в другой **входного порта.** Затем перетащите **OutputPort** для **InputPort** и затем в другую **OutputPort**.  
  
     Вы увидите не указатель недоступна, и можно вставить новый **входного порта** на существующую. Выберите новый **входного порта** и перетащите его на другую точку **компонент**.  
  
## <a name="see-also"></a>См. также  
 [Переход и обновление модели в программном коде](../modeling/navigating-and-updating-a-model-in-program-code.md)   
 [Настройка элементов и элементов](../modeling/customizing-tools-and-the-toolbox.md)   
 [Пример схемы канала DSL](http://code.msdn.microsoft.com/Visualization-Modeling-SDK-763778e8)
