---
title: Указание времени и места применения примечания | Документация Майкрософт
ms.custom: ''
ms.date: 2018-06-30
ms.prod: visual-studio-dev14
ms.reviewer: ''
ms.suite: ''
ms.technology:
- vs-devops-test
ms.tgt_pltfrm: ''
ms.topic: article
f1_keywords:
- _Group_
- _At_
- _When_
- _At_buffer_
ms.assetid: 8e4f4f9c-5dfa-4835-87df-ecd1698fc650
caps.latest.revision: 9
author: corob-msft
ms.author: gewarren
manager: ghogen
ms.openlocfilehash: 9ca11e9339534c1053a62442f4eb2e4a65ca2a62
ms.sourcegitcommit: 55f7ce2d5d2e458e35c45787f1935b237ee5c9f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2018
ms.locfileid: "47571535"
---
# <a name="specifying-when-and-where-an-annotation-applies"></a>Указание времени и места применения примечания
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Последнюю версию этого раздела можно найти в [Указание, когда и где к которому относится заметка](https://docs.microsoft.com/visualstudio/code-quality/specifying-when-and-where-an-annotation-applies).  
  
Если примечание условно, оно может требовать, чтобы другие примечания указали на это анализатору.  Например, если в функции есть переменная, которая может быть либо синхронной, либо асинхронной, то функция ведет себя следующим образом: в случае, если переменная синхронная, она всегда завершается успешно, а в случае, если переменная асинхронная, появляется сообщение об ошибке, если функция не может завершиться сразу. Когда функция вызывается синхронно, проверка значения результата не представляет никакого значения для анализатора кода, поскольку оно не было возвращено.  Однако если функция вызывается асинхронно и результат функции не проверяется, может возникнуть серьезная ошибка. Этот пример иллюстрирует ситуацию, в которой можно использовать примечание `_When_` для включения проверки, как описано далее в этой статье.  
  
## <a name="structural-annotations"></a>Структурные заметки  
 Для того, чтобы контролировать, когда и в каких местах применяются примечания, используйте следующие структурные примечания.  
  
|Комментарий|Описание|  
|----------------|-----------------|  
|`_At_(expr, anno-list)`|`expr` является выражением, которое предоставляет lvalue. Заметки в `anno-list` применяются к объекту с именем `expr`. Для каждого примечания в `anno-list`, `expr` интерпретируется в предусловии, если примечание интерпретируется в предусловии, и в постусловии, если примечание интерпретируется в постусловии.|  
|`_At_buffer_(expr, iter, elem-count, anno-list)`|`expr` является выражением, которое предоставляет lvalue. Заметки в `anno-list` применяются к объекту с именем `expr`. Для каждого примечания в `anno-list`, `expr` интерпретируется в предусловии, если примечание интерпретируется в предусловии, и в постусловии, если примечание интерпретируется в постусловии.<br /><br /> `iter` — имя переменной с областью видимости в примечании (включая `anno-list`). `iter` имеет неявный тип `long`. С одинаковыми именами переменных в любой внешней области видимости скрыты от оценки.<br /><br /> `elem-count` представляет собой выражение, результатом которого является целым числом.|  
|`_Group_(anno-list)`|Примечания в `anno-list` рассматриваются как имеющие любой квалификатор, который применяется к групповому примечанию, применяемому к каждому примечанию.|  
|`_When_(expr, anno-list)`|`expr` выражение, которое может быть преобразован в `bool`. Если он не равен нулю (`true`), то примечания, определенные в `anno-list`, считаются применимыми.<br /><br /> По умолчанию для каждого примечания в `anno-list`, `expr` интерпретируется с использованием входных значений, если это примечание с предусловием, и выходных значений, если это примечание с постусловием. Чтобы переопределить настройки по умолчанию, вы можете использовать встроенный `_Old_` для проверки постусловия, чтобы указать, что должны использоваться входные значения. **Примечание:** другие примечания могут быть включены как следствие использования `_When_` Если изменяемое значение — например, `*pLength`— участвует, так как результат вычисления `expr` в предусловии может отличаться от его вычисленное привести в постусловии.|  
  
## <a name="see-also"></a>См. также  
 [Использование аннотаций SAL для сокращения количества дефектов в коде C/C++](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md)   
 [Основные сведения о SAL](../code-quality/understanding-sal.md)   
 [Создание примечаний к функции параметров и возвращаемых значений](../code-quality/annotating-function-parameters-and-return-values.md)   
 [Аннотация поведения функций](../code-quality/annotating-function-behavior.md)   
 [Аннотация структур и классов](../code-quality/annotating-structs-and-classes.md)   
 [Аннотация поведения блокировки](../code-quality/annotating-locking-behavior.md)   
 [Встроенные функции](../code-quality/intrinsic-functions.md)   
 [Рекомендации и примеры](../code-quality/best-practices-and-examples-sal.md)



