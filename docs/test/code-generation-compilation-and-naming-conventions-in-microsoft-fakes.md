---
title: "Формирование и компиляция кода, а также соглашения об именовании в Microsoft Fakes | Документация Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- vs-devops-test
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 20221de4-2a9e-4787-b99a-b5855bb90872
caps.latest.revision: 16
ms.author: douge
manager: douge
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 4a36302d80f4bc397128e3838c9abf858a0b5fe8
ms.openlocfilehash: f68221fd37da500993e5afb9d3ee7e847f794a28
ms.contentlocale: ru-ru
ms.lasthandoff: 09/26/2017

---
# <a name="code-generation-compilation-and-naming-conventions-in-microsoft-fakes"></a>Формирование и компиляция кода, а также соглашения об именовании в Microsoft Fakes
В этом разделе рассматриваются проблемы и параметры, связанные с созданием и компиляцией кода Fakes, а также описаны соглашения об именовании для созданных типов, членов и параметров Fakes.  
  
 **Requirements**  
  
-   Visual Studio Enterprise  
  
##  <a name="BKMK_In_this_topic"></a> Содержание раздела  
  
-   [Формирование и компиляция кода](#BKMK_Code_generation_and_compilation)  
  
-   [Настройка формирования кода заглушек](#BKMK_Configuring_code_generation_of_stubs)
  
-   [Фильтрация типов](#BKMK_Type_filtering)
  
-   [Создание заглушек для конкретных классов и виртуальных методов](#BKMK_Stubbing_concrete_classes_and_virtual_methods)
  
-   [Внутренние типы](#BKMK_Internal_types)
  
-   [Оптимизация времени сборки](#BKMK_Optimizing_build_times)
  
-   [Предотвращение конфликтов имен сборок](#BKMK_Avoiding_assembly_name_clashing)  
  
-   [Соглашения об именовании для Fakes](#BKMK_Fakes_naming_conventions)  
  
-   [Соглашения об именовании для типов заглушек и типов оболочек](#BKMK_Shim_type_and_stub_type_naming_conventions)
  
-   [Соглашения об именовании для свойства делегата оболочки или поля делегата заглушки](#BKMK_Shim_delegate_property_or_stub_delegate_field_naming_conventions)
  
-   [Соглашения об именовании для типов параметров](#BKMK_Parameter_type_naming_conventions)
  
-   [Рекурсивные правила](#BKMK_Recursive_rules)  
  
-   [Внешние ресурсы](#BKMK_External_resources)  
  
-   [Руководство](#BKMK_Guidance)  
  
##  <a name="BKMK_Code_generation_and_compilation"></a> Формирование и компиляция кода  
  
###  <a name="BKMK_Configuring_code_generation_of_stubs"></a> Настройка формирования кода заглушек  
 Создание типов заглушек настраивается в XML-файле с расширением FAKES. Платформа Fakes интегрируется в процесс сборки с помощью пользовательских задач MSBuild и обнаруживает эти файлы во время сборки. Генератор кода Fakes компилирует типы заглушек в сборку и добавляет ссылку на проект.  
  
 Следующий пример иллюстрирует типы заглушек, определенные в FileSystem.dll:  
  
```xml  
<Fakes xmlns="http://schemas.microsoft.com/fakes/2011/">  
    <Assembly Name="FileSystem"/>  
</Fakes>  
  
```  
  
###  <a name="BKMK_Type_filtering"></a> Фильтрация типов  
 Фильтры можно задать в файле FAKES, чтобы ограничить перечень типов, которые должны быть заменены заглушками. Можно добавить неограниченное число элементов Clear, Add, Remove в элемент StubGeneration, чтобы сформировать список выбранных типов.  
  
 Например, этот файл FAKES создает заглушки для типов в пространствах имен System и System.IO, но исключает любой тип, содержащий Handle в пространстве имен System:  
  
```xml  
<Fakes xmlns="http://schemas.microsoft.com/fakes/2011/">  
  <Assembly Name="mscorlib" />  
  <!-- user code -->  
  <StubGeneration>  
    <Clear />  
    <Add Namespace="System!" />  
    <Add Namespace="System.IO!"/>  
    <Remove TypeName="Handle" />  
  </StubGeneration>  
  <!-- /user code -->  
</Fakes>  
```  
  
 В строках фильтра используется простая грамматика для определения того, как именно следует выполнять сопоставление:  
  
-   По умолчанию фильтры не учитывают регистр, выполняется сравнение подстрок:  
  
     `el` соответствует значению hello  
  
-   Добавление `!` в конец фильтра обеспечит точное совпадение с учетом регистра:  
  
     `el!` не соответствует значению hello  
  
     `hello!` соответствует значению hello  
  
-   Добавление `*` в конец фильтра обеспечит соответствие префиксу строки:  
  
     `el*` не соответствует значению hello  
  
     `he*` соответствует значению hello  
  
-   Несколько фильтров в списке, разделенных точкой с запятой, объединяются в виде дизъюнкции:  
  
     `el;wo` соответствует значениям hello и world  
  
###  <a name="BKMK_Stubbing_concrete_classes_and_virtual_methods"></a> Создание заглушек для конкретных классов и виртуальных методов  
 По умолчанию типы заглушек создаются для всех незапечатанных классов. Типы заглушки можно ограничить абстрактными классами с помощью файла конфигурации FAKES:  
  
```xml  
<Fakes xmlns="http://schemas.microsoft.com/fakes/2011/">  
  <Assembly Name="mscorlib" />  
  <!-- user code -->  
  <StubGeneration>  
    <Types>  
      <Clear />  
      <Add AbstractClasses="true"/>  
    </Types>  
  </StubGeneration>  
  <!-- /user code -->  
</Fakes>  
```  
  
###  <a name="BKMK_Internal_types"></a> Внутренние типы  
 Генератор кода Fakes будет создавать типы оболочек и типы заглушки для типов, которые являются видимыми для созданной сборки Fakes. Чтобы сделать внутренние типы сборки с оболочкой совместимости видимыми для сборки Fakes и тестовой сборки, добавьте атрибуты <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> в код сборки с оболочкой совместимости, отвечающий за видимость для созданной сборки Fakes и тестовой сборки. Ниже приведен пример:  
  
```csharp  
// FileSystem\AssemblyInfo.cs  
[assembly: InternalsVisibleTo("FileSystem.Fakes")]  
[assembly: InternalsVisibleTo("FileSystem.Tests")]  
```  
  
 **Внутренние типы в сборках со строгими именами**  
  
 Если сборка с оболочкой совместимости имеет строгое имя и требуется доступ ко внутренним типам сборки:  
  
-   Как тестовая сборка, так и сборка Fakes должна иметь строгое имя.  
  
-   Необходимо добавить открытые ключи сборки Fakes и тестовой сборки в атрибуты **InternalsVisibleToAttribute** в сборках с оболочкой совместимости. Вот как будут выглядеть наши образцы атрибутов в коде сборки с оболочкой совместимости, когда сборка с оболочкой совместимости имеет строгое имя.  
  
    ```csharp  
    // FileSystem\AssemblyInfo.cs  
    [assembly: InternalsVisibleTo("FileSystem.Fakes",  
        PublicKey=<Fakes_assembly_public_key>)]  
    [assembly: InternalsVisibleTo("FileSystem.Tests",  
        PublicKey=<Test_assembly_public_key>)]  
    ```  
  
 Если сборка с оболочкой совместимости имеет строгое имя, платформа Fakes автоматически назначает созданной сборке Fakes строгую подпись. Тестовой сборке следует назначить строгую подпись. См. статью [Создание и использование сборок со строгими именами](http://msdn.microsoft.com/Library/ffbf6d9e-4a88-4a8a-9645-4ce0ee1ee5f9).  
  
 Платформа Fakes использует один и тот же ключ для подписывания всех созданных сборок, поэтому этот фрагмент кода можно использовать в качестве основы для добавления атрибута **InternalsVisibleTo** для сборки Fakes в код сборки с оболочкой совместимости.  
  
```csharp  
[assembly: InternalsVisibleTo("FileSystem.Fakes, PublicKey=0024000004800000940000000602000000240000525341310004000001000100e92decb949446f688ab9f6973436c535bf50acd1fd580495aae3f875aa4e4f663ca77908c63b7f0996977cb98fcfdb35e05aa2c842002703cad835473caac5ef14107e3a7fae01120a96558785f48319f66daabc862872b2c53f5ac11fa335c0165e202b4c011334c7bc8f4c4e570cf255190f4e3e2cbc9137ca57cb687947bc")]  
```  
  
 Можно указать другой открытый ключ для сборки Fakes, например ключ, созданный для сборки с оболочкой совместимости, указав полный путь к **SNK-файлу**, который содержит альтернативный ключ в виде значения атрибута `KeyFile` в элементе `Fakes`\\`Compilation` **FAKES-файла**. Пример:  
  
```xml  
<-- FileSystem.Fakes.fakes -->  
<Fakes ...>  
  <Compilation KeyFile="full_path_to_the_alternate_snk_file" />  
</Fakes>  
  
```  
  
 Затем следует использовать открытый ключ из альтернативного **SNK-файла** в качестве второго параметра атрибута InternalVisibleTo для сборки Fakes в коде сборки с оболочкой совместимости:  
  
```csharp  
// FileSystem\AssemblyInfo.cs  
[assembly: InternalsVisibleTo("FileSystem.Fakes",  
    PublicKey=<Alternate_public_key>)]  
[assembly: InternalsVisibleTo("FileSystem.Tests",  
    PublicKey=<Test_assembly_public_key>)]  
```  
  
 В приведенном выше примере значения `Alternate_public_key` и `Test_assembly_public_key` могут быть одинаковыми.  
  
###  <a name="BKMK_Optimizing_build_times"></a> Оптимизация времени сборки  
 Компиляция сборок Fakes может значительно затянуть время сборки. Можно сократить время сборки, создав сборки имитаций для сборки Fakes для системных сборок платформы .NET системы и сторонних сборок в отдельном централизованном проекте. Поскольку такие сборки редко изменяются на компьютере, созданные сборки Fakes можно повторно использовать в других проектах.  
  
 Из проектов модульных тестов можно просто указать ссылку на скомпилированные сборки Fakes, помещенные в FakesAssemblies в папке проекта.  
  
1.  Создайте новую библиотеку классов с версией среды выполнения .NET, соответствующей тестовым проектам. Назовем ее Fakes.Prebuild. Удалите файл class1.cs в проекте, так как он нам не нужен.  
  
2.  Добавьте ссылку на все системные и сторонние сборки, для которых требуется Fakes.  
  
3.  Добавьте файл FAKES для каждой сборки и выполните сборку.  
  
4.  В тестовом проекте  
  
    -   Убедитесь в наличии ссылки на библиотеку DLL среды выполнения Fakes:  
  
         C:\Program Files\Microsoft Visual Studio 12.0\Common7\IDE\PublicAssemblies\Microsoft.QualityTools.Testing.Fakes.dll  
  
    -   Для каждой сборки, для которой вы создали Fakes, добавьте ссылку на соответствующий файл DLL в папке Fakes.Prebuild\FakesAssemblies проекта.  
  
###  <a name="BKMK_Avoiding_assembly_name_clashing"></a> Предотвращение конфликтов имен сборок  
 В среде Team Build все выходные данные сборки объединяются в одном каталоге. При работе с несколькими проектами, где используется Fakes, может возникнуть ситуация, когда сборки Fakes из другой версии переопределяют друг друга. Например, как mscorlib.dll сборки Fakes TestProject1 имитаций из .NET Framework 2.0, так и mscorlib.dll сборки Fakes TestProject2 для .NET Framework 4 будут выводить данные в mscorlib. сборку Fakes mscorlib.Fakes.dll.  
  
 Чтобы избежать этой проблемы, платформа Fakes должна автоматически создавать учитывающие версию имена сборок Fakes для ссылок, не относящихся к проектам, при добавлении файлов FAKES. Учитывающее версию имя сборки Fakes внедряет номер версии при создании имени сборки Fakes:  
  
 В случае со сборкой Fakes MyAssembly и версией 1.2.3.4 имя будет иметь вид MyAssembly.1.2.3.4.Fakes.  
  
 Можно изменить или удалить эту версию, изменив атрибут Version элемента Assembly в файле FAKES:  
  
```xml  
attribute of the Assembly element in the .fakes:  
<Fakes ...>  
  <Assembly Name="MyAssembly" Version="1.2.3.4" />  
  ...  
</Fakes>  
  
```  
  
##  <a name="BKMK_Fakes_naming_conventions"></a> Соглашения об именовании для Fakes  
  
###  <a name="BKMK_Shim_type_and_stub_type_naming_conventions"></a> Соглашения об именовании для типов заглушек и типов оболочек  
 **Пространства имен**  
  
-   К пространству имен добавляется суффикс .Fakes.  
  
     Например, `System.Fakes` пространство имен содержит типы оболочек пространства имен System.  
  
-   Global.Fakes содержит тип оболочки пустого пространства имен.  
  
 **Имена типов**  
  
-   Префикс оболочки добавляется к имени типа для получения имени типа оболочки.  
  
     Например, ShimExample является типом оболочки типа Example.  
  
-   Префикс заглушки добавляется к имени типа для получения имени типа заглушки.  
  
     Например, StubIExample является типом заглушки типа IExample.  
  
 **Аргументы типа и структуры вложенных типов**  
  
-   Аргументы универсального типа копируются.  
  
-   Структура вложенного типа копируется для типов оболочек.  
  
###  <a name="BKMK_Shim_delegate_property_or_stub_delegate_field_naming_conventions"></a> Соглашения об именовании для свойства делегата оболочки или поля делегата заглушки  
 **Основные правила** для именования полей, начиная с пустого имени:  
  
-   Имя метода добавляется.  
  
-   Если имя метода является явной реализацией интерфейса, точки удаляются.  
  
-   Если метод является универсальным, добавляется `Of`*n*, где *n* — число аргументов универсального метода.  
  
 **Имена особых методов**, таких как методы получения или задания свойства, обрабатываются согласно описанию в следующей таблице.  
  
|Чем является метод...|Пример|Добавление к имени метода|  
|-------------------|-------------|--------------------------|  
|**Конструктор**|`.ctor`|`Constructor`|  
|Статический **конструктор**|`.cctor`|`StaticConstructor`|  
|**Метод доступа**, имя которого состоит из двух частей, разделенных символом "_" (например, методы получения свойств)|*kind_name* (распространенный вариант, однако он не является обязательным согласно ECMA)|*NameKind*, где обе части начинаются с прописных букв и поменяны местами|  
||Метод получения свойства `Prop`|`PropGet`|  
||Метод задания свойства `Prop`|`PropSet`|  
||Метод добавления события|`Add`|  
||Метод удаления события|`Remove`|  
|**Оператор**, состоящий из двух частей|`op_name`|`NameOp`|  
|Например, оператор +|`op_Add`|`AddOp`|  
|Для **оператора преобразования** добавляется тип возвращаемого значения.|`T op_Implicit`|`ImplicitOpT`|  
  
 **Примечания**  
  
-   **Методы получения и задания индексаторов** обрабатываются так же, как и методы для свойств. Для индексаторов имя по умолчанию имеет значение `Item`.  
  
-   Имена **типов параметров** преобразуются и объединяются.  
  
-   **Тип возвращаемого значения** игнорируется, если нет неоднозначности перегрузки. В этом случае тип возвращаемого значения добавляется в конец имени.  
  
###  <a name="BKMK_Parameter_type_naming_conventions"></a> Соглашения об именовании для типов параметров  
  
|Задано|Добавляемая строка...|  
|-----------|-------------------------|  
|**Тип**`T`|T<br /><br /> Пространство имен, вложенная структура и универсальные регистрации удаляются.|  
|**Параметр вывода**`out T`|`TOut`|  
|**Параметр ссылки** `ref T`|`TRef`|  
|**Тип массива**`T[]`|`TArray`|  
|Тип **многомерного массива**`T[ , , ]`|`T3`|  
|Тип **указателя**`T*`|`TPtr`|  
|**Универсальный тип**`T<R1, ...>`|`TOfR1`|  
|**Аргумент универсального типа**`!i` для типа `C<TType>`|`Ti`|  
|**Аргумент универсального метода**`!!i` для метода `M<MMethod>`|`Mi`|  
|**Вложенный тип**`N.T`|Добавляется `N`, затем `T`|  
  
###  <a name="BKMK_Recursive_rules"></a> Рекурсивные правила  
 Рекурсивно применяются следующие правила:  
  
-   Поскольку платформа Fakes использует C# для создания сборок Fakes, любой символ приведет к тому, что недопустимый токен C#, экранируется за «_» (символ подчеркивания).  
  
-   Если результирующее имя конфликтует с любым членом объявляющего типа, используется схема нумерации, заключающаяся в добавлении двухзначного счетчика, начиная со значения 01.  
  
##  <a name="BKMK_External_resources"></a> Внешние ресурсы  
  
###  <a name="BKMK_Guidance"></a> Руководство  
 [Тестирование непрерывной доставки с Visual Studio 2012 — глава 2. Модульное тестирование. Внутреннее тестирование](http://go.microsoft.com/fwlink/?LinkID=255188)  
  
## <a name="see-also"></a>См. также  
 [Изоляция тестируемого кода с помощью Microsoft Fakes](../test/isolating-code-under-test-with-microsoft-fakes.md)

