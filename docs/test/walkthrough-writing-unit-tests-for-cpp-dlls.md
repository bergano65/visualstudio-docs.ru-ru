---
title: Как выполнить Создание модульных тестов для библиотек DLL на C++
ms.date: 11/04/2017
ms.prod: visual-studio-dev15
ms.topic: conceptual
ms.author: mblome
manager: jillfra
ms.workload:
- cplusplus
author: mikeblome
ms.openlocfilehash: 8806e21159e270385bfbd88106569f9a1722c08a
ms.sourcegitcommit: 2193323efc608118e0ce6f6b2ff532f158245d56
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/25/2019
ms.locfileid: "54951148"
---
# <a name="how-to-write-unit-tests-for-c-dlls"></a>Как выполнить Создание модульных тестов для библиотек DLL на C++

В этом пошаговом руководстве описывается разработка библиотеки DLL на неуправляемом C++ с использованием методологии на основе тестирования. Порядок действий таков:

1.  [Создайте тестовый проект для машинного кода](#create_test_project). Тестовый проект относится к тому же решению, что и проект библиотеки DLL.

2.  [Создание проекта библиотеки DLL](#create_dll_project). В этом пошаговом руководстве создается новая библиотека DLL, но процедура тестирования существующей библиотеки DLL аналогична.

3.  [Сделайте функции DLL доступными для тестов](#make_functions_visible).

4.  [Итеративно расширяйте тесты](#iterate). Рекомендуется цикл "красный — зеленый — рефакторинг", при котором разработка кода проводится согласно результатам тестов.

5.  [Выполните отладку непройденных тестов](#debug). Тесты можно выполнять в режиме отладки.

6.  [Выполняйте рефакторинг, оставляя тесты без изменений](#refactor). Рефакторинг означает улучшение структуры кода без изменения его внешнего поведения. Это можно сделать для повышения производительности, расширяемости и удобочитаемости кода. Так как поведение кода должно сохраняться, не изменяйте тесты при проведении рефакторинга. Тесты помогают убедиться в том, что при выполнении рефакторинга не возникнут новые ошибки.

7.  [Проверьте охват](using-code-coverage-to-determine-how-much-code-is-being-tested.md). Модульные тесты более полезны, когда они охватывают больше кода. Вы можете узнать, какие части кода использовались тестами.

8.  [Изолируйте модули от внешних ресурсов](using-stubs-to-isolate-parts-of-your-application-from-each-other-for-unit-testing.md). Обычно библиотека DLL зависит от других компонентов разрабатываемой системы, таких как другие библиотеки DLL, базы данных или удаленные подсистемы. Полезно тестировать каждый модуль отдельно от его зависимостей. Внешние компоненты могут сделать выполнение тестов медленным. Во время разработки другие компоненты могут быть еще не готовы.

##  <a name="create_test_project"></a> Создание проекта машинного модульного теста

1.  В меню **Файл** последовательно выберите пункты **Создать** > **Проект**.

     В диалоговом окне последовательно разверните узлы **Установлено** > **Шаблоны** > **Visual C++** > **Тест**.

     Выберите шаблон **Проект машинного модульного теста** или проект другой установленной платформы. При выборе другого шаблона, например Google Test или Boost.Test, основные принципы сохраняются, хотя могут быть некоторые особенности.

     В этом пошаговом руководстве тестовый проект называется `NativeRooterTest`.

     ![Создание проекта модульного теста C++](../test/media/utecpp01.png)

2.  В новом проекте изучите файл **unittest1.cpp**.

     ![Проект теста с TEST&#95;CLASS и TEST&#95;METHOD](../test/media/utecpp2.png)

     Обратите внимание на указанные ниже моменты.

    -   Каждый тест определяется с использованием `TEST_METHOD(YourTestName){...}`.

         Стандартную сигнатуру функции писать не требуется. Сигнатура создается макросом TEST_METHOD. Макрос создает функцию экземпляра, которая возвращает значение void. Она также создает статическую функцию, которая возвращает сведения о тестовом методе. Эти сведения позволят обозревателю тестов найти этот метод.

    -   Тестовые методы группируются в классы с помощью `TEST_CLASS(YourClassName){...}`.

         Во время выполнения тестов создается экземпляр каждого тестового класса. Тестовые методы вызываются в неопределенном порядке. Можно задать особые методы, которые вызываются до и после каждого модуля, класса или метода.

3.  Убедитесь в том, что тесты выполняются в обозревателе тестов.

    1.  Добавьте код теста:

        ```cpp
        TEST_METHOD(TestMethod1)
        {
            Assert::AreEqual(1,1);
        }
        ```

         Обратите внимание, что класс `Assert` содержит несколько статических методов, которые можно использовать для проверки результатов в тестовых методах.

    2.  В меню **Тест** выберите **Запуск** > **Все тесты**.

         Произойдет сборка и запуск теста.

         Появится **обозреватель тестов**.

         Тест отображается в списке **Пройденные тесты**.

         ![Обозреватель модульных тестов с одним пройденным тестом](../test/media/utecpp04.png)

##  <a name="create_dll_project"></a> Создание проекта библиотеки DLL

1.  Создайте проект **Visual C++** с помощью шаблона **Проект Win32**.

     В этом пошаговом руководстве проект называется `RootFinder`.

     ![Создание проекта Win32 C++](../test/media/utecpp05.png)

2.  В мастере приложения Win32 выберите параметры **DLL** и **Экспортировать символы**.

     Параметр **Экспортировать символы** создает удобный макрос, который можно использовать для объявления экспортированных методов.

     ![Мастер проектов C++, настроенный для DLL и символов экспорта](../test/media/utecpp06.png)

3.  Объявите экспортированную функцию в основном *H*-файле.

     ![Новый проект кода DLL и H-файл с макросами API](../test/media/utecpp07.png)

     Оператор объявления `__declspec(dllexport)` делает открытые и защищенные члены класса видимыми вне библиотеки DLL. Для получения дополнительной информации см. [Using dllimport and dllexport in C++ Classes](/cpp/cpp/using-dllimport-and-dllexport-in-cpp-classes).

4.  В основной *CPP*-файл добавьте минимальное тело функции.

    ```cpp
        // Find the square root of a number.
        double CRootFinder::SquareRoot(double v)
        {
            return 0.0;
        }
    ```

##  <a name="make_functions_visible"></a> Привязка тестового проекта к проекту библиотеки DLL

1. Добавьте проект DLL в ссылки тестового проекта.

   1.  Откройте свойства тестового проекта и выберите **Общие свойства** > **.NET Framework и ссылки**.

        ![Свойства проекта C++ | .NET Framework и ссылки](../test/media/utecpp08.png)

   2.  Выберите команду **Добавить новую ссылку**.

        В диалоговом окне **Добавление ссылки** выберите проект библиотеки DLL и нажмите **Добавить**.

        ![Свойства проекта C++ | Добавление новой ссылки](../test/media/utecpp09.png)

2. В основном *CPP*-файле модульного теста включите *H*-файл кода библиотеки DLL.

   ```cpp
   #include "..\RootFinder\RootFinder.h"
   ```

3. Добавьте простой тест, который использует экспортированную функцию.

   ```cpp
   TEST_METHOD(BasicTest)
   {
      CRootFinder rooter;
      Assert::AreEqual(
         // Expected value:
         0.0,
         // Actual value:
         rooter.SquareRoot(0.0),
         // Tolerance:
         0.01,
        // Message:
        L"Basic test failed",
        // Line number - used if there is no PDB file:
        LINE_INFO());
   }
   ```

4. Постройте решение.

    Новый тест появится в **обозревателе тестов**.

5. В **обозревателе тестов** выберите **Запустить все**.

    ![Обозреватель модульных тестов — базовый тест пройден](../test/media/utecpp10.png)

   Вы настроили тест и проекты кода и подтвердили, что можно выполнять тесты, которые запускают функции из проекта кода. Теперь можно начать писать реальные тесты и код.

##  <a name="iterate"></a> Итеративное расширение тестов и обеспечение их успешного выполнения

1.  Добавьте новый тест.

    ```cpp
    TEST_METHOD(RangeTest)
    {
      CRootFinder rooter;
      for (double v = 1e-6; v < 1e6; v = v * 3.2)
      {
        double actual = rooter.SquareRoot(v*v);
        Assert::AreEqual(v, actual, v/1000);
      }
    }
    ```

    > [!TIP]
    > Рекомендуется не изменять пройденные тесты. Вместо этого добавьте новый тест, обновите код так, чтобы тест проходил успешно, а затем добавьте еще один тест и т. д.
    >
    > При изменении пользователями требований отключите тесты, которые больше не являются корректными. Создайте новые тесты и сделайте так, чтобы они работали по одному в инкрементном режиме.

2.  Выполните сборку решения, а затем в **обозревателе тестов** щелкните **Запустить все**.

     Новый тест завершится сбоем.

     ![Сбой теста RangeTest](../test/media/ute_cpp_testexplorer_rangetest_fail.png)

    > [!TIP]
    > Убедитесь в том, что каждый тест завершается сбоем, сразу после того, как вы написали его. Это поможет избежать распространенной ошибки, заключающейся в написании теста, который никогда не завершается сбоем.

3.  Исправьте код библиотеки DLL, чтобы новый тест проводился успешно:

    ```cpp
    #include <math.h>
    ...
    double CRootFinder::SquareRoot(double v)
    {
      double result = v;
      double diff = v;
      while (diff > result/1000)
      {
        double oldResult = result;
        result = result - (result*result - v)/(2*result);
        diff = abs (oldResult - result);
      }
      return result;
    }
    ```

4.  Выполните сборку решения, а затем в **обозревателе тестов** щелкните **Запустить все**.

     Оба теста будут пройдены успешно.

     ![Обозреватель модульных тестов — тест RangeTest пройден](../test/media/utecpp12.png)

    > [!TIP]
    > Разрабатывайте код, добавляя тесты по одному. После каждой итерации проверяйте, все ли тесты завершаются успешно.

##  <a name="debug"></a> Отладка непройденного теста

1.  Добавьте еще один тест.

    ```cpp
    #include <stdexcept>
    ...
    // Verify that negative inputs throw an exception.
    TEST_METHOD(NegativeRangeTest)
    {
      wchar_t message[200];
      CRootFinder rooter;
      for (double v = -0.1; v > -3.0; v = v - 0.5)
      {
        try
        {
          // Should raise an exception:
          double result = rooter.SquareRoot(v);

          _swprintf(message, L"No exception for input %g", v);
          Assert::Fail(message, LINE_INFO());
        }
        catch (std::out_of_range ex)
        {
          continue; // Correct exception.
        }
        catch (...)
        {
          _swprintf(message, L"Incorrect exception for %g", v);
          Assert::Fail(message, LINE_INFO());
        }
      }
    }
    ```

2.  Выполните сборку решения и щелкните **Запустить все**.

3.  Откройте (или дважды щелкните) непройденный тест.

     Ошибочное проверочное утверждение будет выделено. Сообщение об ошибке отображается в области сведений **обозревателя тестов**.

     ![Сбой тестов NegativeRangeTests](../test/media/ute_cpp_testexplorer_negativerangetest_fail.png)

4.  Чтобы увидеть, почему тест не был пройден, выполните функцию пошагово.

    1.  Установите точку останова в начале функции SquareRoot.

    2.  В контекстном меню непройденного теста выберите **Отладить выбранные тесты**.

         Когда выполнение прекратится на точке останова, выполните код по шагам.

5.  Вставьте код в функцию, которую вы разрабатываете:

    ```cpp

    #include <stdexcept>
    ...
    double CRootFinder::SquareRoot(double v)
    {
        // Validate parameter:
        if (v < 0.0)
        {
          throw std::out_of_range("Can't do square roots of negatives");
        }

    ```

6.  Теперь все тесты проходят успешно.

     ![Все тесты пройдены](../test/media/ute_ult_alltestspass.png)

> [!TIP]
> Если у отдельных тестов нет зависимостей, предотвращающих выполнение этих тестов в любом порядке, включите параллельное тестирование с помощью переключателя ![UTE&#95;parallelicon&#45;small](../test/media/ute_parallelicon-small.png) на панели инструментов. Это может заметно сократить время, необходимое для выполнения всех тестов.


##  <a name="refactor"></a> Рефакторинг кода без изменения тестов

1.  Упростите основное вычисление в функции SquareRoot.

    ```cpp
    // old code:
    //   result = result - (result*result - v)/(2*result);
    // new code:
         result = (result + v/result)/2.0;

    ```

2.  Выполните сборку решения и щелкните **Запустить все**, чтобы убедиться в том, что не появилось новых ошибок.

    > [!TIP]
    > Хороший набор модульных тестов дает уверенность в том, что при изменении кода не появилось новых ошибок.
    >
    > Рефакторинг должен осуществляться отдельно от других изменений.

## <a name="next-steps"></a>Следующие шаги

-   **Изоляция**. Большинство библиотек DLL зависит от других подсистем, например от баз данных и других библиотек DLL. Эти другие компоненты часто разрабатываются параллельно. Чтобы модульное тестирование могло выполняться, пока другие компоненты еще не доступны, нужно заменить макет или выполнить

-   **Тесты проверки сборки**. Тесты можно выполнять на сервере сборки рабочей группы через заданные промежутки времени. Это гарантирует то, что во время объединения результатов работы, выполненной разными членами рабочей группы, не появятся новые ошибки.

-   **Тесты влияния изменений**. Можно потребовать, чтобы некоторые тесты выполнялись перед тем, как каждый участник рабочей группы вернет код в систему управления версиями. Обычно это подмножество полного набора тестов проверки сборки.

     Можно также требовать минимального уровня покрытия кода.

## <a name="see-also"></a>См. также

- [Модульное тестирование существующих приложений C++ с использованием обозревателя тестов](../test/how-to-use-microsoft-test-framework-for-cpp.md)
- [Использование пространства имен Microsoft.VisualStudio.TestTools.CppUnitTestFramework](how-to-use-microsoft-test-framework-for-cpp.md)
- [Отладка машинного кода](../debugger/debugging-native-code.md)
- [Пошаговое руководство: издание и использование библиотеки DLL (C++)](/cpp/build/walkthrough-creating-and-using-a-dynamic-link-library-cpp)
- [Импорт и экспорт](/cpp/build/importing-and-exporting)
