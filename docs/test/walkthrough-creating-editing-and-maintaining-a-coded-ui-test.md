---
title: "Пошаговое руководство. Создание, изменение и обслуживание закодированного теста пользовательского интерфейса | Документация Майкрософт"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- vs-devops-test
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: f7c25ba7-5c9c-455b-9242-701cda56f90c
caps.latest.revision: 41
ms.author: douge
manager: douge
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 4a36302d80f4bc397128e3838c9abf858a0b5fe8
ms.openlocfilehash: 63dd3f809e472bea8f558bff15e17bbfa0421a2c
ms.contentlocale: ru-ru
ms.lasthandoff: 09/26/2017

---
# <a name="walkthrough-creating-editing-and-maintaining-a-coded-ui-test"></a>Пошаговое руководство. Создание, изменение и обслуживание закодированного теста пользовательского интерфейса
В этом пошаговом руководстве создается простое приложение Windows Presentation Foundation (WPF), чтобы с его помощью продемонстрировать создание, редактирование и обслуживание закодированного теста пользовательского интерфейса. В этом пошаговом руководстве приведены решения для корректировки тестов с проблемами, связанными со временем и рефакторингом элементов управления.  
  
## <a name="prerequisites"></a>Предварительные требования  
 Для этого пошагового руководства требуется следующее:  
  
-   Visual Studio Enterprise  
  
### <a name="create-a-simple-wpf-application"></a>Создание простого приложения WPF  
  
1.  В меню **Файл** наведите указатель мыши на элемент **Создать** и выберите **Проект**.  
  
     Откроется диалоговое окно **Новый проект** .  
  
2.  В области **Установленные** разверните узел **Visual C#** и выберите **Рабочий стол Windows**.  
  
3.  Убедитесь, что над средней областью в раскрывающемся списке требуемой версии .NET Framework выбрано значение **.NET Framework 4.5**.  
  
4.  В средней области выберите шаблон **Приложение WPF**.  
  
5.  В текстовом поле **Имя** введите **SimpleWPFApp**.  
  
6.  Выберите папку для хранения проекта. В текстовом поле **Расположение** введите имя папки.  
  
7.  Нажмите кнопку **ОК**.  
  
     Откроется конструктор WPF для Visual Studio, где будет открыто окно MainWindow проекта.  
  
8.  Если панель элементов еще не открыта, откройте ее. Откройте меню **Вид** и щелкните **Панель элементов**.  
  
9. В разделе **Все элементы управления WPF** перетащите элементы управления **Кнопка**, **CheckBox** и **ProgressBar** в окно MainWindow в рабочей области конструирования.  
  
10. Выберите элемент управления "Кнопка". В окне "Свойства" измените значение свойства **Имя** с \<No Name> на button1. Затем измените значение свойства **Содержимое** с "Button" на "Start".  
  
11. Выберите элемент управления ProgressBar. В окне "Свойства" измените значение свойства **Имя** с \<No Name> на progressBar1. Затем измените значение свойства **Максимум** с **100** на **10000**.  
  
12. Выберите элемент управления Checkbox. В окне "Свойства" измените значение свойства **Имя** с \<No Name> на checkBox1 и очистите свойство **IsEnabled**.  
  
     ![Простое приложение WPF](../test/media/codedui_wpfapp.png "CodedUI_WPFApp")  
  
13. Дважды щелкните элемент управления "Кнопка", чтобы добавить обработчик события щелчка.  
  
     В редакторе кода откроется файл MainWindow.xmal.cs, курсор будет установлен на новом методе button1_Click.  
  
14. В начале класса MainWindow добавьте делегат. Этот делегат будет использоваться для индикатора выполнения. Чтобы добавить делегат, добавьте следующий код.  
  
    ```csharp  
    public partial class MainWindow : Window  
    {  
            private delegate void ProgressBarDelegate(System.Windows.DependencyProperty dp, Object value);          
  
        public MainWindow()  
        {  
  
            InitializeComponent();  
        }  
  
    ```  
  
15. В метод button1_Click добавьте следующий код.  
  
    ```csharp  
    private void button1_Click(object sender, RoutedEventArgs e)  
    {  
        double progress = 0;  
  
        ProgressBarDelegate updatePbDelegate =  
            new ProgressBarDelegate(progressBar1.SetValue);  
  
        do  
        {  
            progress ++;  
  
            Dispatcher.Invoke(updatePbDelegate,  
                System.Windows.Threading.DispatcherPriority.Background,  
                new object[] { ProgressBar.ValueProperty, progress });  
            progressBar1.Value = progress;  
        }  
        while (progressBar1.Value != progressBar1.Maximum);  
  
        checkBox1.IsEnabled = true;  
    }  
  
    ```  
  
16. Сохраните файл.  
  
### <a name="verify-the-wpf-application-runs-correctly"></a>Проверка корректной работы приложения WPF  
  
1.  В меню **Отладка** выберите **Начать отладку** или нажмите клавишу **F5**.  
  
2.  Обратите внимание, что элемент управления флажком отключен. Щелкните **Start**.  
  
     Через несколько секунд индикатор выполнения должен дойти до 100%.  
  
3.  Теперь вы можете выбрать элемент управления.  
  
4.  Закройте приложение SimpleWPFApp.  
  
### <a name="create-and-run-a-coded-ui-test-for-simplewpfapp"></a>Создание и запуск закодированного теста пользовательского интерфейса для приложения SimpleWPFApp  
  
1.  Найдите созданное ранее приложение SimpleWPFApp. По умолчанию приложение расположено по следующему пути: C:\Users\\<username\>\Documents\Visual Studio \<version>\Projects\SimpleWPFApp\SimpleWPFApp\bin\Debug\SimpleWPFApp.exe.  
  
2.  Создайте на рабочем столе ярлык для приложения SimpleWPFApp. Щелкните правой кнопкой мыши файл SimpleWPFApp.exe и выберите команду **Копировать**. Щелкните правой кнопкой мыши на рабочем столе и выберите **Вставить ярлык**.  
  
    > [!TIP]
    >  Ярлык облегчает добавление и изменение закодированных тестов пользовательского интерфейса для приложения, так как позволяет быстро запустить приложение.  
  
3.  В обозревателе решений щелкните правой кнопкой мыши решение, выберите команду **Добавить** и пункт **Новый проект**.  
  
     Откроется диалоговое окно **Добавление нового проекта** .  
  
4.  В области **Установленные** разверните узел **Visual C#** и выберите **Тест**.  
  
5.  В средней области выберите шаблон **Проект закодированных тестов пользовательского интерфейса**.  
  
6.  Нажмите кнопку **ОК**.  
  
     В обозреватель решений добавится новый проект закодированных тестов пользовательского интерфейса с именем **CodedUITestProject1**.  
  
     Откроется диалоговое окно **Формирование кода для кодированного теста пользовательского интерфейса**.  
  
7.  Выберите параметр **Записать действия, изменить карту ИП или добавить утверждения** и нажмите кнопку **ОК**.  
  
     Откроется окно "UIMap — построитель кодированных тестов ИП", а окно Visual Studio свернется.  
  
     Дополнительные сведения о параметрах в этом диалоговом окне см. в разделе [Создание закодированных тестов пользовательского интерфейса](../test/use-ui-automation-to-test-your-code.md#VerifyingCodeUsingCUITCreate).  
  
8.  Щелкните **Начать запись** в окне "UIMap — построитель кодированных тестов ИП".  
  
     ![Начать запись](../test/media/cuit_builder_record.png "CUIT_Builder_Record")  
  
     Вы можете приостановить запись, например если вы работаете с входящей почтой.  
  
     ![Приостановка записи](../test/media/cuit_.png "CUIT_")  
  
    > [!WARNING]
    >  Все действия, выполненные на рабочем столе, будут записаны. Приостановите запись, если вы выполняете действия, которые могут привести к записи конфиденциальных данных.  
  
9. Запустите приложение SimpleWPFApp с помощью ярлыка на рабочем столе.  
  
     Обратите внимание, что, как и ранее, элемент управления флажком отключен.  
  
10. В SimpleWPFApp щелкните **Запуск**.  
  
     Через несколько секунд индикатор выполнения должен дойти до 100%.  
  
11. Установите флажок, который теперь включен.  
  
12. Закройте приложение SimpleWPFApp.  
  
13. В окне "UIMap — Построитель кодированных тестов ИП" щелкните **Создать код**.  
  
14. В поле "Имя метода" введите **SimpleAppTest** и щелкните **Добавить и сформировать**. Через несколько секунд закодированный тест пользовательского интерфейса будет сформирован и добавлен в решение.  
  
15. Закройте окно "UIMap — построитель кодированных тестов ИП".  
  
     В редакторе кода откроется файл CodedUITest1.cs.  
  
16. Сохраните проект.  
  
### <a name="run-the-coded-ui-test"></a>Запустите закодированный тест пользовательского интерфейса.  
  
1.  В меню **Тест** выберите **Windows**, а затем выберите **Обозреватель тестов**.  
  
2.  В меню **Сборка** выберите пункт **Собрать решение**.  
  
3.  В файле CodedUITest1.cs найдите метод **CodedUITestMethod**, щелкните его правой кнопкой мыши и выберите **Выполнить тесты** или запустите тест в обозревателе тестов.  
  
     Пока выполняется закодированный тест пользовательского интерфейса, открыто приложение SimpleWPFApp. Выполняются шаги, которые вы выполняли в предыдущей процедуре. Однако когда тест попытается установить флажок для элемента управления флажком, в окне результатов теста появится сообщение, что тест не пройден. Это происходит потому, что тест пытается установить флажок, но не учитывает, что элемент управления флажком недоступен, пока индикатор выполнения не дойдет до 100 %. Эту и аналогичные проблемы можно решить с помощью различных методов `UITestControl.WaitForControlXXX()`, которые доступны для кодированных тестов пользовательского интерфейса. В следующей процедуре демонстрируется использование метода `WaitForControlEnabled()` для исправления ошибки, в результате которой тест выполнен неудачно. Дополнительные сведения см. в разделе [Настройка закодированного теста пользовательского интерфейса таким образом, чтобы во время воспроизведения он дожидался определенных событий](../test/making-coded-ui-tests-wait-for-specific-events-during-playback.md).  
  
### <a name="edit-and-rerun-the-coded-ui-test"></a>Редактирование и повторный запуск закодированного теста пользовательского интерфейса  
  
1.  В окне обозревателя тестов выберите завершившийся неудачей тест и в разделе **StackTrace** выберите первую ссылку на **UIMap.SimpleAppTest()**.  
  
2.  Откроется файл UIMap.Designer.cs, где в коде будет выделено место ошибки.  
  
    ```csharp  
  
    // Select 'CheckBox' check box  
    uICheckBoxCheckBox.Checked = this.SimpleAppTestParams.UICheckBoxCheckBoxChecked;  
    ```  
  
3.  Для исправления ошибки можно с помощью метода `WaitForControlEnabled()` сделать так, чтобы закодированный тест пользовательского интерфейса ждал включения элемента управления CheckBox перед переходом к этой строке.  
  
    > [!WARNING]
    >  Не изменяйте файл UIMap.Designer.cs. Любые изменения кода, внесенные в файл UIMapDesigner.cs, будут перезаписываться каждый раз при создании кода с помощью построителя кодированных тестов ИП. Если требуется изменить записанный метод, необходимо скопировать его в файл UIMap.cs и переименовать. Файл UIMap.cs можно использовать для переопределения методов и свойств в файле UIMapDesigner.cs. Необходимо удалить ссылку на исходный метод в файле CodedUITest.cs и заменить ее именем переименованного метода.  
  
4.  В обозревателе решений найдите **UIMap.uitest** в проекте с закодированными тестами пользовательского интерфейса.  
  
5.  Откройте контекстное меню **UIMap.uitest** и нажмите кнопку **Открыть**.  
  
     Закодированный тест пользовательского интерфейса откроется в редакторе закодированных тестов пользовательского интерфейса. Теперь закодированный тест пользовательского интерфейса можно просматривать и редактировать.  
  
6.  В области **Действие с ИП** выберите метод теста (SimpleAppTest), который требуется переместить в файл UIMap.cs или UIMap.vb, чтобы повысить функциональность пользовательского кода. Теперь файл не будет переписываться при каждой компиляции кода теста.  
  
7.  На панели инструментов редактора закодированных тестов пользовательского интерфейса нажмите кнопку **Переместить код**.  
  
8.  Откроется диалоговое окно Microsoft Visual Studio. В нем отобразится предупреждение о том, что метод будет перемещен из файла UIMap.uitest в файл UIMap.cs, после чего метод нельзя будет изменять в редакторе закодированных тестов пользовательского интерфейса. Выберите **Да**.  
  
     Метод теста удаляется из файла UIMap.uitest и перестает отображаться в области "Действия с ИП". Чтобы внести изменения в перемещенный тестовый файл, откройте файл UIMap.cs в обозревателе решений.  
  
9. На панели инструментов [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] щелкните **Сохранить**.  
  
     Изменения метода теста сохраняются в файле UIMap.Designer.  
  
    > [!CAUTION]
    >  После того как метод перемещен, его нельзя редактировать в редакторе закодированных тестов пользовательского интерфейса. Для добавления и обслуживания пользовательского кода следует использовать редактор кода.  
  
10. Переименуйте метод из `SimpleAppTest()` в `ModifiedSimpleAppTest()`.  
  
11. Добавьте в файл следующую инструкцию.  
  
    ```csharp  
  
    using Microsoft.VisualStudio.TestTools.UITesting.WpfControls;  
  
    ```  
  
12. Перед найденной ранее строкой кода с ошибкой добавьте следующий метод `WaitForControlEnabled()`.  
  
    ```csharp  
  
              uICheckBoxCheckBox.WaitForControlEnabled();  
  
    // Select 'CheckBox' check box  
    uICheckBoxCheckBox.Checked = this.SimpleAppTestParams.UICheckBoxCheckBoxChecked;  
  
    ```  
  
13. В файле CodedUITest1.cs найдите метод **CodedUITestMethod** и закомментируйте его, либо переименуйте ссылку на исходный метод SimpleAppTest(), указав в ней новый метод ModifiedSimpleAppTest().  
  
    ```csharp  
    [TestMethod]  
            public void CodedUITestMethod1()  
            {  
                // To generate code for this test, select "Generate Code for Coded UI Test" from the shortcut menu and select one of the menu items.  
                // For more information on generated code, see http://go.microsoft.com/fwlink/?LinkId=179463  
                //this.UIMap.SimpleAppTest();  
                this.UIMap.ModifiedSimpleAppTest();  
            }  
  
    ```  
  
14. В меню **Сборка** выберите **Собрать решение**.  
  
15. Щелкните правой кнопкой мыши метод **CodedUITestMethod** и выберите команду **Выполнить тесты**.  
  
16. Теперь закодированный тест пользовательского интерфейса успешно выполнит все этапы тестирования, и в окне обозревателя тестов отобразится сообщение **Тест пройден**.  
  
### <a name="refactor-a-control-in-the-simplewpfapp"></a>Рефакторинг элемента управления в приложении SimpleWPFApp  
  
1.  В конструкторе в файле MainWindow.xaml выберите элемент управления "Кнопка".  
  
2.  В верхней части окна "Свойства" измените значение свойства **Имя** с button1 на buttonA.  
  
3.  В меню **Сборка** выберите **Собрать решение**.  
  
4.  В обозревателе тестов выполните **CodedUITestMethod1**.  
  
     Тест не был пройден, поскольку закодированный тест пользовательского интерфейса не смог обнаружить кнопку, которая раньше была сопоставлена в UIMap как button1. Таким образом рефакторинг может влиять на закодированные тесты пользовательского интерфейса.  
  
5.  В окне обозревателя тестов в разделе **StackTrace** щелкните первую ссылку рядом с **UIMpa.ModifiedSimpleAppTest()**.  
  
     Откроется файл UIMap.cs. В коде выделено место, где произошла ошибка.  
  
    ```csharp  
  
    // Click 'Start' button  
    Mouse.Click(uIStartButton, new Point(27, 10));  
    ```  
  
     Обратите внимание, что в строке кода, приведенной ранее в этой процедуре, используется имя `UiStartButton` — имя UIMap до рефакторинга.  
  
     Чтобы исправить ошибку, можно добавить элемент управления, для которого был выполнен рефакторинг, в UIMap с помощью построителя кодированных тестов ИП. Можно обновить код теста для использования кода, как показано в следующей процедуре.  
  
### <a name="map-refactored-control-and-edit-and-rerun-the-coded-ui-test"></a>Сопоставление элемента управления, для которого был выполнен рефакторинг; редактирование и повторный запуск закодированного теста пользовательского интерфейса  
  
1.  В файле CodedUITest1.cs в методе **CodedUITestMethod1()** щелкните правой кнопкой мыши, выберите **Сформировать код для кодированного теста пользовательского интерфейса** и щелкните **Использовать построитель закодированных тестов пользовательского интерфейса**.  
  
     Откроется окно "UIMap — построитель кодированных тестов ИП".  
  
2.  В помощью созданного ранее ярлыка на рабочем столе запустите созданное ранее приложение SimpleWPFApp.  
  
3.  В окне "UIMap — построитель закодированных тестов пользовательского интерфейса" переместите инструмент в виде перекрестия на кнопку **Пуск** приложения SimpleWPFApp.  
  
     Кнопка **Пуск** будет заключена в голубую рамку, построитель закодированных тестов пользовательского интерфейса обработает данные для выбранного элемента управления и через несколько секунд отобразит его свойства. Обратите внимание, что **AutomationUId** называется **buttonA**.  
  
4.  В окне свойств элемента управления щелкните стрелку в левом верхнем углу, чтобы развернуть карту элементов управления ИП. Обратите внимание, что выбран элемент **UIStartButton1**.  
  
5.  На панели инструментов щелкните **Добавить элемент управления на карту элементов управления ИП**.  
  
     Сообщение о состоянии в нижней части окна подтвердит действие следующим сообщением: **Выбранный элемент управления добавлен на карту элементов управления ИП**.  
  
6.  В окне "UIMap — Построитель кодированных тестов ИП" щелкните **Создать код**.  
  
     Отобразится окно "Построитель кодированных тестов ИП — формирование кода" с примечанием, что новый метод не требуется и что код будет сформирован только для изменений карты элементов управления ИП.  
  
7.  Щелкните **Создать**.  
  
8.  Закройте приложение SimpleWPFApp.exe.  
  
9. Закройте диалоговое окно "UIMap — построитель кодированных тестов ИП".  
  
     Обработка изменений в карте элементов управления ИП в окне "UIMap — построитель кодированных тестов ИП" займет несколько секунд.  
  
10. В обозревателе решений откройте файл UIMap.Designer.cs.  
  
11. В файле UIMap.Designer.cs найдите свойство UIStartButton1. Обратите внимание, что `SearchProperties` имеет значение `"buttonA"`:  
  
    ```csharp  
  
    public WpfButton UIStartButton1  
            {  
                get  
                {  
                    if ((this.mUIStartButton1 == null))  
                    {  
                        this.mUIStartButton1 = new WpfButton(this);  
                        #region Search Criteria  
                        this.mUIStartButton1.SearchProperties[WpfButton.PropertyNames.AutomationId] = "buttonA";  
                        this.mUIStartButton1.WindowTitles.Add("MainWindow");  
                        #endregion  
                    }  
                    return this.mUIStartButton1;  
                }  
            }  
  
    ```  
  
     Теперь закодированный тест пользовательского интерфейса можно изменить, чтобы использовать только что сопоставленный элемент управления. Как указано в предыдущей процедуре, если требуется переопределить какие-либо методы или свойства в закодированном тесте пользовательского интерфейса, это нужно делать в файле UIMap.cs.  
  
12. В файле UIMap.cs добавьте конструктор и задайте свойство `SearchProperties` свойства `UIStartButton`, чтобы использовать свойство `AutomationID` со значением `"buttonA":`  
  
    ```csharp  
  
    public UIMap()  
            {  
                this.UIMainWindowWindow.UIStartButton.SearchProperties[WpfButton.PropertyNames.AutomationId] = "buttonA";  
            }  
  
    ```  
  
13. В меню **Сборка** выберите **Собрать решение**.  
  
14. В обозревателе тестов выполните CodedUITestMethod1.  
  
     Теперь закодированный тест пользовательского интерфейса успешно пройдет все этапы тестирования.  В окне результатов теста отобразится состояние **Тест пройден**.  
  
## <a name="external-resources"></a>Внешние ресурсы  
  
### <a name="videos"></a>Видеоролики  
 ![ссылка на видео](../data-tools/media/playvideo.gif "PlayVideo") [Coded UI Tests-DeepDive-Episode1-GettingStarted](http://go.microsoft.com/fwlink/?LinkID=230573)  
  
 ![ссылка на видео](../data-tools/media/playvideo.gif "PlayVideo") [Coded UI Tests-DeepDive-Episode2-MaintainenceAndDebugging](http://go.microsoft.com/fwlink/?LinkID=230574)  
  
 ![ссылка на видео](../data-tools/media/playvideo.gif "PlayVideo") [Coded UI Tests-DeepDive-Episode3-HandCoding](http://go.microsoft.com/fwlink/?LinkID=230575)  
  
### <a name="hands-on-lab"></a>Практическое лабораторное занятие  
 [Виртуальная лаборатория MSDN. Введение в создание тестов пользовательского интерфейса с помощью Visual Studio 2010](http://go.microsoft.com/fwlink/?LinkID=22508)  
  
### <a name="faq"></a>часто задаваемые вопросы  
 [Часто задаваемые вопросы о закодированных тестах пользовательского интерфейса. Часть 1](http://go.microsoft.com/fwlink/?LinkID=230576)  
  
 [Часто задаваемые вопросы о закодированных тестах пользовательского интерфейса. Часть 2](http://go.microsoft.com/fwlink/?LinkID=230578)  
  
### <a name="forum"></a>Форум  
 [Тестирование автоматизации пользовательского интерфейса в Visual Studio (включает CodedUI)](http://go.microsoft.com/fwlink/?LinkID=224497)  
  
## <a name="see-also"></a>См. также  
 [Использование модели автоматизации пользовательского интерфейса для тестирования кода](../test/use-ui-automation-to-test-your-code.md)   
 [Начало работы с конструктором WPF](http://msdn.microsoft.com/en-us/18e61d03-b96a-4058-a166-8ec6b3f6116b)   
 [Поддерживаемые конфигурации и платформы для закодированных тестов пользовательского интерфейса и записей действий](../test/supported-configurations-and-platforms-for-coded-ui-tests-and-action-recordings.md)   
 [Изменение закодированных тестов пользовательского интерфейса с помощью редактора закодированных тестов пользовательского интерфейса](../test/editing-coded-ui-tests-using-the-coded-ui-test-editor.md)

