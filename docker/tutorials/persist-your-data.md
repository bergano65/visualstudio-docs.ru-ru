---
title: Учебник по Docker. Часть 4. Сохранение данных
description: Узнайте, как сохранять данные в базе данных и совместно использовать каталоги в контейнере путем подключения тома.
ms.date: 08/04/2020
author: nebuk89
ms.author: ghogen
manager: jillfra
ms.technology: vs-azure
ms.topic: conceptual
ms.workload:
- azure
ms.openlocfilehash: 34b3cb9465c1efb946260917d755729e25c4e259
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/02/2020
ms.locfileid: "89176793"
---
# <a name="persist-your-data"></a> Сохранение данных

Если вы не заметили, список задач очищается каждый раз при запуске контейнера. Почему? Давайте подробно рассмотрим работу контейнера.

## <a name="the-containers-filesystem"></a>Файловая система контейнера

При запуске контейнера он использует различные слои из образа для своей файловой системы. Каждый контейнер также получает собственную "область временных файлов" для создания, обновления и удаления файлов. Никакие изменения не будут видны другому контейнеру, *даже если* они используют один и тот же образ.

### <a name="see-this-in-practice"></a>Рассмотрим это на практике

Чтобы увидеть это в действии, необходимо запустить два контейнера и создать файл в каждом из них. Вы увидите, что файлы, созданные в одном контейнере, недоступны в другом.

1. Запустите контейнер `ubuntu`, который создаст файл с именем `/data.txt` со случайным числом от 1 до 10 000.

    ```bash
    docker run -d ubuntu bash -c "shuf -i 1-10000 -n 1 -o /data.txt && tail -f /dev/null"
    ```

    Если вас интересует команда, то она запускает оболочку bash и вызывает две команды (поэтому в ней есть оператор `&&`). Первая часть выбирает одно случайное число и записывает его в файл `/data.txt`. Вторая команда просто наблюдает за файлом, чтобы работа контейнера не завершалась.

1. Убедитесь, что вы можете увидеть результат, используя `exec`, чтобы попасть в контейнер. Для этого откройте расширение VS Code и выберите команду **Attach Shell** (Присоединить оболочку). Эта команда использует `exec`, чтобы открыть оболочку контейнера в терминале VS Code.

    ![Открыть интерфейс командной строки VS Code в контейнере ubuntu](media/attach_shell.png)

    Откроется терминал с запущенной оболочкой в контейнере Ubuntu. Выполните следующую команду, чтобы просмотреть содержимое файла `/data.txt`. Затем снова закройте этот терминал.

    ```bash
    cat /data.txt
    ```

    Если вы предпочитаете командную строку, то для получения того же результата можно использовать команду `docker exec`. Необходимо получить идентификатор контейнера (используйте команду `docker ps` для его получения) и получить содержимое с помощью следующей команды.

    ```bash
    docker exec <container-id> cat /data.txt
    ```

    Должно отобразиться случайное число.

1. Теперь запустите другой контейнер `ubuntu` (тот же образ), и вы увидите, что у вас нет этого файла.

    ```bash
    docker run -it ubuntu ls /
    ```

    Смотрите! Файла `data.txt` нет. Это обусловлено тем, что он был записан в область временных файлов только для первого контейнера.

1. Удалите первый контейнер с помощью команды `docker rm -f`.

## <a name="container-volumes"></a>Тома контейнеров

В предыдущем эксперименте вы увидели, что каждый контейнер начинается с определения образа при каждом запуске. Хотя контейнеры могут создавать, обновлять и удалять файлы, эти изменения теряются при удалении контейнера и они изолируются в этом контейнере. С помощью томов можно изменить это поведение.

[Тома](https://docs.docker.com/storage/volumes/) обеспечивают возможность подключения конкретных путей файловой системы контейнера к хост-компьютеру. Если каталог в контейнере подключен, изменения в этом каталоге также будут видны и на хост-компьютере. Если подключить этот же каталог после перезапуска контейнера, то будут отображаться те же файлы.

Существует два основных типа томов. Мы будем использовать оба, но начнем с **именованных томов**.

## <a name="persist-your-todo-data"></a>Сохранение данных списка задач

По умолчанию приложение todo сохраняет данные в базе данных [SQLite](https://www.sqlite.org/index.html) в `/etc/todos/todo.db`. Если вы не знакомы с SQLite, не стоит беспокоиться. Это просто реляционная база данных, в которой все данные хранятся в одном файле. Хотя это и не лучшее решение для масштабных приложений, она хорошо подходит для небольших примеров. Мы поговорим о переходе на полноценную базу данных позже.

Поскольку база данных представляет собой один файл, если вы можете сохранить его на хосте и сделать его доступным для следующего контейнера, он сможет продолжить работу с того места, где остановился предыдущий. Создавая том и присоединяя его (или "подключая") к каталогу, в котором хранятся данные, можно сохранить данные. Когда контейнер записывает данные в файл `todo.db`, он сохраняется на узле в томе.

Как уже упоминалось, мы будем использовать **именованный том**. Именованный том следует рассматривать как просто набор данных. Docker сохраняет физическое расположение на диске, и вам нужно запомнить только имя тома. При каждом использовании тома Docker обеспечивает правильность предоставленных данных.

1. Создайте том с помощью команды `docker volume create`.

    ```bash
    docker volume create todo-db
    ```

1. Снова закройте контейнер приложения todo на панели мониторинга (или с помощью команды `docker rm -f <id>`), так как он все еще выполняется без использования постоянного тома.

1. Запустите контейнер приложения todo, но добавьте флаг `-v`, чтобы указать подключение тома. Мы будем использовать именованный том и подключим его к папке `/etc/todos`, и он будет записывать все файлы, созданные по этому пути.

    ```bash
    docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started
    ```

1. После запуска контейнера откройте приложение и добавьте несколько пунктов в список дел.

    ![Пункты, добавленные в список дел](media/items-added.png)

1. Удалите контейнер приложения todo. Используйте панель мониторинга или команду `docker ps` для получения идентификатора контейнера и команду `docker rm -f <id>` для его удаления.

1. Запустите новый контейнер с помощью команды, которую мы использовали выше.

1. Запустите приложение. Вы должны увидеть, что элементы по-прежнему находятся в вашем списке!

1. После просмотра списка удалите контейнер.

Поздравляем! Теперь вы узнали, как сохранять данные.

> [!TIP]
> Хотя именованные тома и подключения BIND (которые мы обсудим через минуту) — это два основных типа томов, поддерживаемых установкой подсистемы Docker по умолчанию, существует множество подключаемых модулей драйверов томов для поддержки NFS, SFTP, NetApp и многих других технологий. Это будет особенно важно после запуска контейнеров на нескольких узлах в кластерной среде с помощью Swarm, Kubernetes и т. д.

## <a name="dive-into-your-volume"></a>Подробнее о томах

Многие люди часто спрашивают: "где *на самом деле* хранятся данные при использовании именованного тома?" Если вы хотите узнать это, используйте команду `docker volume inspect`.

```bash
docker volume inspect todo-db
[
    {
        "CreatedAt": "2019-09-26T02:18:36Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/todo-db/_data",
        "Name": "todo-db",
        "Options": {},
        "Scope": "local"
    }
]
```

`Mountpoint` — это фактическое расположение на диске, в котором хранятся данные. Обратите внимание, что на большинстве компьютеров необходимы права администратора для доступа к этому каталогу с хоста. Именно здесь они и хранятся.

> [!NOTE]
> **Доступ к данным тома непосредственно в Docker Desktop**. При работе в Docker Desktop команды Docker на самом деле выполняются внутри небольшой виртуальной машины на компьютере. Если вы хотите просмотреть фактическое содержимое каталога *Mountpoint*, сначала необходимо получить его в виртуальной машине. В WSL 2 он находится внутри дистрибутива WSL 2, и доступ к нему можно получить с помощью проводника.

## <a name="recap"></a>Резюме

На этом этапе у вас есть работающее приложение, которое может выдерживать перезапуски. Вы можете продемонстрировать его своим инвесторам и надеяться на то, что они поймут ваше видение.

Однако вы уже видели, что перестроение образов для каждого изменения занимает довольно много времени. Есть же лучший способ вносить изменения, верно? При использовании подключений BIND (которые мы уже упоминали ранее) существует лучший способ. Давайте рассмотрим это прямо сейчас!

## <a name="next-steps"></a>Дальнейшие действия

Продолжайте изучать учебник.

> [!div class="nextstepaction"]
> [Использование подключения BIND](use-bind-mounts.md)
